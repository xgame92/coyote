{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Concurrency Unit Testing with Coyote Coyote is .NET library and tool designed to help ensure that your code is free of concurrency bugs. Too often developers are drowning in the complexity of their own code and many hours are wasted trying to track down impossible-to-find bugs, especially when dealing with concurrent code or various other sources of non-determinism (like message ordering, failures, timeouts and so on). var captions = [[0, \"This animation shows messages passing through a highly parallel distributed system.\"], [5, \"Each node represents a microservice or a piece of code running on some machine.\"], [10, \"Messages are flying through this system in a way that makes it hard to debug when something goes wrong.\"], [16, \"Coyote tests one async path at a time exploring all possible paths through the system and it does this very quickly\"], [23, \"It also records this path so that when it finds a bug that bug is 100% reproducible.\"] ]; function show_captions(video, caption){ var time = video.currentTime; var line = null; for (var i = 0; i < captions.length; i++) { var nextline = captions[i]; if (nextline[0] > time) break; line = nextline; } if (line != null) { caption.style.display=\"block\"; caption.innerHTML = line[1] } else { caption.style.display=\"none\"; } } $(document).ready(function () { video = $(\"#shortintro\")[0]; caption = $(\"#caption\")[0]; caption.style.display=\"none\"; video.ontimeupdate = function() { show_captions(video, caption); }; }); Coyote helps write powerful, expressive tests for your code. We call these concurrency unit tests . You can declare sources of non-determinism (such as timeouts and failures) as part of your Coyote tests. The Coyote testing tool can systematically explore a large number of interleavings of concurrent operations as well as non-deterministic choices so that it covers a large set of behaviors in a very short time. This is different from stress testing . Coyote takes control of the concurrency so that it can manipulate every possible scheduling. With appropriate mocking , Coyote can also do this in \u201cdeveloper\u201d mode on a single laptop with little or no dependence on the bigger production environment. Coyote is not a verification system. It does not use theorem proving to make correctness guarantees, instead it uses intelligent search strategies to drive systematic testing, based on deep understanding of concurrency primitives that you have used in your code. This approach has proven to work well for large production teams, including many teams in Microsoft Azure because it has a small barrier to entry with almost immediate benefits for those who adopt it. Coyote does not require that a team starts from scratch and rebuilds their system. Coyote uses binary rewriting during test time to take control of the concurrency in your unmodified code. For advanced users, Coyote also provides a powerful in-memory actor and state machine programming model that allows you to build reliable concurrent systems from the ground up. This programming model allows you to program at a high-level of abstraction. Coyote actors are built using asynchronous C# APIs, supported by a lightweight runtime, making it easy to program efficient non-blocking code. So Coyote brings together elements of design, development and testing into an integrated package that works really well in the real world. See our case studies for some great customer testimonials. Fearless coding for concurrent software Using Coyote gives your team much more confidence in building mission-critical services that also push the limits on high concurrency, maximizing throughput and minimizing operational costs. With Coyote you can create highly reliable software in a way that is also highly productive. These are some direct quotes from Azure Engineers that use Coyote: We often found bugs with Coyote in a matter of minutes that would have taken days with stress testing. Coyote added agility and allowed progress at a much faster pace. Features were developed in a test environment to first pass the Coyote tester. When dropped in production, they simply worked from the start. Coyote gave developers a significant confidence boost by providing full failover and concurrency testing at each check-in, right on their desktops as the code was written. Explore Coyote Get started with the following links: Watch a video overview of Coyote Learn about the key benefits of using Coyote Install the NuGet package and CLI tool, it is super easy Learn how to use Coyote in practice Read about core concepts behind Coyote Try to find concurrency bugs in this interactive demo Learn how various Azure teams are using Coyote Contribute on Github","title":"Home"},{"location":"#concurrency-unit-testing-with-coyote","text":"Coyote is .NET library and tool designed to help ensure that your code is free of concurrency bugs. Too often developers are drowning in the complexity of their own code and many hours are wasted trying to track down impossible-to-find bugs, especially when dealing with concurrent code or various other sources of non-determinism (like message ordering, failures, timeouts and so on). var captions = [[0, \"This animation shows messages passing through a highly parallel distributed system.\"], [5, \"Each node represents a microservice or a piece of code running on some machine.\"], [10, \"Messages are flying through this system in a way that makes it hard to debug when something goes wrong.\"], [16, \"Coyote tests one async path at a time exploring all possible paths through the system and it does this very quickly\"], [23, \"It also records this path so that when it finds a bug that bug is 100% reproducible.\"] ]; function show_captions(video, caption){ var time = video.currentTime; var line = null; for (var i = 0; i < captions.length; i++) { var nextline = captions[i]; if (nextline[0] > time) break; line = nextline; } if (line != null) { caption.style.display=\"block\"; caption.innerHTML = line[1] } else { caption.style.display=\"none\"; } } $(document).ready(function () { video = $(\"#shortintro\")[0]; caption = $(\"#caption\")[0]; caption.style.display=\"none\"; video.ontimeupdate = function() { show_captions(video, caption); }; }); Coyote helps write powerful, expressive tests for your code. We call these concurrency unit tests . You can declare sources of non-determinism (such as timeouts and failures) as part of your Coyote tests. The Coyote testing tool can systematically explore a large number of interleavings of concurrent operations as well as non-deterministic choices so that it covers a large set of behaviors in a very short time. This is different from stress testing . Coyote takes control of the concurrency so that it can manipulate every possible scheduling. With appropriate mocking , Coyote can also do this in \u201cdeveloper\u201d mode on a single laptop with little or no dependence on the bigger production environment. Coyote is not a verification system. It does not use theorem proving to make correctness guarantees, instead it uses intelligent search strategies to drive systematic testing, based on deep understanding of concurrency primitives that you have used in your code. This approach has proven to work well for large production teams, including many teams in Microsoft Azure because it has a small barrier to entry with almost immediate benefits for those who adopt it. Coyote does not require that a team starts from scratch and rebuilds their system. Coyote uses binary rewriting during test time to take control of the concurrency in your unmodified code. For advanced users, Coyote also provides a powerful in-memory actor and state machine programming model that allows you to build reliable concurrent systems from the ground up. This programming model allows you to program at a high-level of abstraction. Coyote actors are built using asynchronous C# APIs, supported by a lightweight runtime, making it easy to program efficient non-blocking code. So Coyote brings together elements of design, development and testing into an integrated package that works really well in the real world. See our case studies for some great customer testimonials.","title":"Concurrency Unit Testing with Coyote"},{"location":"#fearless-coding-for-concurrent-software","text":"Using Coyote gives your team much more confidence in building mission-critical services that also push the limits on high concurrency, maximizing throughput and minimizing operational costs. With Coyote you can create highly reliable software in a way that is also highly productive. These are some direct quotes from Azure Engineers that use Coyote: We often found bugs with Coyote in a matter of minutes that would have taken days with stress testing. Coyote added agility and allowed progress at a much faster pace. Features were developed in a test environment to first pass the Coyote tester. When dropped in production, they simply worked from the start. Coyote gave developers a significant confidence boost by providing full failover and concurrency testing at each check-in, right on their desktops as the code was written.","title":"Fearless coding for concurrent software"},{"location":"#explore-coyote","text":"Get started with the following links: Watch a video overview of Coyote Learn about the key benefits of using Coyote Install the NuGet package and CLI tool, it is super easy Learn how to use Coyote in practice Read about core concepts behind Coyote Try to find concurrency bugs in this interactive demo Learn how various Azure teams are using Coyote Contribute on Github","title":"Explore Coyote"},{"location":"case-studies/azure-batch-service/","text":"Azure Batch Service Background Azure Batch Service is a cloud-scale job-scheduling service. Users can submit a parallel job consisting of multiple tasks with a given set of dependencies and Azure Batch Service will execute them on Azure, in dependency order, exploiting as much parallelism as possible between independent tasks. Batch is a popular service, managing over hundreds of thousands of VMs on Azure. Integrating scheduling with virtual machine (VM) management, Azure Batch Service supports auto-scaling the number of VMs created, spinning up or down according to the needs of the job. This differs from many other schedulers\u2014like Yarn or Mesos, for example\u2014that must be installed on a pre-created set of VMs. Challenge The Batch team wanted to invest in a new microservices-based architecture that would reliably scale to meet the demands of the service. The complex responsive design demanded that each microservice be able to: Process requests asynchronously as they arrived. Support cancellation of an in-flight request, enabling quick turnaround for auto-scaling. Be resilient to failures of VMs hosting the service. Solution Coding three of their core microservices with Coyote, the team used Coyote\u2019s state machines programming model for fully asynchronous, non-blocking computation. The team also wrote detailed functional specifications\u2014as well as models of external services\u2014to allow for exhaustive testing of concurrent behaviors and failures. These services totalled to more than 100,000 lines of code. Coyote\u2019s key advantages The Batch team reported several key advantages of developing and testing their code using Coyote. Faster development time: adding a new feature for supporting low-priority VMs to the Coyote code took just one developer month. The same feature took six developer months in the legacy code. Coyote design and testing added agility and allowed progress at a much faster pace. Coyote removed reliance on overly complex, and often inadequate, unit tests for each small component. The Batch team reported that Coyote\u2019s test coverage for end-to-end scenarios was unheard of previously. Features were developed in a test environment to first pass the Coyote tester. When dropped in production, they simply worked from the start. Coyote gave developers a significant confidence boost by providing full failover and concurrency testing at each check-in, right on their desktops as the code was written. Read more about it in this arXiv technical paper . (Note that the paper still refers to P#, the name of the previous incarnation of Coyote.)","title":"Azure Batch Service"},{"location":"case-studies/azure-batch-service/#azure-batch-service","text":"","title":"Azure Batch Service"},{"location":"case-studies/azure-batch-service/#background","text":"Azure Batch Service is a cloud-scale job-scheduling service. Users can submit a parallel job consisting of multiple tasks with a given set of dependencies and Azure Batch Service will execute them on Azure, in dependency order, exploiting as much parallelism as possible between independent tasks. Batch is a popular service, managing over hundreds of thousands of VMs on Azure. Integrating scheduling with virtual machine (VM) management, Azure Batch Service supports auto-scaling the number of VMs created, spinning up or down according to the needs of the job. This differs from many other schedulers\u2014like Yarn or Mesos, for example\u2014that must be installed on a pre-created set of VMs.","title":"Background"},{"location":"case-studies/azure-batch-service/#challenge","text":"The Batch team wanted to invest in a new microservices-based architecture that would reliably scale to meet the demands of the service. The complex responsive design demanded that each microservice be able to: Process requests asynchronously as they arrived. Support cancellation of an in-flight request, enabling quick turnaround for auto-scaling. Be resilient to failures of VMs hosting the service.","title":"Challenge"},{"location":"case-studies/azure-batch-service/#solution","text":"Coding three of their core microservices with Coyote, the team used Coyote\u2019s state machines programming model for fully asynchronous, non-blocking computation. The team also wrote detailed functional specifications\u2014as well as models of external services\u2014to allow for exhaustive testing of concurrent behaviors and failures. These services totalled to more than 100,000 lines of code.","title":"Solution"},{"location":"case-studies/azure-batch-service/#coyotes-key-advantages","text":"The Batch team reported several key advantages of developing and testing their code using Coyote. Faster development time: adding a new feature for supporting low-priority VMs to the Coyote code took just one developer month. The same feature took six developer months in the legacy code. Coyote design and testing added agility and allowed progress at a much faster pace. Coyote removed reliance on overly complex, and often inadequate, unit tests for each small component. The Batch team reported that Coyote\u2019s test coverage for end-to-end scenarios was unheard of previously. Features were developed in a test environment to first pass the Coyote tester. When dropped in production, they simply worked from the start. Coyote gave developers a significant confidence boost by providing full failover and concurrency testing at each check-in, right on their desktops as the code was written. Read more about it in this arXiv technical paper . (Note that the paper still refers to P#, the name of the previous incarnation of Coyote.)","title":"Coyote's key advantages"},{"location":"case-studies/azure-blockchain-service/","text":"Azure Blockchain Service Background Azure\u2019s Blockchain Service allows customers to provision blockchain nodes-as-a-service. It allows setting up consortiums that include blockchain nodes from multiple organizations to govern shared resources. Challenge The Blockchain Service has to deal with the complexity of three sources of concurrency interacting with each other: (1) the incoming user requests, (2) asynchronous processing of those requests within the service and (3) reading and reacting to consortium governance data from the blockchain and taking resulting actions within the service. This interaction sometimes led to rare, but serious bugs, that had the potential of stalling the entire blockchain network. Solution and Coyote\u2019s key advantages The Blockchain Service code heavily utilized .NET tasks and the corresponding async/await style of programming concurrent systems. Integrating Coyote\u2019s Task-based programming model into the system was easy and required minimal effort. The development team wrote mocks for their external dependencies using Coyote. Writing of mocks is common for any kind of unit testing. The Coyote mocks turned out to be concise and it was easy to express a number of safety and failure scenarios in a localized manner. Coyote testing helped repro a couple of known safety and liveness bugs in the system. It also revealed a series of bugs in recent changes that had passed code review as well as manual testing. Coyote testing provides confidence that the system will not regress: once a concurrency issue is found and a corresponding Coyote test is put in place, similar issues get caught out immediately in future code changes. This allowed the team to make progress at a rapid pace.","title":"Azure Blockchain Service"},{"location":"case-studies/azure-blockchain-service/#azure-blockchain-service","text":"","title":"Azure Blockchain Service"},{"location":"case-studies/azure-blockchain-service/#background","text":"Azure\u2019s Blockchain Service allows customers to provision blockchain nodes-as-a-service. It allows setting up consortiums that include blockchain nodes from multiple organizations to govern shared resources.","title":"Background"},{"location":"case-studies/azure-blockchain-service/#challenge","text":"The Blockchain Service has to deal with the complexity of three sources of concurrency interacting with each other: (1) the incoming user requests, (2) asynchronous processing of those requests within the service and (3) reading and reacting to consortium governance data from the blockchain and taking resulting actions within the service. This interaction sometimes led to rare, but serious bugs, that had the potential of stalling the entire blockchain network.","title":"Challenge"},{"location":"case-studies/azure-blockchain-service/#solution-and-coyotes-key-advantages","text":"The Blockchain Service code heavily utilized .NET tasks and the corresponding async/await style of programming concurrent systems. Integrating Coyote\u2019s Task-based programming model into the system was easy and required minimal effort. The development team wrote mocks for their external dependencies using Coyote. Writing of mocks is common for any kind of unit testing. The Coyote mocks turned out to be concise and it was easy to express a number of safety and failure scenarios in a localized manner. Coyote testing helped repro a couple of known safety and liveness bugs in the system. It also revealed a series of bugs in recent changes that had passed code review as well as manual testing. Coyote testing provides confidence that the system will not regress: once a concurrency issue is found and a corresponding Coyote test is put in place, similar issues get caught out immediately in future code changes. This allowed the team to make progress at a rapid pace.","title":"Solution and Coyote's key advantages"},{"location":"case-studies/azure-blockchain-workbench/","text":"Azure Blockchain Workbench Background Azure Blockchain Workbench is a packaged solution that allows users to spin up end-to-end blockchain applications integrated with a number of Azure services with minimal effort on their part. The users provide Workbench with an Ethereum smart contract and associated metadata, and Workbench spins up the requisite Azure infrastructure. Users can authenticate and sign transactions using their AAD identities, submit transactions into the blockchain and consume events and transactions from the blockchain through the event grid as well as through a SQL database with no additional development effort on their part. Challenge Ethereum Transaction Submitter is the component within Workbench responsible for submitting transactions into the blockchain. Blockchains are distributed systems where user-submitted transactions are eventually included (or mined ) into the blockchain. The node through which the transaction is submitted is typically not the one that mines it and can, in fact, even die before gossiping about the transaction to the rest of the network. This requires periodic resubmissions of transactions if they\u2019re not mined. Blockchains also exhibit forks where history can be rewound. In that case, transactions that were successfully mined previously need to be submitted again. Writing a high-throughput service component that can reliably submit transactions into the blockchain is thus a harder problem than it first appears. Solution and Coyote\u2019s key advantages An initial version of the Ethereum Transaction Submitter was facing a number of reliability issues and missed corner cases, so the team decided to write the service component using Coyote. The use of Coyote helped the team in a number of ways. Coyote safety conditions force the user to think about what must be true in all states (aka invariants ) as opposed to the ways in which the system can fail. This helped the team gain clarity in their design. Coyote helped find and fix a liveness condition that would have been near impossible to detect without Coyote\u2019s testing methodology. Blockchains can occasionally fork, which was causing an initial version of the service component to permanently stall. Without a means of reproducing forks in a controlled way, such issues are hard to debug. The Azure team implemented a mock for the blockchain network using Coyote and were then able to systematically introduce a fork during testing. Coyote was able to detect the liveness bug, a fix was implemented, after which Coyote tests passed. As a result, the team had a much higher confidence in deploying their fix. Developing the system using Coyote\u2019s state machine programming model led to a highly concurrent and performant implementation. Coyote allowed the team to concisely state the various success and failure conditions in the individual mocks, leaving the job of exploration to the tester. This allowed the team to effectively have a very large number of (traditional) test cases without having to write them all by hand. Coyote\u2019s deterministic repro of bugs allowed the team to debug and understand the bugs much more easily than before.","title":"Azure Blockchain Workbench"},{"location":"case-studies/azure-blockchain-workbench/#azure-blockchain-workbench","text":"","title":"Azure Blockchain Workbench"},{"location":"case-studies/azure-blockchain-workbench/#background","text":"Azure Blockchain Workbench is a packaged solution that allows users to spin up end-to-end blockchain applications integrated with a number of Azure services with minimal effort on their part. The users provide Workbench with an Ethereum smart contract and associated metadata, and Workbench spins up the requisite Azure infrastructure. Users can authenticate and sign transactions using their AAD identities, submit transactions into the blockchain and consume events and transactions from the blockchain through the event grid as well as through a SQL database with no additional development effort on their part.","title":"Background"},{"location":"case-studies/azure-blockchain-workbench/#challenge","text":"Ethereum Transaction Submitter is the component within Workbench responsible for submitting transactions into the blockchain. Blockchains are distributed systems where user-submitted transactions are eventually included (or mined ) into the blockchain. The node through which the transaction is submitted is typically not the one that mines it and can, in fact, even die before gossiping about the transaction to the rest of the network. This requires periodic resubmissions of transactions if they\u2019re not mined. Blockchains also exhibit forks where history can be rewound. In that case, transactions that were successfully mined previously need to be submitted again. Writing a high-throughput service component that can reliably submit transactions into the blockchain is thus a harder problem than it first appears.","title":"Challenge"},{"location":"case-studies/azure-blockchain-workbench/#solution-and-coyotes-key-advantages","text":"An initial version of the Ethereum Transaction Submitter was facing a number of reliability issues and missed corner cases, so the team decided to write the service component using Coyote. The use of Coyote helped the team in a number of ways. Coyote safety conditions force the user to think about what must be true in all states (aka invariants ) as opposed to the ways in which the system can fail. This helped the team gain clarity in their design. Coyote helped find and fix a liveness condition that would have been near impossible to detect without Coyote\u2019s testing methodology. Blockchains can occasionally fork, which was causing an initial version of the service component to permanently stall. Without a means of reproducing forks in a controlled way, such issues are hard to debug. The Azure team implemented a mock for the blockchain network using Coyote and were then able to systematically introduce a fork during testing. Coyote was able to detect the liveness bug, a fix was implemented, after which Coyote tests passed. As a result, the team had a much higher confidence in deploying their fix. Developing the system using Coyote\u2019s state machine programming model led to a highly concurrent and performant implementation. Coyote allowed the team to concisely state the various success and failure conditions in the individual mocks, leaving the job of exploration to the tester. This allowed the team to effectively have a very large number of (traditional) test cases without having to write them all by hand. Coyote\u2019s deterministic repro of bugs allowed the team to debug and understand the bugs much more easily than before.","title":"Solution and Coyote's key advantages"},{"location":"concepts/binary-rewriting/","text":"Binary rewriting for systematic testing To enable systematic testing of unmodified programs, Coyote performs binary rewriting of managed .NET assemblies. This process loads one or more of your assemblies and rewrites them for systematic testing (for production just use the original unmodified assemblies). This can be easily done in a post-build task. The rewritten code maintains exact semantics with the production version (so you don\u2019t need to worry about false bugs), but has stubs and hooks injected that allow Coyote to take control of concurrent execution and various sources of nondeterminism in a program. To learn how to run the binary rewriter of Coyote before testing your application read here , as well as check out our tutorial on writing your first concurrency unit test . Quality of life improvements through rewriting Coyote will automatically rewrite certain parts of your test code (without changing the application semantics) to improve the testing experience. For example: During testing coyote needs to be able to terminate a test iteration at any time in order to support the --max-steps command line argument. This termination is done using a special coyote ExecutionCancelledException . The problem is when your code contains one of the following: } catch { } catch (Exception) { } catch (RuntimeException) { These will inadvertently catch the special Coyote exception, which then stops --max-steps from working. The recommended fix is to add a when (!(e is Microsoft.Coyote.RuntimeException)) filter. The good news is that coyote rewrite can take care of this for you automatically so you do not need to modify any of your exception handlers.","title":"Binary rewriting for systematic testing"},{"location":"concepts/binary-rewriting/#binary-rewriting-for-systematic-testing","text":"To enable systematic testing of unmodified programs, Coyote performs binary rewriting of managed .NET assemblies. This process loads one or more of your assemblies and rewrites them for systematic testing (for production just use the original unmodified assemblies). This can be easily done in a post-build task. The rewritten code maintains exact semantics with the production version (so you don\u2019t need to worry about false bugs), but has stubs and hooks injected that allow Coyote to take control of concurrent execution and various sources of nondeterminism in a program. To learn how to run the binary rewriter of Coyote before testing your application read here , as well as check out our tutorial on writing your first concurrency unit test .","title":"Binary rewriting for systematic testing"},{"location":"concepts/binary-rewriting/#quality-of-life-improvements-through-rewriting","text":"Coyote will automatically rewrite certain parts of your test code (without changing the application semantics) to improve the testing experience. For example: During testing coyote needs to be able to terminate a test iteration at any time in order to support the --max-steps command line argument. This termination is done using a special coyote ExecutionCancelledException . The problem is when your code contains one of the following: } catch { } catch (Exception) { } catch (RuntimeException) { These will inadvertently catch the special Coyote exception, which then stops --max-steps from working. The recommended fix is to add a when (!(e is Microsoft.Coyote.RuntimeException)) filter. The good news is that coyote rewrite can take care of this for you automatically so you do not need to modify any of your exception handlers.","title":"Quality of life improvements through rewriting"},{"location":"concepts/concurrency-unit-testing/","text":"Concurrency unit testing Coyote gives you the ability to write concurrency unit tests . These simple but very powerful tests look similar to traditional (sequential) tests, but allow (and encourage) the use of concurrency and non-determinism , which you would normally avoid due to flakiness. By writing such a test, Coyote allows you to exercise what happens, for example, when two requests execute concurrently in your service, as if it was deployed in production. Now the cool thing is that once a bug is found, Coyote allows you to fully reproduce the exact same trace that led to the bug 100% of the time, and as many times as you want. Coyote achieves this by automatically replaying all nondeterministic choices in your test that led to this bug. This is a game changer! Let\u2019s see how this kind of testing works in practice. Systematic testing of unmodified programs During testing, Coyote takes over the non-determinism in your program. Once Coyote has control over the non-determinism, it will repeatedly run the concurrency unit test from start to completion, each time exercising a different set of non-deterministic choices, offering much better coverage than using traditional techniques such as stress testing (which rely on luck). This type of testing that Coyote performs is known as systematic testing . This powerful testing ability, however, has one requirement: you must declare all sources of non-determinism in your logic in a way that Coyote understands so that it is able to reproduce any nondeterministic bug that it finds and help you easily debug the issue. Luckily, in most common cases you do not need to do much thanks to the awesome binary rewriting that Coyote does to enable testing of unmodified programs. Out of the box, Coyote supports most common types and methods available in the .NET Task Parallel Library (such as Task , Task<TResult> and TaskCompletionSource<TResult> ), as well as the async , await and lock C# keywords, and we are adding more types and APIs over time. You can read more about binary rewriting in Coyote here and supported scenarios here . Take the simple example that was used to explain concurrency non-determinism . Notice that the code below is using the C# Task type. Coyote understands this Task type and is able to control its schedule during systematic testing, as discussed above. using System.Threading.Tasks; // Shared variable x. int x = 0; // Concurrency unit test. int foo() { // Concurrent operations on x. var t1 = Task.Run(() => { x = 1; }); var t2 = Task.Run(() => { x = 2; }); // Join all. Task.WaitAll(t1, t2); } When this method foo executes as part of a test case, the Coyote tester will understand that it is spawning two tasks that can run concurrently. The tester will explore different ways of executing the tasks to systematically cover all possibilities. Expressing nondeterminism and mocking Coyote also offers APIs for expressing other forms of non-determinism that are not supported out of the box using binary rewriting. The CoyoteRuntime.Random API, for instance, returns a non-deterministic bool value. The exact value is chosen by the tester. This simple API can be used to build more complex mocks of external dependencies in the system. As an example, suppose that our code calls into an external service. Either this call returns successfully and the external service does the work that we requested, or it may timeout, or return an error code if the external service is unable to perform the work at the time. For testing your code, you will write a mock for it as follows: Status CallExternalServiceMock(WorkItem work) { if (CoyoteRuntime.Random()) { // Perform some work. ... // Return success. return Status.Success; } else if (CoyoteRuntime.Random()) { // Return error code. return Status.ErrorCode1; } else if (CoyoteRuntime.Random()) { // Return error code. return Status.ErrorCode2; } else { // Timeout. return Status.Timeout; } } When using such a mock, the Coyote tester will control the values that Random returns in a way that provides good coverage. All these techniques can be put together to write very expressive test cases. A Coyote concurrency unit test has the power of encoding many different scenarios concisely and leave their exploration to the automated tester. Using Coyote involves two main activities. First, you write a concurrency unit test. Second, you design mocks for external dependencies, capturing the sources of non-determinism that you want tested in your system. Additionally, Coyote also offers ways of writing safety and liveness specifications concisely. Testing other programming models Besides the popular task-based programming model of C#, you can also choose to use the Microsoft.Coyote.Actor library that provides APIs for expressing in-memory asynchronous actors and state machines . Programs written using this more advanced programming model can also be systematically tested with Coyote similar to unmodified task-based programs. See this demo which shows the systematic testing process in action on a test application that implements the Raft consensus protocol using Coyote state machines.","title":"Concurrency unit testing"},{"location":"concepts/concurrency-unit-testing/#concurrency-unit-testing","text":"Coyote gives you the ability to write concurrency unit tests . These simple but very powerful tests look similar to traditional (sequential) tests, but allow (and encourage) the use of concurrency and non-determinism , which you would normally avoid due to flakiness. By writing such a test, Coyote allows you to exercise what happens, for example, when two requests execute concurrently in your service, as if it was deployed in production. Now the cool thing is that once a bug is found, Coyote allows you to fully reproduce the exact same trace that led to the bug 100% of the time, and as many times as you want. Coyote achieves this by automatically replaying all nondeterministic choices in your test that led to this bug. This is a game changer! Let\u2019s see how this kind of testing works in practice.","title":"Concurrency unit testing"},{"location":"concepts/concurrency-unit-testing/#systematic-testing-of-unmodified-programs","text":"During testing, Coyote takes over the non-determinism in your program. Once Coyote has control over the non-determinism, it will repeatedly run the concurrency unit test from start to completion, each time exercising a different set of non-deterministic choices, offering much better coverage than using traditional techniques such as stress testing (which rely on luck). This type of testing that Coyote performs is known as systematic testing . This powerful testing ability, however, has one requirement: you must declare all sources of non-determinism in your logic in a way that Coyote understands so that it is able to reproduce any nondeterministic bug that it finds and help you easily debug the issue. Luckily, in most common cases you do not need to do much thanks to the awesome binary rewriting that Coyote does to enable testing of unmodified programs. Out of the box, Coyote supports most common types and methods available in the .NET Task Parallel Library (such as Task , Task<TResult> and TaskCompletionSource<TResult> ), as well as the async , await and lock C# keywords, and we are adding more types and APIs over time. You can read more about binary rewriting in Coyote here and supported scenarios here . Take the simple example that was used to explain concurrency non-determinism . Notice that the code below is using the C# Task type. Coyote understands this Task type and is able to control its schedule during systematic testing, as discussed above. using System.Threading.Tasks; // Shared variable x. int x = 0; // Concurrency unit test. int foo() { // Concurrent operations on x. var t1 = Task.Run(() => { x = 1; }); var t2 = Task.Run(() => { x = 2; }); // Join all. Task.WaitAll(t1, t2); } When this method foo executes as part of a test case, the Coyote tester will understand that it is spawning two tasks that can run concurrently. The tester will explore different ways of executing the tasks to systematically cover all possibilities.","title":"Systematic testing of unmodified programs"},{"location":"concepts/concurrency-unit-testing/#expressing-nondeterminism-and-mocking","text":"Coyote also offers APIs for expressing other forms of non-determinism that are not supported out of the box using binary rewriting. The CoyoteRuntime.Random API, for instance, returns a non-deterministic bool value. The exact value is chosen by the tester. This simple API can be used to build more complex mocks of external dependencies in the system. As an example, suppose that our code calls into an external service. Either this call returns successfully and the external service does the work that we requested, or it may timeout, or return an error code if the external service is unable to perform the work at the time. For testing your code, you will write a mock for it as follows: Status CallExternalServiceMock(WorkItem work) { if (CoyoteRuntime.Random()) { // Perform some work. ... // Return success. return Status.Success; } else if (CoyoteRuntime.Random()) { // Return error code. return Status.ErrorCode1; } else if (CoyoteRuntime.Random()) { // Return error code. return Status.ErrorCode2; } else { // Timeout. return Status.Timeout; } } When using such a mock, the Coyote tester will control the values that Random returns in a way that provides good coverage. All these techniques can be put together to write very expressive test cases. A Coyote concurrency unit test has the power of encoding many different scenarios concisely and leave their exploration to the automated tester. Using Coyote involves two main activities. First, you write a concurrency unit test. Second, you design mocks for external dependencies, capturing the sources of non-determinism that you want tested in your system. Additionally, Coyote also offers ways of writing safety and liveness specifications concisely.","title":"Expressing nondeterminism and mocking"},{"location":"concepts/concurrency-unit-testing/#testing-other-programming-models","text":"Besides the popular task-based programming model of C#, you can also choose to use the Microsoft.Coyote.Actor library that provides APIs for expressing in-memory asynchronous actors and state machines . Programs written using this more advanced programming model can also be systematically tested with Coyote similar to unmodified task-based programs. See this demo which shows the systematic testing process in action on a test application that implements the Raft consensus protocol using Coyote state machines.","title":"Testing other programming models"},{"location":"concepts/non-determinism/","text":"Program non-determinism Programs that are deterministic are also easy to test. Intuitively, a program is deterministic whenever it executes in the same manner if provided the same inputs. Most software, however, isn\u2019t deterministic. Let\u2019s begin by understanding this non-determinism and how it makes your life as developers more difficult. The most common form of non-determinism stems from concurrency. Consider the following procedure: // Shared variable x. int x = 0; int foo() { // Concurrent operations on x. var t1 = Task.Run(() => { x = 1; }); var t2 = Task.Run(() => { x = 2; }); // Join all. Task.WaitAll(t1, t2); } Executing foo can result in x == 1 or x == 2 . The exact value of x depends on the order in which the tasks are executed. This is non-determinism because the scheduling of tasks is not in your control. Adding synchronization helps reduce the amount of non-determinism but doesn\u2019t completely take it away. The above example showed a classical data race . Actually, it is a low level data race between individual memory accesses. Even high level races such as the order in which messages arrive and get processed also contributes to non-determinism. Non-determinism arises from many other sources as well. Timeouts are a good example. The use of timers prevail in many distributed systems. Consider a program that wishes to offload some computation to a remote computer. It will typically send a message over the network, and then start a timer with some pre-determined timeout value. If the response arrives successfully from the remote machine, the timer is canceled and all is good. If the timer fires before the response arrives, then the sender may wish to invoke a recovery action. Which of these two cases actually happen in practice is, again, not in the programmer\u2019s control. Timers, thus, are another source of non-determinism in the program. Other similar examples include failures. When designing software services that execute in the cloud, you must anticipate the possibility of hardware or software failures that cause the hosting VM to reboot. In such cases the fallback is to restart the VM (or spawn a new one) to take over the failed process. This is also non-determinism because the failure (and restart) can happen at any time. Calling into an external service that may return one of many error codes is also non-determinism; the exact return value is again not in your control when you call the external service. The trouble with non-determinism is that you must defend against all the ways in which the non-determinism unfolds at runtime. For example, no matter what scheduling happens between concurrent operations or when failures happen, your program must still work. This imposes a cognitive burden on your design and makes it harder to write correct code. Once the design and code are in place, even testing is hard because how do you get coverage of these non-deterministic activities? Stress testing techniques hope that with enough load on the system, the corner cases will get covered. Coyote offers a more principled approach, namely concurrency unit testing that has proven to be very effective in practice, and widely adopted in Azure .","title":"Program non-determinism"},{"location":"concepts/non-determinism/#program-non-determinism","text":"Programs that are deterministic are also easy to test. Intuitively, a program is deterministic whenever it executes in the same manner if provided the same inputs. Most software, however, isn\u2019t deterministic. Let\u2019s begin by understanding this non-determinism and how it makes your life as developers more difficult. The most common form of non-determinism stems from concurrency. Consider the following procedure: // Shared variable x. int x = 0; int foo() { // Concurrent operations on x. var t1 = Task.Run(() => { x = 1; }); var t2 = Task.Run(() => { x = 2; }); // Join all. Task.WaitAll(t1, t2); } Executing foo can result in x == 1 or x == 2 . The exact value of x depends on the order in which the tasks are executed. This is non-determinism because the scheduling of tasks is not in your control. Adding synchronization helps reduce the amount of non-determinism but doesn\u2019t completely take it away. The above example showed a classical data race . Actually, it is a low level data race between individual memory accesses. Even high level races such as the order in which messages arrive and get processed also contributes to non-determinism. Non-determinism arises from many other sources as well. Timeouts are a good example. The use of timers prevail in many distributed systems. Consider a program that wishes to offload some computation to a remote computer. It will typically send a message over the network, and then start a timer with some pre-determined timeout value. If the response arrives successfully from the remote machine, the timer is canceled and all is good. If the timer fires before the response arrives, then the sender may wish to invoke a recovery action. Which of these two cases actually happen in practice is, again, not in the programmer\u2019s control. Timers, thus, are another source of non-determinism in the program. Other similar examples include failures. When designing software services that execute in the cloud, you must anticipate the possibility of hardware or software failures that cause the hosting VM to reboot. In such cases the fallback is to restart the VM (or spawn a new one) to take over the failed process. This is also non-determinism because the failure (and restart) can happen at any time. Calling into an external service that may return one of many error codes is also non-determinism; the exact return value is again not in your control when you call the external service. The trouble with non-determinism is that you must defend against all the ways in which the non-determinism unfolds at runtime. For example, no matter what scheduling happens between concurrent operations or when failures happen, your program must still work. This imposes a cognitive burden on your design and makes it harder to write correct code. Once the design and code are in place, even testing is hard because how do you get coverage of these non-deterministic activities? Stress testing techniques hope that with enough load on the system, the corner cases will get covered. Coyote offers a more principled approach, namely concurrency unit testing that has proven to be very effective in practice, and widely adopted in Azure .","title":"Program non-determinism"},{"location":"concepts/specifications/","text":"Writing program specifications Coyote makes it easy to design and express system-level specifications that can be asserted during testing. Specifications come in two forms. Safety specifications assert that the system never enters a bad state. Liveness specifications assert that the system eventually does something good , that is, it asserts that the system is always able to make progress. These can be written using a Monitor . Specifying safety properties Safety property specifications generalize the notion of source code assertions. A safety property violation is a finite execution that leads a system to an erroneous state. Coyote provides an API for writing assertions that specify safety properties that are local to a Coyote actor or task. In the Task programming model, you should use Specification.Assert (see Specification API ) and in the Actor programming model the corresponding API is Actor.Assert . In addition, Coyote also provides a way to specify global assertions that can describe the relationship across tasks or actors. Coyote provides the notion of a Monitor (see Monitor API ). It is a special kind of actor that can receive events but cannot send events to other actors. So it can only observe the execution of a program but not influence it: a desirable property when writing specifications in code. A Monitor is declared as follows: class GlobalSpec : Monitor { ... } The above code snippet declares a monitor named GlobalSpec . Unlike actors, monitors are not explicitly instantiated. Instead, they need to be registered with the Coyote runtime: ICoyoteRuntime runtime; runtime.RegisterMonitor<GlobalSpec>(); There can only be one instance of a given monitor type. Communication with this monitor happens via events: ICoyoteRuntime runtime; runtime.InvokeMonitor<GlobalSpec>(new CustomEvent(...)); Just like actors, monitors can have any number of fields, methods and states. The following is a simple example of a monitor. Let\u2019s say that there are two actors A and B that maintain two important variables called x and y , respectively. We want to assert that these two values are always within a difference of 5 between each other. There is no one assert that we can write that is local to A or B because both x and y live in different places. So we define a global Monitor that accepts events as soon as a variable is updated. Then it keeps asserting their values are within the required bound. public class UpdatedXEvent : Event { public int value { get; private set; } public UpdatedXEvent(int value) { this.value = value; } } public class UpdatedYEvent : Event { public int value { get; private set; } public UpdatedYEvent(int value) { this.value = value; } } class GlobalSpec : Monitor { // Current reading of x. int my_x; // Current reading of y. int my_y; [Start] [OnEntry(nameof(InitOnEntry))] [OnEventDoAction(typeof(UpdatedXEvent), nameof(UpdatedXAction))] [OnEventDoAction(typeof(UpdatedYEvent), nameof(UpdatedYAction))] class Init : State { } // Initialization. void InitOnEntry() { my_x = my_y = 0; } void UpdatedXAction(Event e) { my_x = (e as UpdatedXEvent).value; this.AssertSafety(); } void UpdatedYAction(Event e) { my_y = (e as UpdatedYEvent).value; this.AssertSafety(); } void AssertSafety() { this.Assert(Math.Abs(my_x - my_y) <= 5); } } In general, a monitor maintains local state of its own that is modified in response to events received from the program. This local state is used to maintain a history of the computation that is relevant to the property being monitored. An erroneous global behavior is flagged via an assertion on the private state of the safety monitor. Thus, a monitor cleanly separates the instrumentation state required for specification (inside the monitor) from the program state (outside the monitor). You can use monitors with the tasks programming model as well. Simply use Specification.RegisterMonitor and Specification.InvokeMonitor instead of the corresponding APIs in ICoyoteRuntime . A Task program can still use an ICoyoteRuntime if it wants to, the static methods are just provided as a convenience way to find the current ICoyoteRuntime . Specifying liveness properties Liveness property specifications generalize the notion of non-termination . A liveness property violation is an infinite trace that exhibits lack of progress. Let\u2019s explain this concept through an example. Suppose that you are designing a replication protocol. The job of the protocol is to ensure that your data is replicated on, say, three different storage nodes. When a storage node fails, the protocol kicks in, reads the lost data from one of the alive replicas, and then creates a new replica on a different storage node. A natural specification for this protocol is that eventually it must establish three replicas for the data. In other words, it is unavoidable (on storage-node failure) that there are less-than-required number of replicas, but in that case the protocol must work towards creating the desired number of replicas again. A violation of this property is an (infinite) execution where a storage node fails but the protocol is not able to create the third replica, even when given an infinite amount of time. We keep talking about infinite behaviors here, but let\u2019s come back to that later. First, let us see how we can write this property as a monitor. A liveness monitor contains two special states: the hot and the cold state. The hot state denotes a point in the execution where progress is required, but has not happened yet; e.g. a node has failed, but a new one has not been created yet. A liveness monitor transitions to the hot state when it is notified that the system must make progress. A liveness monitor leaves the hot state and enters the cold state when it is notified that the system has progressed enough. An infinite execution is erroneous if the liveness monitor stays in the hot state for an infinitely long period of time. Consider the following example. class UpEvent : Event { } class DownEvent : Event { } class LivenessMonitor : Monitor { // current number of replicas alive. int alive = 0; [Start] [Hot] [OnEventDoAction(typeof(UpEvent),nameof(OnUp))] [OnEventDoAction(typeof(DownEvent),nameof(OnDown))] class NotEnoughReplicas : State { } [Cold] [OnEventDoAction(typeof(UpEvent),nameof(OnUp))] [OnEventDoAction(typeof(DownEvent),nameof(OnDown))] class EnoughReplicas : State { } // Notification that a new replica is up. void OnUp() { alive++; if (alive >= 3) { this.RaiseGotoStateEvent<EnoughReplicas>(); } else { this.RaiseGotoStateEvent<NotEnoughReplicas>(); } } // Notification that a replica has gone down. void OnDown() { alive--; if (alive >= 3) { this.RaiseGotoStateEvent<EnoughReplicas>(); } else { this.RaiseGotoStateEvent<NotEnoughReplicas>(); } } } This monitor has two states. It starts in a hot state NotEnoughReplicas and keeps track of the number of replicas alive in the system. It stays in the NotEnoughReplicas state as long as this number is below three, otherwise it transitions to the cold state EnoughReplicas . A program execution where this monitor gets stuck in the hot state demonstrates a violation of the correctness property of the replication protocol. Liveness monitors offer a natural way of describing properties of progress: things that must eventually happen in the system, where you cannot necessarily say (or its too cumbersome to say) exactly when the progress will happen. In practice, of course, you cannot wait for infinite executions: there is only a finite amount of time available to testing. The tester resorts to heuristics: it considers a sufficiently long and hot execution as a proxy for a liveness violation. You can configure a bound beyond which executions are considered infinite using the --liveness-temperature-threshold argument on the coyote tool . Read this how-to guide to learn how to effectively test for liveness bugs using Coyote.","title":"Program specifications"},{"location":"concepts/specifications/#writing-program-specifications","text":"Coyote makes it easy to design and express system-level specifications that can be asserted during testing. Specifications come in two forms. Safety specifications assert that the system never enters a bad state. Liveness specifications assert that the system eventually does something good , that is, it asserts that the system is always able to make progress. These can be written using a Monitor .","title":"Writing program specifications"},{"location":"concepts/specifications/#specifying-safety-properties","text":"Safety property specifications generalize the notion of source code assertions. A safety property violation is a finite execution that leads a system to an erroneous state. Coyote provides an API for writing assertions that specify safety properties that are local to a Coyote actor or task. In the Task programming model, you should use Specification.Assert (see Specification API ) and in the Actor programming model the corresponding API is Actor.Assert . In addition, Coyote also provides a way to specify global assertions that can describe the relationship across tasks or actors. Coyote provides the notion of a Monitor (see Monitor API ). It is a special kind of actor that can receive events but cannot send events to other actors. So it can only observe the execution of a program but not influence it: a desirable property when writing specifications in code. A Monitor is declared as follows: class GlobalSpec : Monitor { ... } The above code snippet declares a monitor named GlobalSpec . Unlike actors, monitors are not explicitly instantiated. Instead, they need to be registered with the Coyote runtime: ICoyoteRuntime runtime; runtime.RegisterMonitor<GlobalSpec>(); There can only be one instance of a given monitor type. Communication with this monitor happens via events: ICoyoteRuntime runtime; runtime.InvokeMonitor<GlobalSpec>(new CustomEvent(...)); Just like actors, monitors can have any number of fields, methods and states. The following is a simple example of a monitor. Let\u2019s say that there are two actors A and B that maintain two important variables called x and y , respectively. We want to assert that these two values are always within a difference of 5 between each other. There is no one assert that we can write that is local to A or B because both x and y live in different places. So we define a global Monitor that accepts events as soon as a variable is updated. Then it keeps asserting their values are within the required bound. public class UpdatedXEvent : Event { public int value { get; private set; } public UpdatedXEvent(int value) { this.value = value; } } public class UpdatedYEvent : Event { public int value { get; private set; } public UpdatedYEvent(int value) { this.value = value; } } class GlobalSpec : Monitor { // Current reading of x. int my_x; // Current reading of y. int my_y; [Start] [OnEntry(nameof(InitOnEntry))] [OnEventDoAction(typeof(UpdatedXEvent), nameof(UpdatedXAction))] [OnEventDoAction(typeof(UpdatedYEvent), nameof(UpdatedYAction))] class Init : State { } // Initialization. void InitOnEntry() { my_x = my_y = 0; } void UpdatedXAction(Event e) { my_x = (e as UpdatedXEvent).value; this.AssertSafety(); } void UpdatedYAction(Event e) { my_y = (e as UpdatedYEvent).value; this.AssertSafety(); } void AssertSafety() { this.Assert(Math.Abs(my_x - my_y) <= 5); } } In general, a monitor maintains local state of its own that is modified in response to events received from the program. This local state is used to maintain a history of the computation that is relevant to the property being monitored. An erroneous global behavior is flagged via an assertion on the private state of the safety monitor. Thus, a monitor cleanly separates the instrumentation state required for specification (inside the monitor) from the program state (outside the monitor). You can use monitors with the tasks programming model as well. Simply use Specification.RegisterMonitor and Specification.InvokeMonitor instead of the corresponding APIs in ICoyoteRuntime . A Task program can still use an ICoyoteRuntime if it wants to, the static methods are just provided as a convenience way to find the current ICoyoteRuntime .","title":"Specifying safety properties"},{"location":"concepts/specifications/#specifying-liveness-properties","text":"Liveness property specifications generalize the notion of non-termination . A liveness property violation is an infinite trace that exhibits lack of progress. Let\u2019s explain this concept through an example. Suppose that you are designing a replication protocol. The job of the protocol is to ensure that your data is replicated on, say, three different storage nodes. When a storage node fails, the protocol kicks in, reads the lost data from one of the alive replicas, and then creates a new replica on a different storage node. A natural specification for this protocol is that eventually it must establish three replicas for the data. In other words, it is unavoidable (on storage-node failure) that there are less-than-required number of replicas, but in that case the protocol must work towards creating the desired number of replicas again. A violation of this property is an (infinite) execution where a storage node fails but the protocol is not able to create the third replica, even when given an infinite amount of time. We keep talking about infinite behaviors here, but let\u2019s come back to that later. First, let us see how we can write this property as a monitor. A liveness monitor contains two special states: the hot and the cold state. The hot state denotes a point in the execution where progress is required, but has not happened yet; e.g. a node has failed, but a new one has not been created yet. A liveness monitor transitions to the hot state when it is notified that the system must make progress. A liveness monitor leaves the hot state and enters the cold state when it is notified that the system has progressed enough. An infinite execution is erroneous if the liveness monitor stays in the hot state for an infinitely long period of time. Consider the following example. class UpEvent : Event { } class DownEvent : Event { } class LivenessMonitor : Monitor { // current number of replicas alive. int alive = 0; [Start] [Hot] [OnEventDoAction(typeof(UpEvent),nameof(OnUp))] [OnEventDoAction(typeof(DownEvent),nameof(OnDown))] class NotEnoughReplicas : State { } [Cold] [OnEventDoAction(typeof(UpEvent),nameof(OnUp))] [OnEventDoAction(typeof(DownEvent),nameof(OnDown))] class EnoughReplicas : State { } // Notification that a new replica is up. void OnUp() { alive++; if (alive >= 3) { this.RaiseGotoStateEvent<EnoughReplicas>(); } else { this.RaiseGotoStateEvent<NotEnoughReplicas>(); } } // Notification that a replica has gone down. void OnDown() { alive--; if (alive >= 3) { this.RaiseGotoStateEvent<EnoughReplicas>(); } else { this.RaiseGotoStateEvent<NotEnoughReplicas>(); } } } This monitor has two states. It starts in a hot state NotEnoughReplicas and keeps track of the number of replicas alive in the system. It stays in the NotEnoughReplicas state as long as this number is below three, otherwise it transitions to the cold state EnoughReplicas . A program execution where this monitor gets stuck in the hot state demonstrates a violation of the correctness property of the replication protocol. Liveness monitors offer a natural way of describing properties of progress: things that must eventually happen in the system, where you cannot necessarily say (or its too cumbersome to say) exactly when the progress will happen. In practice, of course, you cannot wait for infinite executions: there is only a finite amount of time available to testing. The tester resorts to heuristics: it considers a sufficiently long and hot execution as a proxy for a liveness violation. You can configure a bound beyond which executions are considered infinite using the --liveness-temperature-threshold argument on the coyote tool . Read this how-to guide to learn how to effectively test for liveness bugs using Coyote.","title":"Specifying liveness properties"},{"location":"concepts/actors/actor-semantics/","text":"Actor semantics An Actor in Coyote is an in-memory object. The main APIs that define the semantics of programming with actors are CreateActor , which is used to create a new Actor instance, and SendEvent that is used to pass an event to an existing Actor . It is useful to understand both the synchronous and asynchronous guarantees of these methods. Semantics of actor creation Suppose you create an Actor as follows: ActorId clientId = this.CreateActor(typeof(Client)); This call synchronously creates the inbox of the actor. The initialization of the new actor happens asynchronously in the background. Think of this as follows: the call takes only as long as it takes to create an inbox. It does not wait for the initialization code of the target actor to finish. This is enough to guarantee that you can start sending messages to the new actor immediately after creating it. Basically, if you have an ActorId , then you can send messages to it. The Coyote runtime will initialize the new actor in the background, and ensure that its initialization finishes before letting the actor process its inbox. Semantics of actor messages Actors in Coyote have both in-order as well as causal-delivery semantics. Lets break down this guarantee into pieces. If one actor sends two messages to another actor as follows: this.SendEvent(id, e1); this.SendEvent(id, e2); Then it is guaranteed that e1 will be delivered to the inbox of id before e2 . This is the in-order part of the message-delivery semantics. To explain causal delivery, we need to consider three actors A , B and C . Suppose that A first sends a message e1 to C and then it sends a message e2 to B . Next, B is programmed so that whenever it receives a message e2 , it will forward it to C . For this program, the message e1 is guaranteed to reach the inbox of C before e2 . There is a simple way of thinking about this guarantee. The call to SendEvent ensures that the message is delivered to the inbox of the target before it returns. (It does not wait for the message to be processed\u2014that can happen asynchronously.) Thus, when A sent message e1 to C , it was delivered to the inbox of C even before the message e2 was sent out. Thus, e2 had no chance of overtaking e1 to reach the inbox of C first. Distributed systems modeling Suppose that you have written a distributed system where each node of the system is running its own set of Coyote actors and these actors communicate over the network. When you write a Coyote test for checking end-to-end behaviors (by using a mock of the network to connect all the remote nodes together in the same test), then be sure to consider the difference in the delivery semantics of the network and the Coyote API SendEvent . Usually, real networks will provide more relaxed guarantees than SendEvent for performance reasons. Closing this gap requires modeling. For instance, a network that can either lose a message, deliver it once, or deliver it twice can be modeled as follows: if(this.Random()) { this.SendEvent(destination, message); } if(this.Random()) { this.SendEvent(destination, message); } See also State machine semantics .","title":"Actor semantics"},{"location":"concepts/actors/actor-semantics/#actor-semantics","text":"An Actor in Coyote is an in-memory object. The main APIs that define the semantics of programming with actors are CreateActor , which is used to create a new Actor instance, and SendEvent that is used to pass an event to an existing Actor . It is useful to understand both the synchronous and asynchronous guarantees of these methods.","title":"Actor semantics"},{"location":"concepts/actors/actor-semantics/#semantics-of-actor-creation","text":"Suppose you create an Actor as follows: ActorId clientId = this.CreateActor(typeof(Client)); This call synchronously creates the inbox of the actor. The initialization of the new actor happens asynchronously in the background. Think of this as follows: the call takes only as long as it takes to create an inbox. It does not wait for the initialization code of the target actor to finish. This is enough to guarantee that you can start sending messages to the new actor immediately after creating it. Basically, if you have an ActorId , then you can send messages to it. The Coyote runtime will initialize the new actor in the background, and ensure that its initialization finishes before letting the actor process its inbox.","title":"Semantics of actor creation"},{"location":"concepts/actors/actor-semantics/#semantics-of-actor-messages","text":"Actors in Coyote have both in-order as well as causal-delivery semantics. Lets break down this guarantee into pieces. If one actor sends two messages to another actor as follows: this.SendEvent(id, e1); this.SendEvent(id, e2); Then it is guaranteed that e1 will be delivered to the inbox of id before e2 . This is the in-order part of the message-delivery semantics. To explain causal delivery, we need to consider three actors A , B and C . Suppose that A first sends a message e1 to C and then it sends a message e2 to B . Next, B is programmed so that whenever it receives a message e2 , it will forward it to C . For this program, the message e1 is guaranteed to reach the inbox of C before e2 . There is a simple way of thinking about this guarantee. The call to SendEvent ensures that the message is delivered to the inbox of the target before it returns. (It does not wait for the message to be processed\u2014that can happen asynchronously.) Thus, when A sent message e1 to C , it was delivered to the inbox of C even before the message e2 was sent out. Thus, e2 had no chance of overtaking e1 to reach the inbox of C first.","title":"Semantics of actor messages"},{"location":"concepts/actors/actor-semantics/#distributed-systems-modeling","text":"Suppose that you have written a distributed system where each node of the system is running its own set of Coyote actors and these actors communicate over the network. When you write a Coyote test for checking end-to-end behaviors (by using a mock of the network to connect all the remote nodes together in the same test), then be sure to consider the difference in the delivery semantics of the network and the Coyote API SendEvent . Usually, real networks will provide more relaxed guarantees than SendEvent for performance reasons. Closing this gap requires modeling. For instance, a network that can either lose a message, deliver it once, or deliver it twice can be modeled as follows: if(this.Random()) { this.SendEvent(destination, message); } if(this.Random()) { this.SendEvent(destination, message); } See also State machine semantics .","title":"Distributed systems modeling"},{"location":"concepts/actors/event-groups/","text":"Event groups For some applications, it is useful to know which actor is processing an event derived from some user request. Coyote offers the notion of an EventGroup that can be tracked automatically. The following IActorRuntime APIs take an optional EventGroup parameter. ActorId CreateActor(Type type, Event e = null, EventGroup group = null); void SendEvent(ActorId target, Event e, EventGroup group = null); When you pass a non-null group the runtime takes care of propagating it to any subsequent actors that might be created and across any SendEvent calls to any other actors. So all the work performed as a result of these actors and events can be grouped into a logical group. The EventGroup argument on SendEvent is optional, the value null means pick up the CurrentEventGroup of the sender and pass it along to the target actor (if there is one). The Actor class has a field that returns the current EventGroup . The EventGroup is stored with the event and CurrentEventGroup is set when the event is dequeued. EventGroup CurrentEventGroup { get; set; } Additionally you may use the following IActorRuntime API to get the current group of any actor. EventGroup GetCurrentEventGroup(ActorId actorId); The CurrentEventGroup is automatically passed along whenever you use CreateActor or SendEvent as shown below: EventGroup The base EventGroup class contains the following: public Guid Id { get; internal set; } public string Name { get; internal set; } The Guid is automatically assigned to Guid.Empty . The Name defaults to null but you can provide any friendly name you want there. AwaitableEventGroup< > As a convenience the following typed EventGroup is also provided that can also be used to wait for some result to be returned from the actors that share this group: public class AwaitableEventGroup<T> : EventGroup { public bool IsCompleted { get; } public Task<T> Task { get; } public virtual void SetResult(T result); public TaskAwaiter<T> GetAwaiter(); } You can pass this group to your actors so that one of those actors can decide at some point to call SetResult . Then you can await on this object for the result. In this way you can asynchronously return a result from a collection of actors that are performing some job. SetResult also sets IsCompleted to true. Clearing the CurrentEventGroup You might need to clear the current event group at some point in your Actor . To do this you can simply set the property to null: this.CurrentEventGroup = null; However, this could be overridden by any subsequent event that is dequeued from the event queue. If you do not want the CurrentEventGroup to be passed along to the target actor you can pass a special EventGroup.Null event group like this: this.SendEvent(target, e, EventGroup.Null); This will put a null in the event queue of the target actor so that when this event is dequeued the CurrentEventGroup of the target actor will be set to null . In this way then you can propagate a null EventGroup to all your actors. Custom EventGroups The EventGroup class is unsealed so you can create any custom class that you need. The following is an example that counts a certain number of steps before completing the boolean AwaitableEventGroup : public class EventGroupCounter : AwaitableEventGroup<bool> { public int ExpectedCount; public EventGroupCounter(int expected) { this.ExpectedCount = expected; } public void Complete() { var count = Interlocked.Decrement(ref this.ExpectedCount); if (count == 0) { this.SetResult(true); } } } This way you can have multiple actors calling Complete and the outer code that is waiting is not released until the expected count is reached. Similarly you can create an EventGroup that gathers multiple results from various actors like this: public class EventGroupList : AwaitableEventGroup<List<string>> { public List<string> Items = new List<string>(); public void AddItem(string msg) { this.Items.Add(msg); } public void Complete() { this.SetResult(Items); } } Then when the final actor calls Complete() the list of gathered items is then made available to the waiting caller via SetResult .","title":"Event groups"},{"location":"concepts/actors/event-groups/#event-groups","text":"For some applications, it is useful to know which actor is processing an event derived from some user request. Coyote offers the notion of an EventGroup that can be tracked automatically. The following IActorRuntime APIs take an optional EventGroup parameter. ActorId CreateActor(Type type, Event e = null, EventGroup group = null); void SendEvent(ActorId target, Event e, EventGroup group = null); When you pass a non-null group the runtime takes care of propagating it to any subsequent actors that might be created and across any SendEvent calls to any other actors. So all the work performed as a result of these actors and events can be grouped into a logical group. The EventGroup argument on SendEvent is optional, the value null means pick up the CurrentEventGroup of the sender and pass it along to the target actor (if there is one). The Actor class has a field that returns the current EventGroup . The EventGroup is stored with the event and CurrentEventGroup is set when the event is dequeued. EventGroup CurrentEventGroup { get; set; } Additionally you may use the following IActorRuntime API to get the current group of any actor. EventGroup GetCurrentEventGroup(ActorId actorId); The CurrentEventGroup is automatically passed along whenever you use CreateActor or SendEvent as shown below:","title":"Event groups"},{"location":"concepts/actors/event-groups/#eventgroup","text":"The base EventGroup class contains the following: public Guid Id { get; internal set; } public string Name { get; internal set; } The Guid is automatically assigned to Guid.Empty . The Name defaults to null but you can provide any friendly name you want there.","title":"EventGroup"},{"location":"concepts/actors/event-groups/#awaitableeventgroup","text":"As a convenience the following typed EventGroup is also provided that can also be used to wait for some result to be returned from the actors that share this group: public class AwaitableEventGroup<T> : EventGroup { public bool IsCompleted { get; } public Task<T> Task { get; } public virtual void SetResult(T result); public TaskAwaiter<T> GetAwaiter(); } You can pass this group to your actors so that one of those actors can decide at some point to call SetResult . Then you can await on this object for the result. In this way you can asynchronously return a result from a collection of actors that are performing some job. SetResult also sets IsCompleted to true.","title":"AwaitableEventGroup&lt;&gt;"},{"location":"concepts/actors/event-groups/#clearing-the-currenteventgroup","text":"You might need to clear the current event group at some point in your Actor . To do this you can simply set the property to null: this.CurrentEventGroup = null; However, this could be overridden by any subsequent event that is dequeued from the event queue. If you do not want the CurrentEventGroup to be passed along to the target actor you can pass a special EventGroup.Null event group like this: this.SendEvent(target, e, EventGroup.Null); This will put a null in the event queue of the target actor so that when this event is dequeued the CurrentEventGroup of the target actor will be set to null . In this way then you can propagate a null EventGroup to all your actors.","title":"Clearing the CurrentEventGroup"},{"location":"concepts/actors/event-groups/#custom-eventgroups","text":"The EventGroup class is unsealed so you can create any custom class that you need. The following is an example that counts a certain number of steps before completing the boolean AwaitableEventGroup : public class EventGroupCounter : AwaitableEventGroup<bool> { public int ExpectedCount; public EventGroupCounter(int expected) { this.ExpectedCount = expected; } public void Complete() { var count = Interlocked.Decrement(ref this.ExpectedCount); if (count == 0) { this.SetResult(true); } } } This way you can have multiple actors calling Complete and the outer code that is waiting is not released until the expected count is reached. Similarly you can create an EventGroup that gathers multiple results from various actors like this: public class EventGroupList : AwaitableEventGroup<List<string>> { public List<string> Items = new List<string>(); public void AddItem(string msg) { this.Items.Add(msg); } public void Complete() { this.SetResult(Items); } } Then when the final actor calls Complete() the list of gathered items is then made available to the waiting caller via SetResult .","title":"Custom EventGroups"},{"location":"concepts/actors/logging/","text":"Logging The Coyote runtime provides a Microsoft.Coyote.IO.ILogger interface for logging so that your program output can be captured and included in coyote test tool output logs. A default Logger is provided and can be accessed like this: Programming Model Accessing the Logger Task based program Microsoft.Coyote.Actors.RuntimeFactory.Create().Logger Actor based program Microsoft.Coyote.Runtime.RuntimeFactory.Create().Logger Actor.Logger , StateMachine.Logger , Monitor.Logger The default Logger is a ConsoleLogger which is used to write output to the System.Console . You can provide your own implementation of Microsoft.Coyote.IO.ILogger by setting the Logger property on the ICoyoteRuntime or IActorRuntime . The IActorRuntime also provides a higher level logging interface called IActorRuntimeLog for logging Actor and StateMachine activity. Example of custom ILogger It is possible to replace the default logger with a custom one. The following example captures all log output in a StringBuilder : public class CustomLogger : ILogger { private StringBuilder StringBuilder; public TextWriter TextWriter => throw new NotImplementedException(); public CustomLogger() { this.StringBuilder = new StringBuilder(); } public void Write(string value) { this.Write(LogSeverity.Informational, value); } public void WriteLine(string value) { this.WriteLine(LogSeverity.Informational, value); } public void Write(string format, params object[] args) { this.Write(LogSeverity.Informational, format, args); } public void WriteLine(string format, params object[] args) { this.WriteLine(LogSeverity.Informational, format, args); } public void Write(LogSeverity severity, string format, object[] args) { this.Write(severity, string.Format(format, args)); } public void WriteLine(LogSeverity severity, string format, object[] args) { this.WriteLine(severity, string.Format(format, args)); } public void Write(LogSeverity severity, string value) { switch (severity) { case LogSeverity.Informational: this.StringBuilder.Append(\"<info>\" + value); break; case LogSeverity.Warning: this.StringBuilder.Append(\"<warning>\" + value); break; case LogSeverity.Error: this.StringBuilder.Append(\"<error>\" + value); break; case LogSeverity.Important: this.StringBuilder.Append(\"<important>\" + value); break; } } public void WriteLine(LogSeverity severity, string value) { this.Write(severity, value); this.StringBuilder.AppendLine(); } public override string ToString() { return this.StringBuilder.ToString(); } public void Dispose() { // todo } } To replace the default logger, call the following IActorRuntime method: runtime.Logger = new CustomLogger(); The above method replaces the previously installed logger with the specified one and returns the previously installed logger. Note that the old Logger might be disposable, so if you care about disposing the old logger at the same time you may need to write this instead: using (var oldLogger = runtime.Logger) { runtime.Logger = new CustomLogger(); } You could write a custom ILogger to intercept all logging messages and send them to an Azure Log table, or over a TCP socket. IActorRuntimeLog The default IActorRuntimeLog implementation is the ActorRuntimeLogTextFormatter base class which is responsible for formatting all Actor and StateMachine activity as text and writing that out using the installed Logger . You can add your own implementation of IActorRuntimeLog or ActorRuntimeLogTextFormatter using the RegisterLog method on IActorRuntime . This is additive so you can have the default ActorRuntimeLogTextFormatter and another logger running at the same time. For example, see the ActorRuntimeLogGraphBuilder class which implements IActorRuntimeLog and generates a directed graph representing all activities that happened during the execution of your actors. See activity coverage for an example graph output. The coyote test tool sets this up for you when you specify --graph or --coverage activity command line options. The --verbosity command line option can also affect the default logging behavior. When --verbosity is specified all log output is written to the System.Console by default, but you can specify different levels of output using --verbosity quiet to get no output, --verbosity minimal to see only error messages and --verbosity normal to get errors and warnings. This can produce a lot of output especially if you run many testing iterations. It is usually more useful to only capture the output of the one failing iteration in a log file and this is done automatically by the testing runtime when --verbosity is not specified. See IActorRuntimeLog API documentation . Example of a custom IActorRuntimeLog You can also implement your own IActorRuntimeLog . The following is an example of how to do this: internal class CustomLogWriter : IActorRuntimeLog { // Callbacks on runtime events public void OnCreateActor(ActorId id, ActorId creator) { // Override to change the behavior. } public void OnEnqueueEvent(ActorId id, Event e) { // Override to change the behavior. } // More methods to implement. } You can then register your new implementation using the following IActorRuntime method: runtime.RegisterLog(new CustomLogWriter()); You can register multiple IActorRuntimeLog objects in case you have loggers that are doing very different things. The runtime will invoke each callback for every registered IActorRuntimeLog . Customizing the ActorRuntimeLogTextFormatter You can modify the format of text log messages by providing your own ActorRuntimeLogTextFormatter . You can subclass the default ActorRuntimeLogTextFormatter implementation to override its default behavior. The following is an example of how to do this: internal class CustomLogFormatter : ActorRuntimeLogTextFormatter { // Methods for formatting log messages public override void OnCreateActor(ActorId id, ActorId creator) { // Override to change the text to be logged. this.Logger.WriteLine(\"Hello!\"); } public override void OnEnqueueEvent(ActorId id, Event e) { // Override to conditionally hide certain events from the log. if (!(e is SecretEvent)) { base.OnEnqueueEvent(id, e); } } // More methods that can be overridden. } You can then replace the default ActorRuntimeLogTextFormatter with your new implementation using the following IActorRuntime method: runtime.RegisterLog(new CustomLogFormatter()); The above method replaces the previously installed ActorRuntimeLogTextFormatter with the specified one. See ActorRuntimeLogTextFormatter documentation.","title":"Logging"},{"location":"concepts/actors/logging/#logging","text":"The Coyote runtime provides a Microsoft.Coyote.IO.ILogger interface for logging so that your program output can be captured and included in coyote test tool output logs. A default Logger is provided and can be accessed like this: Programming Model Accessing the Logger Task based program Microsoft.Coyote.Actors.RuntimeFactory.Create().Logger Actor based program Microsoft.Coyote.Runtime.RuntimeFactory.Create().Logger Actor.Logger , StateMachine.Logger , Monitor.Logger The default Logger is a ConsoleLogger which is used to write output to the System.Console . You can provide your own implementation of Microsoft.Coyote.IO.ILogger by setting the Logger property on the ICoyoteRuntime or IActorRuntime . The IActorRuntime also provides a higher level logging interface called IActorRuntimeLog for logging Actor and StateMachine activity.","title":"Logging"},{"location":"concepts/actors/logging/#example-of-custom-ilogger","text":"It is possible to replace the default logger with a custom one. The following example captures all log output in a StringBuilder : public class CustomLogger : ILogger { private StringBuilder StringBuilder; public TextWriter TextWriter => throw new NotImplementedException(); public CustomLogger() { this.StringBuilder = new StringBuilder(); } public void Write(string value) { this.Write(LogSeverity.Informational, value); } public void WriteLine(string value) { this.WriteLine(LogSeverity.Informational, value); } public void Write(string format, params object[] args) { this.Write(LogSeverity.Informational, format, args); } public void WriteLine(string format, params object[] args) { this.WriteLine(LogSeverity.Informational, format, args); } public void Write(LogSeverity severity, string format, object[] args) { this.Write(severity, string.Format(format, args)); } public void WriteLine(LogSeverity severity, string format, object[] args) { this.WriteLine(severity, string.Format(format, args)); } public void Write(LogSeverity severity, string value) { switch (severity) { case LogSeverity.Informational: this.StringBuilder.Append(\"<info>\" + value); break; case LogSeverity.Warning: this.StringBuilder.Append(\"<warning>\" + value); break; case LogSeverity.Error: this.StringBuilder.Append(\"<error>\" + value); break; case LogSeverity.Important: this.StringBuilder.Append(\"<important>\" + value); break; } } public void WriteLine(LogSeverity severity, string value) { this.Write(severity, value); this.StringBuilder.AppendLine(); } public override string ToString() { return this.StringBuilder.ToString(); } public void Dispose() { // todo } } To replace the default logger, call the following IActorRuntime method: runtime.Logger = new CustomLogger(); The above method replaces the previously installed logger with the specified one and returns the previously installed logger. Note that the old Logger might be disposable, so if you care about disposing the old logger at the same time you may need to write this instead: using (var oldLogger = runtime.Logger) { runtime.Logger = new CustomLogger(); } You could write a custom ILogger to intercept all logging messages and send them to an Azure Log table, or over a TCP socket.","title":"Example of custom ILogger"},{"location":"concepts/actors/logging/#iactorruntimelog","text":"The default IActorRuntimeLog implementation is the ActorRuntimeLogTextFormatter base class which is responsible for formatting all Actor and StateMachine activity as text and writing that out using the installed Logger . You can add your own implementation of IActorRuntimeLog or ActorRuntimeLogTextFormatter using the RegisterLog method on IActorRuntime . This is additive so you can have the default ActorRuntimeLogTextFormatter and another logger running at the same time. For example, see the ActorRuntimeLogGraphBuilder class which implements IActorRuntimeLog and generates a directed graph representing all activities that happened during the execution of your actors. See activity coverage for an example graph output. The coyote test tool sets this up for you when you specify --graph or --coverage activity command line options. The --verbosity command line option can also affect the default logging behavior. When --verbosity is specified all log output is written to the System.Console by default, but you can specify different levels of output using --verbosity quiet to get no output, --verbosity minimal to see only error messages and --verbosity normal to get errors and warnings. This can produce a lot of output especially if you run many testing iterations. It is usually more useful to only capture the output of the one failing iteration in a log file and this is done automatically by the testing runtime when --verbosity is not specified. See IActorRuntimeLog API documentation .","title":"IActorRuntimeLog"},{"location":"concepts/actors/logging/#example-of-a-custom-iactorruntimelog","text":"You can also implement your own IActorRuntimeLog . The following is an example of how to do this: internal class CustomLogWriter : IActorRuntimeLog { // Callbacks on runtime events public void OnCreateActor(ActorId id, ActorId creator) { // Override to change the behavior. } public void OnEnqueueEvent(ActorId id, Event e) { // Override to change the behavior. } // More methods to implement. } You can then register your new implementation using the following IActorRuntime method: runtime.RegisterLog(new CustomLogWriter()); You can register multiple IActorRuntimeLog objects in case you have loggers that are doing very different things. The runtime will invoke each callback for every registered IActorRuntimeLog .","title":"Example of a custom IActorRuntimeLog"},{"location":"concepts/actors/logging/#customizing-the-actorruntimelogtextformatter","text":"You can modify the format of text log messages by providing your own ActorRuntimeLogTextFormatter . You can subclass the default ActorRuntimeLogTextFormatter implementation to override its default behavior. The following is an example of how to do this: internal class CustomLogFormatter : ActorRuntimeLogTextFormatter { // Methods for formatting log messages public override void OnCreateActor(ActorId id, ActorId creator) { // Override to change the text to be logged. this.Logger.WriteLine(\"Hello!\"); } public override void OnEnqueueEvent(ActorId id, Event e) { // Override to conditionally hide certain events from the log. if (!(e is SecretEvent)) { base.OnEnqueueEvent(id, e); } } // More methods that can be overridden. } You can then replace the default ActorRuntimeLogTextFormatter with your new implementation using the following IActorRuntime method: runtime.RegisterLog(new CustomLogFormatter()); The above method replaces the previously installed ActorRuntimeLogTextFormatter with the specified one. See ActorRuntimeLogTextFormatter documentation.","title":"Customizing the ActorRuntimeLogTextFormatter"},{"location":"concepts/actors/overview/","text":"Programming model: asynchronous actors The asynchronous actors programming model of Coyote is an actor-based programming model that encourages a message passing (or event based) programming model where all asynchronous actions happen by sending asynchronous events from one actor to another. This model is similar to how real people interact asynchronously via email. Each Coyote actor has an inbox for events, event handlers, as well as normal class fields and methods. Actors run concurrently with respect to each other, but individually they handle their input queue in a sequential way. When an event arrives, the actor dequeues that event from the input queue and handles it by executing a sequence of operations. Each operation might update a field, create a new actor, or send an event to another actor. In Coyote, creating actors and sending events are both non-blocking operations. In the case of a send operation the message (or event) is simply enqueued into the input queue of the target actor and, most importantly, it does not wait for the message to be processed at the target before returning control to the sender. The actor model also provides a specialized type of actor called a StateMachine . State machines are actors that have explicitly declared states and state transitions. Every object oriented class that has member variables is really also just a state machine where that state is updated as methods are called, but sometimes this gets really complicated and hard to test. Formal state machines help you model your states more explicitly and coyote tester can help you find bugs by exploring different state transitions using information you provide declaring how various types of events causes those state transitions. See also: how are Coyote Actors different from existing Microsoft Actor frameworks? . Declaring and creating actors An actor based program in Coyote is a normal .NET program that also uses the Actor or StateMachine base classes from the Microsoft.Coyote.Actors namespace, as well as the Event base class from the Microsoft.Coyote namespace. Actors can be declared in the following way: using Microsoft.Coyote.Actors; class Client : Actor { ... } class Server : Actor { ... } The above code declares two actors named Client and Server . Being a C# class you can also declare fields, properties and methods. An actor can create an instance of another actor and send Events using the following Actor methods: ActorId clientId = this.CreateActor(typeof(Client)); this.SendEvent(this.ClientId, new PingEvent()); When an event is being sent, it is enqueued in the event queue of the target actor. The coyote runtime will at some point dequeue the received event, and allow the target actor to handle it asynchronously. All actors in Coyote have an associated unique ActorId which identifies a specific instance of that type. Note that Coyote never gives you the actual object reference for an actor instance. This ensures your code does not get too tightly coupled. By limiting yourself to the Coyote API\u2019s for interacting with an actor, you also get all the benefits of coyote test in terms of understanding more deeply how to test all asynchronous interactions and ensure your specifications are maintained correctly. There is a lot of literature on actor models that explain in more depth the importance of this message passing programming model which is especially popular in the world of distributed systems. Event based programming is also popular in User Interface development and even shows up in low level embedded systems. It is a powerful tool for solving the tangled web of complexity that happens with less disciplined architectures. Starting a Coyote actor-based program To create the first instance of an Actor you need to initialize the Coyote actor runtime inside your C# process (typically in the Main method). An example of this is the following: using Microsoft.Coyote; using Microsoft.Coyote.Actors; using Microsoft.Coyote.SystematicTesting; using System; class Program { static void Main(string[] args) { IActorRuntime runtime = RuntimeFactory.Create(); Execute(runtime); Console.ReadLine(); } [Test] public static void Execute(IActorRuntime runtime) { ActorId serverId = runtime.CreateActor(typeof(Server)); } } You must first import the Coyote runtime library ( Microsoft.Coyote.dll ), which you can get from NuGet , then create a runtime instance (of type IActorRuntime ) which you pass to a [Test] method. The test method named Execute will be the entry point that is used during testing of your Coyote program. In this case it simply invokes the CreateActor method of the runtime to instantiate the first Coyote actor (of type Server in the above example). The CreateActor method accepts as a parameter the type of the actor to be instantiated, and returns the ActorId representing that actor instance and this bootstraps a series of asynchronous events that handle initialization of that actor and any operations it performs during initialization. Because CreateActor is an asynchronous method, we call the Console.ReadLine method, which pauses the main thread until some console input has been given, so that the host C# program does not exit prematurely. The IActorRuntime interface also provides the SendEvent method for sending events to a Coyote actor. This method accepts as parameters an object of type ActorId and an event object. It also has a couple more advanced parameters which you don\u2019t need to worry about right now. An event can be created by sub-classing from Microsoft.Coyote.Event : class PingEvent : Event { public readonly ActorId Caller; public PingEvent(ActorId caller) { this.Caller = caller; } } class PongEvent : Event { } An event can contain members of any type (including scalar values or references to object) and when an event is sent to a target actor there is no deep-copying of those members, for performance reasons. The target actor will be able to see the Event object and cast it to a specific type to extract the information it needs. Now you can write a complete actor, declaring what type of events it can handle: [OnEventDoAction(typeof(PingEvent), nameof(HandlePing))] class Server : Actor { public void HandlePing(Event e) { PingEvent ping = (PingEvent)e; Console.WriteLine(\"Server handling ping\"); Console.WriteLine(\"Server sending pong back to caller\"); this.SendEvent(ping.Caller, new PongEvent()); } } This Server is an Actor that can receive PingEvent . The PingEvent contains the ActorId of the caller and the Server uses that to send back a PongEvent in response. An event handler controls how a machine reacts to a received event. It is clearly just a method so you can do anything there, including creating one or more actor instances, sending one or more events, updating some private state or invoking some 3rd party library. To complete this Coyote program, you can provide the following implementation of the Client actor: using System.Threading.Tasks; class SetupEvent : Event { public readonly ActorId ServerId; public SetupEvent(ActorId server) { this.ServerId = server; } } [OnEventDoAction(typeof(PongEvent), nameof(HandlePong))] class Client : Actor { public ActorId ServerId; protected override Task OnInitializeAsync(Event initialEvent) { Console.WriteLine(\"{0} initializing\", this.Id); this.ServerId = ((SetupEvent)initialEvent).ServerId; Console.WriteLine(\"{0} sending ping event to server\", this.Id); this.SendEvent(this.ServerId, new PingEvent(this.Id)); return base.OnInitializeAsync(initialEvent); } void HandlePong() { Console.WriteLine(\"{0} received pong event\", this.Id); } } This Client is an Actor that sends PingEvents to a server. This means the Client needs to know the ActorId of the Server . This can be done using an initialEvent passed to OnInitializeAsync . The Client then uses this ActorId to send a PingEvent to the Server . When the Server responds with a PongEvent the HandlePong method is called because of the OnEventDoAction declaration on the class. Notice in this case the HandlePong event handler takes no Event argument. The Event argument is optional on Coyote event handlers. Note that HandlePong could also be defined as an async Task method. Async handlers are allowed so that you can call external async systems in your production code, but this has some restrictions. You are not allowed to directly create parallel tasks inside an actor (e.g. by using Task.Run ) as that can introduce race conditions (if you need to parallelize a workload, you can simply create more actors). Also, during testing, you should not use Task.Delay or Task.Yield in your event handlers. It is ok to have truly async behavior in production, but at test time the coyote test tool wants to know about, so that it can control, all async behavior of your actor. If it detects some uncontrolled async behavior an error will be reported. One last remaining bit of code is needed in your Program to complete this example, namely, you need to create the Client actor in the Execute method, in fact, you can create as many Client actors as you want to make this an interesting test: public static void Execute(IActorRuntime runtime) { ActorId serverId = runtime.CreateActor(typeof(Server)); runtime.CreateActor(typeof(Client), new SetupEvent(serverId)); runtime.CreateActor(typeof(Client), new SetupEvent(serverId)); runtime.CreateActor(typeof(Client), new SetupEvent(serverId)); } The output of the program will be something like this: Client(3) initializing Client(3) sending ping event to server Client(1) initializing Client(2) initializing Client(2) sending ping event to server Client(1) sending ping event to server Server handling ping from Client(1) Server sending pong back to caller Client(1) received pong event Server handling ping from Client(3) Server sending pong back to caller Server handling ping from Client(2) Server sending pong back to caller Client(2) received pong event Client(3) received pong event The CreateActor and SendEvent methods are non-blocking so you can see those operations are interleaved in the log output. The Coyote runtime will take care of all the underlying concurrency using the Task Parallel Library, which means that you do not need to explicitly create and manage tasks. However, you must be careful not to share data between actors because accessing that shared data from multiple actors at once could lead to race conditions. You can reduce race conditions in your code if you use events to transfer data from one actor to another. But since it is a reference model without deep copy semantics, you can actually share data between actors if you really need to. See sharing objects for more information in this advanced topic. Assertions Coyote also supports specifying invariants through assertions. You can do this by using the Assert method, which accepts as input a predicate that must always hold in that specific program point, e.g. this.Assert(k == 0) , which holds if the integer k equals to 0 . These Assert statement are useful for local invariants, i.e., they are about the state of a single actor. For global invariants it is recommended that you use Monitors . Samples To see a full working example of an Actor based program see the Hello World Actors tutorial. Seel also precise definition of actor semantics .","title":"Overview"},{"location":"concepts/actors/overview/#programming-model-asynchronous-actors","text":"The asynchronous actors programming model of Coyote is an actor-based programming model that encourages a message passing (or event based) programming model where all asynchronous actions happen by sending asynchronous events from one actor to another. This model is similar to how real people interact asynchronously via email. Each Coyote actor has an inbox for events, event handlers, as well as normal class fields and methods. Actors run concurrently with respect to each other, but individually they handle their input queue in a sequential way. When an event arrives, the actor dequeues that event from the input queue and handles it by executing a sequence of operations. Each operation might update a field, create a new actor, or send an event to another actor. In Coyote, creating actors and sending events are both non-blocking operations. In the case of a send operation the message (or event) is simply enqueued into the input queue of the target actor and, most importantly, it does not wait for the message to be processed at the target before returning control to the sender. The actor model also provides a specialized type of actor called a StateMachine . State machines are actors that have explicitly declared states and state transitions. Every object oriented class that has member variables is really also just a state machine where that state is updated as methods are called, but sometimes this gets really complicated and hard to test. Formal state machines help you model your states more explicitly and coyote tester can help you find bugs by exploring different state transitions using information you provide declaring how various types of events causes those state transitions. See also: how are Coyote Actors different from existing Microsoft Actor frameworks? .","title":"Programming model: asynchronous actors"},{"location":"concepts/actors/overview/#declaring-and-creating-actors","text":"An actor based program in Coyote is a normal .NET program that also uses the Actor or StateMachine base classes from the Microsoft.Coyote.Actors namespace, as well as the Event base class from the Microsoft.Coyote namespace. Actors can be declared in the following way: using Microsoft.Coyote.Actors; class Client : Actor { ... } class Server : Actor { ... } The above code declares two actors named Client and Server . Being a C# class you can also declare fields, properties and methods. An actor can create an instance of another actor and send Events using the following Actor methods: ActorId clientId = this.CreateActor(typeof(Client)); this.SendEvent(this.ClientId, new PingEvent()); When an event is being sent, it is enqueued in the event queue of the target actor. The coyote runtime will at some point dequeue the received event, and allow the target actor to handle it asynchronously. All actors in Coyote have an associated unique ActorId which identifies a specific instance of that type. Note that Coyote never gives you the actual object reference for an actor instance. This ensures your code does not get too tightly coupled. By limiting yourself to the Coyote API\u2019s for interacting with an actor, you also get all the benefits of coyote test in terms of understanding more deeply how to test all asynchronous interactions and ensure your specifications are maintained correctly. There is a lot of literature on actor models that explain in more depth the importance of this message passing programming model which is especially popular in the world of distributed systems. Event based programming is also popular in User Interface development and even shows up in low level embedded systems. It is a powerful tool for solving the tangled web of complexity that happens with less disciplined architectures.","title":"Declaring and creating actors"},{"location":"concepts/actors/overview/#starting-a-coyote-actor-based-program","text":"To create the first instance of an Actor you need to initialize the Coyote actor runtime inside your C# process (typically in the Main method). An example of this is the following: using Microsoft.Coyote; using Microsoft.Coyote.Actors; using Microsoft.Coyote.SystematicTesting; using System; class Program { static void Main(string[] args) { IActorRuntime runtime = RuntimeFactory.Create(); Execute(runtime); Console.ReadLine(); } [Test] public static void Execute(IActorRuntime runtime) { ActorId serverId = runtime.CreateActor(typeof(Server)); } } You must first import the Coyote runtime library ( Microsoft.Coyote.dll ), which you can get from NuGet , then create a runtime instance (of type IActorRuntime ) which you pass to a [Test] method. The test method named Execute will be the entry point that is used during testing of your Coyote program. In this case it simply invokes the CreateActor method of the runtime to instantiate the first Coyote actor (of type Server in the above example). The CreateActor method accepts as a parameter the type of the actor to be instantiated, and returns the ActorId representing that actor instance and this bootstraps a series of asynchronous events that handle initialization of that actor and any operations it performs during initialization. Because CreateActor is an asynchronous method, we call the Console.ReadLine method, which pauses the main thread until some console input has been given, so that the host C# program does not exit prematurely. The IActorRuntime interface also provides the SendEvent method for sending events to a Coyote actor. This method accepts as parameters an object of type ActorId and an event object. It also has a couple more advanced parameters which you don\u2019t need to worry about right now. An event can be created by sub-classing from Microsoft.Coyote.Event : class PingEvent : Event { public readonly ActorId Caller; public PingEvent(ActorId caller) { this.Caller = caller; } } class PongEvent : Event { } An event can contain members of any type (including scalar values or references to object) and when an event is sent to a target actor there is no deep-copying of those members, for performance reasons. The target actor will be able to see the Event object and cast it to a specific type to extract the information it needs. Now you can write a complete actor, declaring what type of events it can handle: [OnEventDoAction(typeof(PingEvent), nameof(HandlePing))] class Server : Actor { public void HandlePing(Event e) { PingEvent ping = (PingEvent)e; Console.WriteLine(\"Server handling ping\"); Console.WriteLine(\"Server sending pong back to caller\"); this.SendEvent(ping.Caller, new PongEvent()); } } This Server is an Actor that can receive PingEvent . The PingEvent contains the ActorId of the caller and the Server uses that to send back a PongEvent in response. An event handler controls how a machine reacts to a received event. It is clearly just a method so you can do anything there, including creating one or more actor instances, sending one or more events, updating some private state or invoking some 3rd party library. To complete this Coyote program, you can provide the following implementation of the Client actor: using System.Threading.Tasks; class SetupEvent : Event { public readonly ActorId ServerId; public SetupEvent(ActorId server) { this.ServerId = server; } } [OnEventDoAction(typeof(PongEvent), nameof(HandlePong))] class Client : Actor { public ActorId ServerId; protected override Task OnInitializeAsync(Event initialEvent) { Console.WriteLine(\"{0} initializing\", this.Id); this.ServerId = ((SetupEvent)initialEvent).ServerId; Console.WriteLine(\"{0} sending ping event to server\", this.Id); this.SendEvent(this.ServerId, new PingEvent(this.Id)); return base.OnInitializeAsync(initialEvent); } void HandlePong() { Console.WriteLine(\"{0} received pong event\", this.Id); } } This Client is an Actor that sends PingEvents to a server. This means the Client needs to know the ActorId of the Server . This can be done using an initialEvent passed to OnInitializeAsync . The Client then uses this ActorId to send a PingEvent to the Server . When the Server responds with a PongEvent the HandlePong method is called because of the OnEventDoAction declaration on the class. Notice in this case the HandlePong event handler takes no Event argument. The Event argument is optional on Coyote event handlers. Note that HandlePong could also be defined as an async Task method. Async handlers are allowed so that you can call external async systems in your production code, but this has some restrictions. You are not allowed to directly create parallel tasks inside an actor (e.g. by using Task.Run ) as that can introduce race conditions (if you need to parallelize a workload, you can simply create more actors). Also, during testing, you should not use Task.Delay or Task.Yield in your event handlers. It is ok to have truly async behavior in production, but at test time the coyote test tool wants to know about, so that it can control, all async behavior of your actor. If it detects some uncontrolled async behavior an error will be reported. One last remaining bit of code is needed in your Program to complete this example, namely, you need to create the Client actor in the Execute method, in fact, you can create as many Client actors as you want to make this an interesting test: public static void Execute(IActorRuntime runtime) { ActorId serverId = runtime.CreateActor(typeof(Server)); runtime.CreateActor(typeof(Client), new SetupEvent(serverId)); runtime.CreateActor(typeof(Client), new SetupEvent(serverId)); runtime.CreateActor(typeof(Client), new SetupEvent(serverId)); } The output of the program will be something like this: Client(3) initializing Client(3) sending ping event to server Client(1) initializing Client(2) initializing Client(2) sending ping event to server Client(1) sending ping event to server Server handling ping from Client(1) Server sending pong back to caller Client(1) received pong event Server handling ping from Client(3) Server sending pong back to caller Server handling ping from Client(2) Server sending pong back to caller Client(2) received pong event Client(3) received pong event The CreateActor and SendEvent methods are non-blocking so you can see those operations are interleaved in the log output. The Coyote runtime will take care of all the underlying concurrency using the Task Parallel Library, which means that you do not need to explicitly create and manage tasks. However, you must be careful not to share data between actors because accessing that shared data from multiple actors at once could lead to race conditions. You can reduce race conditions in your code if you use events to transfer data from one actor to another. But since it is a reference model without deep copy semantics, you can actually share data between actors if you really need to. See sharing objects for more information in this advanced topic.","title":"Starting a Coyote actor-based program"},{"location":"concepts/actors/overview/#assertions","text":"Coyote also supports specifying invariants through assertions. You can do this by using the Assert method, which accepts as input a predicate that must always hold in that specific program point, e.g. this.Assert(k == 0) , which holds if the integer k equals to 0 . These Assert statement are useful for local invariants, i.e., they are about the state of a single actor. For global invariants it is recommended that you use Monitors .","title":"Assertions"},{"location":"concepts/actors/overview/#samples","text":"To see a full working example of an Actor based program see the Hello World Actors tutorial. Seel also precise definition of actor semantics .","title":"Samples"},{"location":"concepts/actors/sharing-objects/","text":"Safely sharing objects between actors An actor program in Coyote is expected to be free of low-level data races. This means that two different actors should not race on access to the same object, unless both accesses are reads. Typically, you should build your application with an ownership protocol in mind to associate a unique owner actor to an object when writes have to be performed on that object. An exception to this rule is when using the thread-safe in-memory data structures provided by the Microsoft.Coyote.Actors.SharedObjects namespace. Microsoft.Coyote.Actors.SharedObjects Coyote provides multiple thread-safe in-memory data structures that help simplify writing actor programs. Instances of these data structures can be shared freely and accessed by multiple actors, even when performing write operations. There is a simple API for creating these shared data structures. Currently three kinds of shared data structures are available: SharedCounter , SharedRegister<T> and SharedDictionary . The following code snippet creates and initializes a SharedRegister . It then sends the register to a different actor m by stashing it as part of the payload of an event. SharedRegister<int> register = SharedRegister.Create<int>(this.Id.Runtime); register.SetValue(100); this.SendEvent(m, new MyEvent(register, ...)); var v = register.GetValue(); this.Assert(v == 100 || v == 200); Let\u2019s suppose that the target actors m , when it gets this MyEvent message, gets the register and does register.SetValue(200) . In this case, a read of the register in the source actor can either return the original value 100 or the value 200 set by m . In this way, these shared objects offer convenient ways of sharing data between actors (without going through explicit message creation, send, receive, etc.). Furthermore, if the assertion at the end of the code snippet shown above was this.Assert(v == 100) then the tester will be able to find and report a violation of the assertion because it understands SharedRegister operations as a source of synchronization. Internally, these data structures are written so that they use efficient thread-safe implementations in production runs of a Coyote program. For instance, SharedCounter uses Interlocked operations, SharedRegister uses small critical sections implemented using locks and SharedDictionary uses a ConcurrentDictionary . However, during test mode (i.e., while running tests under coyote test ) the implementation automatically switches to use an actor that serializes all accesses to the object. Thus, coyote test sees a normal Coyote program with no synchronization operations other than actor creation and message passing. At the moment, the APIs used to implement Microsoft.Coyote.Actors.SharedObjects are internal to Coyote. Important remark on using SharedDictionary<TKey, TValue> Conceptually you should think of a Coyote SharedObject as a wrapper around a Coyote actor. Thus, you need to be careful about stashing references inside a SharedObject and treat it in the same manner as sharing references between actors. In the case of a SharedDictionary both the key and the value (which are passed by reference into the dictionary) should not be mutated unless first removed from the dictionary because this can lead to a data race. Consider two actors that share a SharedDictionary object D . If both actors grab the value D[k] at the same key k they will each have a reference to the same object, creating the potential for a data race (unless the intention is to only do read operations on that object). The same note holds for SharedRegister<T> when T is a struct type with reference fields inside it. What about System.Collections.Concurrent? Yes, you can use the .NET thread safe collections to share information across actors but not the BlockingCollection as this can block and Coyote will not know about that which will lead to deadlocks during testing. The other thread safe collections do not have uncontrolled non-determinism, either from Task.Run, or from retry loops, timers or waits. The caveat is that Coyote has not instrumented the .NET concurrent collections, and so coyote does not systematically explore thread switching in the middle of these operations, therefore Coyote will not always find all data race conditions related to concurrent access on these collections.","title":"Sharing objects"},{"location":"concepts/actors/sharing-objects/#safely-sharing-objects-between-actors","text":"An actor program in Coyote is expected to be free of low-level data races. This means that two different actors should not race on access to the same object, unless both accesses are reads. Typically, you should build your application with an ownership protocol in mind to associate a unique owner actor to an object when writes have to be performed on that object. An exception to this rule is when using the thread-safe in-memory data structures provided by the Microsoft.Coyote.Actors.SharedObjects namespace.","title":"Safely sharing objects between actors"},{"location":"concepts/actors/sharing-objects/#microsoftcoyoteactorssharedobjects","text":"Coyote provides multiple thread-safe in-memory data structures that help simplify writing actor programs. Instances of these data structures can be shared freely and accessed by multiple actors, even when performing write operations. There is a simple API for creating these shared data structures. Currently three kinds of shared data structures are available: SharedCounter , SharedRegister<T> and SharedDictionary . The following code snippet creates and initializes a SharedRegister . It then sends the register to a different actor m by stashing it as part of the payload of an event. SharedRegister<int> register = SharedRegister.Create<int>(this.Id.Runtime); register.SetValue(100); this.SendEvent(m, new MyEvent(register, ...)); var v = register.GetValue(); this.Assert(v == 100 || v == 200); Let\u2019s suppose that the target actors m , when it gets this MyEvent message, gets the register and does register.SetValue(200) . In this case, a read of the register in the source actor can either return the original value 100 or the value 200 set by m . In this way, these shared objects offer convenient ways of sharing data between actors (without going through explicit message creation, send, receive, etc.). Furthermore, if the assertion at the end of the code snippet shown above was this.Assert(v == 100) then the tester will be able to find and report a violation of the assertion because it understands SharedRegister operations as a source of synchronization. Internally, these data structures are written so that they use efficient thread-safe implementations in production runs of a Coyote program. For instance, SharedCounter uses Interlocked operations, SharedRegister uses small critical sections implemented using locks and SharedDictionary uses a ConcurrentDictionary . However, during test mode (i.e., while running tests under coyote test ) the implementation automatically switches to use an actor that serializes all accesses to the object. Thus, coyote test sees a normal Coyote program with no synchronization operations other than actor creation and message passing. At the moment, the APIs used to implement Microsoft.Coyote.Actors.SharedObjects are internal to Coyote.","title":"Microsoft.Coyote.Actors.SharedObjects"},{"location":"concepts/actors/sharing-objects/#important-remark-on-using-shareddictionarytkey-tvalue","text":"Conceptually you should think of a Coyote SharedObject as a wrapper around a Coyote actor. Thus, you need to be careful about stashing references inside a SharedObject and treat it in the same manner as sharing references between actors. In the case of a SharedDictionary both the key and the value (which are passed by reference into the dictionary) should not be mutated unless first removed from the dictionary because this can lead to a data race. Consider two actors that share a SharedDictionary object D . If both actors grab the value D[k] at the same key k they will each have a reference to the same object, creating the potential for a data race (unless the intention is to only do read operations on that object). The same note holds for SharedRegister<T> when T is a struct type with reference fields inside it.","title":"Important remark on using SharedDictionary&lt;TKey, TValue&gt;"},{"location":"concepts/actors/sharing-objects/#what-about-systemcollectionsconcurrent","text":"Yes, you can use the .NET thread safe collections to share information across actors but not the BlockingCollection as this can block and Coyote will not know about that which will lead to deadlocks during testing. The other thread safe collections do not have uncontrolled non-determinism, either from Task.Run, or from retry loops, timers or waits. The caveat is that Coyote has not instrumented the .NET concurrent collections, and so coyote does not systematically explore thread switching in the middle of these operations, therefore Coyote will not always find all data race conditions related to concurrent access on these collections.","title":"What about System.Collections.Concurrent?"},{"location":"concepts/actors/state-machine-demo/","text":"State machine demo This graph was generated from a coyote test with the --xml-trace and --graph-bug options on a StateMachine based coyote application that implements the Raft protocol. The fact that coyote StateMachines expose explicit state information makes it possible for coyote to visualize what is going on in a level of detail that is hard to extract from other kinds of C# code. This illustrates the benefit of this programming model both for software design, as well as implementation enforcing this design, and testing that can find very hard to find bugs in these kinds of complex distributed systems. The trace shows a global order of messages being transferred between the various state machines. The message exchange is shown to happen one after the other (when in production they may be happening in parallel). This makes it easy to understand the trace. This trace, in fact, demonstrates a bug where two Raft Server state-machines both end up claiming to be leaders at the same time which is a violation of Raft\u2019s consensus requirements that there be at most one leader at a time. This animation is slowed down from actual testing speed so you can see what is happening. This entire test normally takes milliseconds so that Coyote can explore a huge number of possible tests in a short amount of time.","title":"State machine demo"},{"location":"concepts/actors/state-machine-demo/#state-machine-demo","text":"This graph was generated from a coyote test with the --xml-trace and --graph-bug options on a StateMachine based coyote application that implements the Raft protocol. The fact that coyote StateMachines expose explicit state information makes it possible for coyote to visualize what is going on in a level of detail that is hard to extract from other kinds of C# code. This illustrates the benefit of this programming model both for software design, as well as implementation enforcing this design, and testing that can find very hard to find bugs in these kinds of complex distributed systems. The trace shows a global order of messages being transferred between the various state machines. The message exchange is shown to happen one after the other (when in production they may be happening in parallel). This makes it easy to understand the trace. This trace, in fact, demonstrates a bug where two Raft Server state-machines both end up claiming to be leaders at the same time which is a violation of Raft\u2019s consensus requirements that there be at most one leader at a time. This animation is slowed down from actual testing speed so you can see what is happening. This entire test normally takes milliseconds so that Coyote can explore a huge number of possible tests in a short amount of time.","title":"State machine demo"},{"location":"concepts/actors/state-machines/","text":"State machines A Coyote state machine is a special type of Actor that inherits from the StateMachine class which lives in the Microsoft.Coyote.Actors namespace. A state machine adds State semantics with explicit information about how Events can trigger State changes in a StateMachine . You can write a state machine version of the Server class shown in Programming model: asynchronous actors like this: class ReadyEvent : Event { } class Server : StateMachine { [Start] [OnEntry(nameof(InitOnEntry))] [OnEventGotoState(typeof(ReadyEvent), typeof(Active))] class Init : State { } void InitOnEntry() { this.RaiseEvent(new ReadyEvent()); } [OnEventDoAction(typeof(PingEvent), nameof(HandlePing))] class Active : State { } void HandlePing(Event e) { var pe = (PingEvent)e; Console.WriteLine(\"Server received ping event from {0}\", pe.Caller.Name); this.SendEvent(pe.Caller, new PongEvent()); } } The above class declares a state machine named Server . The StateMachine class itself inherits from Actor so state machines are also actors and, of course, state machines are also normal C# classes. Actors and StateMachines can talk to each other by sending events. State machines in Coyote must also declare one or more states where a state is a nested class that inherits from the coyote State class which is a nested class inside StateMachine . The nested state classes can be private. The above code snippet declares two states in the Server machine: Init and Active . You must use the Start attribute to declare one of the states the initial state, which will be the first state that the machine will transition to upon initialization. In this example, the Init state has been declared as the initial state of Server . A state declaration can optionally be decorated with a number of state-specific attributes, as seen in the [Init] state: [OnEntry(nameof(InitOnEntry))] [OnEventGotoState(typeof(ReadyEvent), typeof(Active))] The OnEntry attribute denotes an action that will be executed when the machine transitions to the Init state, while the OnExit attribute denotes an action that will be executed when the machine leaves the state. Actions in Coyote are C# methods that take either no input parameters or a single input parameter of type Event , and return either void or async Task . OnExit actions cannot receive an Event argument. Note that Coyote actions are also referred to as event handlers, however these should not be confused with the System.EventHandler , which have a different prototype. Notice that the InitOnEntry method declared above is similar to the original OnInitializeAsync method on the Server Actor. The RaiseEvent call is used to trigger the state transition defined in the OnEventGotoState custom attribute, in this case it is ready to transition to the Active state: this.RaiseEvent(new ReadyEvent()); The RaiseEvent call is used to send an event to yourself. Similar to SendEvent , when a machine raises an event on itself, it is also queued so that the method can continue execution until the InitOnEntry method is completed. When control returns to the coyote runtime, instead of dequeuing the next event from the inbox (if there is one), the machine immediately handles the raised event (so raised events are prioritized over any events in the inbox). This prioritization is important in the above case, because it guarantees that the Server will transition to the Active state before the PingEvent is received from the Client . The attribute OnEventGotoState indicates that if the state machine receives the ReadyEvent event while it is currently in the Init state, it will automatically handle the ReadyEvent by exiting the Init state and transitioning to the Active state. This saves you from having to write that trivial event handler logic. All this happens as a result of the simple RaiseEvent call and the OnEventGotoState attribute. The Coyote state machine programming model takes a lot of tedium out of managing explicit state machinery. If you ever find yourself building your own state machinery, then you definitely should consider using the Coyote state machine class instead. Note that on a given State of a state machine, you can only define one handler for a given event type. When you run this new StateMachine based Server you will see the same output as before, with the addition of the state information from HandlePong : Program+Client(2) initializing Program+Client(2) sending ping event to server Program+Client(1) initializing Program+Client(1) sending ping event to server Program+Client(3) initializing Program+Client(3) sending ping event to server Server received ping event from Program+Client(2) Server received ping event from Program+Client(1) Server received ping event from Program+Client(3) Program+Client(2) received pong event Program+Client(3) received pong event Program+Client(1) received pong event Unlike Actors which declare the events they can receive at the class level, StateMachines can also declare this information on the States . This gives StateMachines more fine grained control, for example, perhaps you want your state machine to only be able to receive a certain type of event when it is in a particular state. In an Actor you would need to check this yourself and throw an exception, whereas in a state machine this is more declarative and is enforced by the Coyote runtime; the Coyote runtime will report an error if an event is received on a State of a StateMachine that was not expecting to receive that event. This reduces the amount of tedious book keeping code you need to write, and keeps your code even cleaner. For an example of a state machine in action see the state machine demo . Goto, push and pop states Besides RaiseEvent , state machine event handlers can request a state change in code rather than depending on OnEventGotoState attributes. This allows conditional goto operations as shown in the following example: void InitOnEntry() { if (this.Random()) { this.RaiseGotoStateEvent<Active>(); } else { this.RaiseGotoStateEvent<Busy>(); } } State machines can also push and pop states, effectively creating a stack of active states. Use [OnEventPushState(...)] or RaisePushStateEvent in code to push a new state: this.RaisePushStateEvent<Active>(); This will push the Active state on the stack, but it will also inherit some actions declared on the Init state. The Active state can pop itself off the stack, returning to the Init state using a RaisePopStateEvent call: void HandlePing() { Console.WriteLine(\"Server received ping event while in the {0} state\", this.CurrentState.Name); // pop the current state off the stack of active states. this.RaisePopStateEvent(); } Note that this does not result in the OnEntry method being called again, because you never actually exited the Init state in this case. But if you used RaiseGotoStateEvent instead of RaisePushStateEvent and RaisePopStateEvent then InitOnEntry will be called again, and that would make our Server toggle back and forth between the Init and Active states. The push and pop feature is considered an advanced feature of state machines. It is designed to help you reuse some of your event handling code, where you can put \u201ccommon event handling\u201d in lower states and more specific event handling in pushed states. If an event handler is defined more than once in the stack, the one closest to the top of the stack is used. Only one Raise* operation per action There is an important restriction on the use of the following. Only one of these operations can be queued up per event handling action: RaiseEvent RaiseGotoStateEvent RaisePushStateEvent RaisePopStateEvent RaiseHaltEvent A runtime Assert will be raised if you accidentally try and do two of these operations in a single action. For example, this would be an error because you are trying to do two Raise operations in the InitOnEntry action: void InitOnEntry() { this.RaiseGotoStateEvent<Active>(); this.RaiseEvent(new TestEvent()); } Deferring and ignoring events Coyote also provides the capability to defer and ignore events while in a particular state: [DeferEvents(typeof(PingEvent), typeof(PongEvent))] [IgnoreEvents(typeof(ReadyEvent))] class SomeState : State { } The attribute DeferEvents indicates that the PingEvent and PongEvent events should not be dequeued while the machine is in the state SomeState . Instead, the machine should skip over PingEvent and PongEvent (without dropping these events from the queue) and dequeue the next event that is not being deferred. Note that when a state decides to defer an event a subsequent pushed state can choose to receive that event if it wants to, but if the pushed state chooses not to receive the event then it is not an error and it remains deferred. The attribute IgnoreEvents indicates that whenever ReadyEvent is dequeued while the machine is in SomeState , then the machine should drop ReadyEvent without invoking any action. Note that when a state decides to ignore an event a subsequent pushed state can choose to receive that event if it wants to, but if the pushed state chooses not to receive the event then it is not an error and the event will be ignored and dropped. Default events State machines support an interesting concept called default events . A state can request that something be done by default when there is nothing else to do. [OnEventDoAction(typeof(DefaultEvent), nameof(OnIdle))] class Idle : State { } public void OnIdle() { Console.WriteLine(\"OnIdle\"); } The Coyote runtime will invoke this action handler when Idle is the current active state and the state machine has nothing else to do (the inbox has no events that can be processed). If nothing else happens, (no other actionable events are queued on this state machine) then the OnIdle method will be called over and over until something else changes. It is more efficient to use CreatePeriodicTimer for low priority work. Default events can also invoke goto, and push state transitions, which brings up an interesting case where you can actually implement an infinite ping pong using the following: internal class PingPongMachine : StateMachine { [Start] [OnEntry(nameof(OnPing))] [OnEventGotoState(typeof(DefaultEvent), typeof(Pong))] public class Ping : State { } public void OnPing() { Console.WriteLine(\"OnPing\"); } [OnEntry(nameof(OnPong))] [OnEventGotoState(typeof(DefaultEvent), typeof(Ping))] public class Pong : State { } void OnPong() { Console.WriteLine(\"OnPong\"); } } The difference between this and a timer based ping-pong is that this will run as fast as the Coyote runtime can go. So you have to be careful using DefaultEvents like this as it could use up a lot of CPU time. WildCard events State machines also support a special WildcardEvent which acts as a special pattern matching event that matches all event types. This means you can create generic actions, or state transitions as a result of receiving any event (except the DefaultEvent ). The following example shows how the WildcardEvent can be used: internal class WildMachine : StateMachine { [Start] [OnEntry(nameof(OnInit))] [OnEventGotoState(typeof(WildCardEvent), typeof(CatchAll))] public class Init : State { } public void OnInit() { Console.WriteLine(\"Entering state {0}\", this.CurrentStateName); } [OnEntry(nameof(OnInit))] [OnEntry(nameof(OnCatchAll))] [OnEventDoAction(typeof(WildCardEvent), nameof(OnCatchAll))] public class CatchAll : State { } void OnCatchAll(Event e) { Console.WriteLine(\"Catch all state caught event of type {0}\", e.GetType().Name); } } The client of this state machine can send any event it wants and it will cause a transition to the CatchAll state where it will be handled by the OnCatchAll method. For example: class X : Event { }; var actor = runtime.CreateActor(typeof(WildMachine)); runtime.SendEvent(actor, new X()); And the output of this test is: Entering state Init Entering state CatchAll Catch all state caught event of type X Precise semantics There is a lot of interesting combinations of things that you can do with DeferEvents , IgnoreEvents , OnEventDoAction , OnEventGotoState or OnEventPushState and WildcardEvent . The following gives the precise semantics of these operations with regards to push and pop. First of all only one action per specific event type can be defined on a given State , so the following would be an error: [DeferEvents(typeof(E1), typeof(E2))] [OnEventDoAction(typeof(E1), nameof(HandleE1))] class SomeState : State { } Because the E1 has both a DeferEvents and OnEventDoAction defined on the same state. Second, a pushed state inherits DeferEvents , IgnoreEvents , OnEventDoAction actions from all previous states on the active state stack, but it does not inherit OnEventGotoState or OnEventPushState actions. If multiple states on the stack of active states define an action for a specific event type then the action closest to the top of the stack takes precedence. For example: [DeferEvents(typeof(E1))] [OnEventPushState(typeof(E1), typeof(S2))] class A : State { } [OnEventDoAction(typeof(E1), nameof(HandleE1))] class B : State { } In state B the OnEventDoAction takes precedence over the inherited DeferEvents for event E1 . On a given state actions defined for a specific event type take precedence over actions involving WildcardEvent but a pushed state can override a specific event type action with a WildcardEvent action. If an event cannot be handled by a pushed state then that state is automatically popped so handling can be attempted again on the lower states. If this auto-popping pops all states then an unhandled event error is raised.","title":"State machines"},{"location":"concepts/actors/state-machines/#state-machines","text":"A Coyote state machine is a special type of Actor that inherits from the StateMachine class which lives in the Microsoft.Coyote.Actors namespace. A state machine adds State semantics with explicit information about how Events can trigger State changes in a StateMachine . You can write a state machine version of the Server class shown in Programming model: asynchronous actors like this: class ReadyEvent : Event { } class Server : StateMachine { [Start] [OnEntry(nameof(InitOnEntry))] [OnEventGotoState(typeof(ReadyEvent), typeof(Active))] class Init : State { } void InitOnEntry() { this.RaiseEvent(new ReadyEvent()); } [OnEventDoAction(typeof(PingEvent), nameof(HandlePing))] class Active : State { } void HandlePing(Event e) { var pe = (PingEvent)e; Console.WriteLine(\"Server received ping event from {0}\", pe.Caller.Name); this.SendEvent(pe.Caller, new PongEvent()); } } The above class declares a state machine named Server . The StateMachine class itself inherits from Actor so state machines are also actors and, of course, state machines are also normal C# classes. Actors and StateMachines can talk to each other by sending events. State machines in Coyote must also declare one or more states where a state is a nested class that inherits from the coyote State class which is a nested class inside StateMachine . The nested state classes can be private. The above code snippet declares two states in the Server machine: Init and Active . You must use the Start attribute to declare one of the states the initial state, which will be the first state that the machine will transition to upon initialization. In this example, the Init state has been declared as the initial state of Server . A state declaration can optionally be decorated with a number of state-specific attributes, as seen in the [Init] state: [OnEntry(nameof(InitOnEntry))] [OnEventGotoState(typeof(ReadyEvent), typeof(Active))] The OnEntry attribute denotes an action that will be executed when the machine transitions to the Init state, while the OnExit attribute denotes an action that will be executed when the machine leaves the state. Actions in Coyote are C# methods that take either no input parameters or a single input parameter of type Event , and return either void or async Task . OnExit actions cannot receive an Event argument. Note that Coyote actions are also referred to as event handlers, however these should not be confused with the System.EventHandler , which have a different prototype. Notice that the InitOnEntry method declared above is similar to the original OnInitializeAsync method on the Server Actor. The RaiseEvent call is used to trigger the state transition defined in the OnEventGotoState custom attribute, in this case it is ready to transition to the Active state: this.RaiseEvent(new ReadyEvent()); The RaiseEvent call is used to send an event to yourself. Similar to SendEvent , when a machine raises an event on itself, it is also queued so that the method can continue execution until the InitOnEntry method is completed. When control returns to the coyote runtime, instead of dequeuing the next event from the inbox (if there is one), the machine immediately handles the raised event (so raised events are prioritized over any events in the inbox). This prioritization is important in the above case, because it guarantees that the Server will transition to the Active state before the PingEvent is received from the Client . The attribute OnEventGotoState indicates that if the state machine receives the ReadyEvent event while it is currently in the Init state, it will automatically handle the ReadyEvent by exiting the Init state and transitioning to the Active state. This saves you from having to write that trivial event handler logic. All this happens as a result of the simple RaiseEvent call and the OnEventGotoState attribute. The Coyote state machine programming model takes a lot of tedium out of managing explicit state machinery. If you ever find yourself building your own state machinery, then you definitely should consider using the Coyote state machine class instead. Note that on a given State of a state machine, you can only define one handler for a given event type. When you run this new StateMachine based Server you will see the same output as before, with the addition of the state information from HandlePong : Program+Client(2) initializing Program+Client(2) sending ping event to server Program+Client(1) initializing Program+Client(1) sending ping event to server Program+Client(3) initializing Program+Client(3) sending ping event to server Server received ping event from Program+Client(2) Server received ping event from Program+Client(1) Server received ping event from Program+Client(3) Program+Client(2) received pong event Program+Client(3) received pong event Program+Client(1) received pong event Unlike Actors which declare the events they can receive at the class level, StateMachines can also declare this information on the States . This gives StateMachines more fine grained control, for example, perhaps you want your state machine to only be able to receive a certain type of event when it is in a particular state. In an Actor you would need to check this yourself and throw an exception, whereas in a state machine this is more declarative and is enforced by the Coyote runtime; the Coyote runtime will report an error if an event is received on a State of a StateMachine that was not expecting to receive that event. This reduces the amount of tedious book keeping code you need to write, and keeps your code even cleaner. For an example of a state machine in action see the state machine demo .","title":"State machines"},{"location":"concepts/actors/state-machines/#goto-push-and-pop-states","text":"Besides RaiseEvent , state machine event handlers can request a state change in code rather than depending on OnEventGotoState attributes. This allows conditional goto operations as shown in the following example: void InitOnEntry() { if (this.Random()) { this.RaiseGotoStateEvent<Active>(); } else { this.RaiseGotoStateEvent<Busy>(); } } State machines can also push and pop states, effectively creating a stack of active states. Use [OnEventPushState(...)] or RaisePushStateEvent in code to push a new state: this.RaisePushStateEvent<Active>(); This will push the Active state on the stack, but it will also inherit some actions declared on the Init state. The Active state can pop itself off the stack, returning to the Init state using a RaisePopStateEvent call: void HandlePing() { Console.WriteLine(\"Server received ping event while in the {0} state\", this.CurrentState.Name); // pop the current state off the stack of active states. this.RaisePopStateEvent(); } Note that this does not result in the OnEntry method being called again, because you never actually exited the Init state in this case. But if you used RaiseGotoStateEvent instead of RaisePushStateEvent and RaisePopStateEvent then InitOnEntry will be called again, and that would make our Server toggle back and forth between the Init and Active states. The push and pop feature is considered an advanced feature of state machines. It is designed to help you reuse some of your event handling code, where you can put \u201ccommon event handling\u201d in lower states and more specific event handling in pushed states. If an event handler is defined more than once in the stack, the one closest to the top of the stack is used.","title":"Goto, push and pop states"},{"location":"concepts/actors/state-machines/#only-one-raise-operation-per-action","text":"There is an important restriction on the use of the following. Only one of these operations can be queued up per event handling action: RaiseEvent RaiseGotoStateEvent RaisePushStateEvent RaisePopStateEvent RaiseHaltEvent A runtime Assert will be raised if you accidentally try and do two of these operations in a single action. For example, this would be an error because you are trying to do two Raise operations in the InitOnEntry action: void InitOnEntry() { this.RaiseGotoStateEvent<Active>(); this.RaiseEvent(new TestEvent()); }","title":"Only one Raise* operation per action"},{"location":"concepts/actors/state-machines/#deferring-and-ignoring-events","text":"Coyote also provides the capability to defer and ignore events while in a particular state: [DeferEvents(typeof(PingEvent), typeof(PongEvent))] [IgnoreEvents(typeof(ReadyEvent))] class SomeState : State { } The attribute DeferEvents indicates that the PingEvent and PongEvent events should not be dequeued while the machine is in the state SomeState . Instead, the machine should skip over PingEvent and PongEvent (without dropping these events from the queue) and dequeue the next event that is not being deferred. Note that when a state decides to defer an event a subsequent pushed state can choose to receive that event if it wants to, but if the pushed state chooses not to receive the event then it is not an error and it remains deferred. The attribute IgnoreEvents indicates that whenever ReadyEvent is dequeued while the machine is in SomeState , then the machine should drop ReadyEvent without invoking any action. Note that when a state decides to ignore an event a subsequent pushed state can choose to receive that event if it wants to, but if the pushed state chooses not to receive the event then it is not an error and the event will be ignored and dropped.","title":"Deferring and ignoring events"},{"location":"concepts/actors/state-machines/#default-events","text":"State machines support an interesting concept called default events . A state can request that something be done by default when there is nothing else to do. [OnEventDoAction(typeof(DefaultEvent), nameof(OnIdle))] class Idle : State { } public void OnIdle() { Console.WriteLine(\"OnIdle\"); } The Coyote runtime will invoke this action handler when Idle is the current active state and the state machine has nothing else to do (the inbox has no events that can be processed). If nothing else happens, (no other actionable events are queued on this state machine) then the OnIdle method will be called over and over until something else changes. It is more efficient to use CreatePeriodicTimer for low priority work. Default events can also invoke goto, and push state transitions, which brings up an interesting case where you can actually implement an infinite ping pong using the following: internal class PingPongMachine : StateMachine { [Start] [OnEntry(nameof(OnPing))] [OnEventGotoState(typeof(DefaultEvent), typeof(Pong))] public class Ping : State { } public void OnPing() { Console.WriteLine(\"OnPing\"); } [OnEntry(nameof(OnPong))] [OnEventGotoState(typeof(DefaultEvent), typeof(Ping))] public class Pong : State { } void OnPong() { Console.WriteLine(\"OnPong\"); } } The difference between this and a timer based ping-pong is that this will run as fast as the Coyote runtime can go. So you have to be careful using DefaultEvents like this as it could use up a lot of CPU time.","title":"Default events"},{"location":"concepts/actors/state-machines/#wildcard-events","text":"State machines also support a special WildcardEvent which acts as a special pattern matching event that matches all event types. This means you can create generic actions, or state transitions as a result of receiving any event (except the DefaultEvent ). The following example shows how the WildcardEvent can be used: internal class WildMachine : StateMachine { [Start] [OnEntry(nameof(OnInit))] [OnEventGotoState(typeof(WildCardEvent), typeof(CatchAll))] public class Init : State { } public void OnInit() { Console.WriteLine(\"Entering state {0}\", this.CurrentStateName); } [OnEntry(nameof(OnInit))] [OnEntry(nameof(OnCatchAll))] [OnEventDoAction(typeof(WildCardEvent), nameof(OnCatchAll))] public class CatchAll : State { } void OnCatchAll(Event e) { Console.WriteLine(\"Catch all state caught event of type {0}\", e.GetType().Name); } } The client of this state machine can send any event it wants and it will cause a transition to the CatchAll state where it will be handled by the OnCatchAll method. For example: class X : Event { }; var actor = runtime.CreateActor(typeof(WildMachine)); runtime.SendEvent(actor, new X()); And the output of this test is: Entering state Init Entering state CatchAll Catch all state caught event of type X","title":"WildCard events"},{"location":"concepts/actors/state-machines/#precise-semantics","text":"There is a lot of interesting combinations of things that you can do with DeferEvents , IgnoreEvents , OnEventDoAction , OnEventGotoState or OnEventPushState and WildcardEvent . The following gives the precise semantics of these operations with regards to push and pop. First of all only one action per specific event type can be defined on a given State , so the following would be an error: [DeferEvents(typeof(E1), typeof(E2))] [OnEventDoAction(typeof(E1), nameof(HandleE1))] class SomeState : State { } Because the E1 has both a DeferEvents and OnEventDoAction defined on the same state. Second, a pushed state inherits DeferEvents , IgnoreEvents , OnEventDoAction actions from all previous states on the active state stack, but it does not inherit OnEventGotoState or OnEventPushState actions. If multiple states on the stack of active states define an action for a specific event type then the action closest to the top of the stack takes precedence. For example: [DeferEvents(typeof(E1))] [OnEventPushState(typeof(E1), typeof(S2))] class A : State { } [OnEventDoAction(typeof(E1), nameof(HandleE1))] class B : State { } In state B the OnEventDoAction takes precedence over the inherited DeferEvents for event E1 . On a given state actions defined for a specific event type take precedence over actions involving WildcardEvent but a pushed state can override a specific event type action with a WildcardEvent action. If an event cannot be handled by a pushed state then that state is automatically popped so handling can be attempted again on the lower states. If this auto-popping pops all states then an unhandled event error is raised.","title":"Precise semantics"},{"location":"concepts/actors/synchronous-execution/","text":"Obsolete Note: these api\u2019s are now obsolete and it is recommended instead that you use the Event Group construct to track the asynchronous completion of operations across your actors. Synchronous execution of actors Coyote offers the following APIs (and overloads) for synchronous execution of actor creation and event sending. Task<ActorId> CreateActorAndExecuteAsync(Type type, Event e = null, Guid opGroupId = default); Task<bool> SendEventAndExecuteAsync(ActorId target, Event e, Guid opGroupId = default, SendOptions options = null); Both of these are async methods and must be awaited by the caller. The method CreateActorAndExecuteAsync when awaited, returns only when the newly created actor becomes idle. That is, it creates the actor, passes it the initial event e , starts executing the actor, and then waits for the actor to become idle. An actor is idle when no events can be received from its inbox. The method SendEventAndExecuteAsync when awaited has two possible executions. If the target actor is running (i.e., it is not idle) then the method only enqueues the event and returns immediately with the return value false . If the target actor was idle then the method enqueues the event (which causes the target actor to start executing) and waits until the actor becomes idle again. In this case, the method returns true indicating that the event has been processed by the target actor. Note that this is only one level deep. If the event handler invoked by the actor creation or event handling decides to send more events to other actors, then the above synchronous methods do not wait for that additional work to be completed, unless those events are sent to this.Id which does stop the actor from becoming idle. Another type of synchronous execution is provided by the Actor method ReceiveEventAsync . This method allows an actor to wait for a given type of event to be received, and can even provide a predicate that conditionally receives the event. This means instead of declaring an event handler like this which means you can receive this event any time and call HandlePoing: [OnEventDoAction(typeof(PongEvent), nameof(HandlePong))] You can instead explicitly receive the event in a specific place in your actor like this so that the event is not generally handled at other times: Event e = await this.ReceiveEventAsync(typeof(PongEvent)); HandlePong(e); A second overload of ReceiveEventAsync allows you to provide a list of event types each with their own predicates. This version of the method receives the first matching event. A ReceiveEventAsync call blocks all non-matching events from being dequeued from the actor\u2019s inbox. Potential deadlocks with ReceiveEventAsync You should be careful with the use of ReceiveEventAsync when using CreateActorAndExecuteAsync and SendEventAndExecuteAsync . In the absence of ReceiveEventAsync , the semantics of these methods guarantee that the program cannot deadlock. With a ReceiveEventAsync the following situation can occur. Let\u2019s suppose there are two actors A and B and the latter is idle. Then actor A does SendEventAndExecuteAsync to pass an event e to B . Because B was idle, A will wait until B becomes idle again. But if B executes a ReceiveEventAsync while processing the event e , expecting another event from A then the program deadlocks. (Blocking on a ReceiveEventAsync is not considered as being idle.) Extracting information from an actor Suppose there is a Coyote actor M1 that holds some information that you are interested in grabbing. The usual way of getting this information would be to SendEvent a \u201cget\u201d message to M1 and then wait for its response via ReceiveEventAsync . However, a ReceiveEventAsync can only be executed by an actor. How do you get the result outside the context of an actor, from, say, a static method? One option is to use these *AndExecuteAsync methods. First define a trampoline actor T that you create from your static method via CreateActorAndExecuteAsync . The trampoline actor, in its OnEntry method of the start state (which is called immediately when a actor is created), sends the \u201cget\u201d message to M1 and waits for its response via ReceiveEventAsync . Once it gets the response, it can stash the result in an object that can be safely shared with the calling static method without any race conditions. You can use a SharedRegister , which will rule out race conditions as well, but this still requires a separate protocol to know when the result has been made available. Running an actor synchronously Another programming pattern is to drive an actor synchronously. The program can do CreateActorAndExecuteAsync to create the actor, then repeatedly do SendEventAndExecuteAsync to make the actor process events one after another. Let\u2019s consider an example. Suppose that we need to define a actor M that is easily decomposed into two smaller actors M1 and M2 . For each incoming event, M decides to run one of the two actors; there is no need to run them in parallel. In this case, you only need to code up the smaller actors M1 and M2 . The actor M can be a simple wrapper. On instantiation, M creates the two child actors as follows: ActorId m1 = this.CreateActorAndExecuteAsync(typeof(M1), ...); ActorId m2 = this.CreateActorAndExecuteAsync(typeof(M2), ...); When M receives an event e , it will choose to run the appropriate actor as follows: if (SomeCondition(e)) { bool b1 = await this.SendEventAndExecuteAsync(m1, e); this.Assert(b1); } else { bool b2 = await this.SendEventAndExecuteAsync(m2, e); this.Assert(b2); } Note that the two assertions above are guaranteed to never fail because the m1 and m2 actors are always left in an idle state by M , provided that M never gives out the ActorId of m1 or m2 to any other actors and does not so long as M1 and M2 do not queue other events on themselves using SendEvent .","title":"Synchronous execution"},{"location":"concepts/actors/synchronous-execution/#obsolete","text":"Note: these api\u2019s are now obsolete and it is recommended instead that you use the Event Group construct to track the asynchronous completion of operations across your actors.","title":"Obsolete"},{"location":"concepts/actors/synchronous-execution/#synchronous-execution-of-actors","text":"Coyote offers the following APIs (and overloads) for synchronous execution of actor creation and event sending. Task<ActorId> CreateActorAndExecuteAsync(Type type, Event e = null, Guid opGroupId = default); Task<bool> SendEventAndExecuteAsync(ActorId target, Event e, Guid opGroupId = default, SendOptions options = null); Both of these are async methods and must be awaited by the caller. The method CreateActorAndExecuteAsync when awaited, returns only when the newly created actor becomes idle. That is, it creates the actor, passes it the initial event e , starts executing the actor, and then waits for the actor to become idle. An actor is idle when no events can be received from its inbox. The method SendEventAndExecuteAsync when awaited has two possible executions. If the target actor is running (i.e., it is not idle) then the method only enqueues the event and returns immediately with the return value false . If the target actor was idle then the method enqueues the event (which causes the target actor to start executing) and waits until the actor becomes idle again. In this case, the method returns true indicating that the event has been processed by the target actor. Note that this is only one level deep. If the event handler invoked by the actor creation or event handling decides to send more events to other actors, then the above synchronous methods do not wait for that additional work to be completed, unless those events are sent to this.Id which does stop the actor from becoming idle. Another type of synchronous execution is provided by the Actor method ReceiveEventAsync . This method allows an actor to wait for a given type of event to be received, and can even provide a predicate that conditionally receives the event. This means instead of declaring an event handler like this which means you can receive this event any time and call HandlePoing: [OnEventDoAction(typeof(PongEvent), nameof(HandlePong))] You can instead explicitly receive the event in a specific place in your actor like this so that the event is not generally handled at other times: Event e = await this.ReceiveEventAsync(typeof(PongEvent)); HandlePong(e); A second overload of ReceiveEventAsync allows you to provide a list of event types each with their own predicates. This version of the method receives the first matching event. A ReceiveEventAsync call blocks all non-matching events from being dequeued from the actor\u2019s inbox.","title":"Synchronous execution of actors"},{"location":"concepts/actors/synchronous-execution/#potential-deadlocks-with-receiveeventasync","text":"You should be careful with the use of ReceiveEventAsync when using CreateActorAndExecuteAsync and SendEventAndExecuteAsync . In the absence of ReceiveEventAsync , the semantics of these methods guarantee that the program cannot deadlock. With a ReceiveEventAsync the following situation can occur. Let\u2019s suppose there are two actors A and B and the latter is idle. Then actor A does SendEventAndExecuteAsync to pass an event e to B . Because B was idle, A will wait until B becomes idle again. But if B executes a ReceiveEventAsync while processing the event e , expecting another event from A then the program deadlocks. (Blocking on a ReceiveEventAsync is not considered as being idle.)","title":"Potential deadlocks with ReceiveEventAsync"},{"location":"concepts/actors/synchronous-execution/#extracting-information-from-an-actor","text":"Suppose there is a Coyote actor M1 that holds some information that you are interested in grabbing. The usual way of getting this information would be to SendEvent a \u201cget\u201d message to M1 and then wait for its response via ReceiveEventAsync . However, a ReceiveEventAsync can only be executed by an actor. How do you get the result outside the context of an actor, from, say, a static method? One option is to use these *AndExecuteAsync methods. First define a trampoline actor T that you create from your static method via CreateActorAndExecuteAsync . The trampoline actor, in its OnEntry method of the start state (which is called immediately when a actor is created), sends the \u201cget\u201d message to M1 and waits for its response via ReceiveEventAsync . Once it gets the response, it can stash the result in an object that can be safely shared with the calling static method without any race conditions. You can use a SharedRegister , which will rule out race conditions as well, but this still requires a separate protocol to know when the result has been made available.","title":"Extracting information from an actor"},{"location":"concepts/actors/synchronous-execution/#running-an-actor-synchronously","text":"Another programming pattern is to drive an actor synchronously. The program can do CreateActorAndExecuteAsync to create the actor, then repeatedly do SendEventAndExecuteAsync to make the actor process events one after another. Let\u2019s consider an example. Suppose that we need to define a actor M that is easily decomposed into two smaller actors M1 and M2 . For each incoming event, M decides to run one of the two actors; there is no need to run them in parallel. In this case, you only need to code up the smaller actors M1 and M2 . The actor M can be a simple wrapper. On instantiation, M creates the two child actors as follows: ActorId m1 = this.CreateActorAndExecuteAsync(typeof(M1), ...); ActorId m2 = this.CreateActorAndExecuteAsync(typeof(M2), ...); When M receives an event e , it will choose to run the appropriate actor as follows: if (SomeCondition(e)) { bool b1 = await this.SendEventAndExecuteAsync(m1, e); this.Assert(b1); } else { bool b2 = await this.SendEventAndExecuteAsync(m2, e); this.Assert(b2); } Note that the two assertions above are guaranteed to never fail because the m1 and m2 actors are always left in an idle state by M , provided that M never gives out the ActorId of m1 or m2 to any other actors and does not so long as M1 and M2 do not queue other events on themselves using SendEvent .","title":"Running an actor synchronously"},{"location":"concepts/actors/termination/","text":"Explicit termination of an actor Coyote actors and state machines continue running unless they are explicitly terminated. The runtime will mark an actor as idle if it has no work to do, but it will not reclaim any resources held by the actor unless it is terminated. An actor is terminated when it performs the Halt operation, as seen in the following example: private class Example : Actor { private void SomeAction() { if (this.timeToStop) { this.Halt(); } } protected override Task OnHaltAsync(Event e) { // Do some cleanup on halt. return Task.CompletedTask; } } Additionally, an actor can be halted by another actor by sending a special built-in event called HaltEvent . On state machines this event can also be used for self termination using RaiseEvent . Termination of an actor due to an unhandled HaltEvent event is valid behavior (the Coyote runtime does not report an error). An event sent to a halted actor is simply dropped. A halted actor cannot be restarted; it remains halted forever. The Coyote runtime implements actor termination efficiently by cleaning up resources allocated to a halted actor and recording that the actor has halted. Actor termination via Halt is an asynchronous operation. So in failover scenarios where you need to be sure an actor is fully terminated before creating it\u2019s replacement actor, you will need to create a handshake callback event sent from OnHaltAsync telling the caller that the actor has officially halted, otherwise there will be a brief period of time where both actors are alive which may not be what you want when modeling a failover situation. This is shown in the test failover tutorial.","title":"Actor termination"},{"location":"concepts/actors/termination/#explicit-termination-of-an-actor","text":"Coyote actors and state machines continue running unless they are explicitly terminated. The runtime will mark an actor as idle if it has no work to do, but it will not reclaim any resources held by the actor unless it is terminated. An actor is terminated when it performs the Halt operation, as seen in the following example: private class Example : Actor { private void SomeAction() { if (this.timeToStop) { this.Halt(); } } protected override Task OnHaltAsync(Event e) { // Do some cleanup on halt. return Task.CompletedTask; } } Additionally, an actor can be halted by another actor by sending a special built-in event called HaltEvent . On state machines this event can also be used for self termination using RaiseEvent . Termination of an actor due to an unhandled HaltEvent event is valid behavior (the Coyote runtime does not report an error). An event sent to a halted actor is simply dropped. A halted actor cannot be restarted; it remains halted forever. The Coyote runtime implements actor termination efficiently by cleaning up resources allocated to a halted actor and recording that the actor has halted. Actor termination via Halt is an asynchronous operation. So in failover scenarios where you need to be sure an actor is fully terminated before creating it\u2019s replacement actor, you will need to create a handshake callback event sent from OnHaltAsync telling the caller that the actor has officially halted, otherwise there will be a brief period of time where both actors are alive which may not be what you want when modeling a failover situation. This is shown in the test failover tutorial.","title":"Explicit termination of an actor"},{"location":"concepts/actors/timers/","text":"Using timers in actors The Coyote actor programming model has built-in support for timers. Timers are themselves a type of Actor that send a TimerElapsedEvent upon timeout to the actor that created the timer. Timers are handy for modeling a common type of asynchronous behavior in distributed systems, so you can find more bugs in your code relating to how it deals with the uncertainty of various kinds of timeouts. Timers provide a once only timeout event or a periodic timeout, which can continually send such events on a user-defined interval until they are stopped. To make use of timers, you must include the Microsoft.Coyote.Actors.Timers namespace. You can start a non-periodic timer using the function StartTimer . TimerInfo StartTimer(TimeSpan startDelay, TimerElapsedEvent customEvent) StartTimer takes as argument: 1. TimeSpan startDelay , which is the amount of time to wait before sending the timeout event. 2. TimerElapsedEvent customEvent , an optional custom event (of a user-specified subclass of TimerElapsedEvent ) to raise instead of the default TimerElapsedEvent . StartTimer returns TimerInfo , which contains information about the created non-periodic timer. The non-periodic timer is automatically disposed after it timeouts. You can also pass the TimerInfo to the StopTimer method to manually stop and dispose the timer. The timer enqueues events of type TimerElapsedEvent (or of a user-specified subclass of TimerElapsedEvent ) in the inbox of the actor that created it. The TimerElapsedEvent contains as payload, the same TimerInfo returned during the timer creation. If you create multiple timers, then the TimerInfo object can be used to distinguish the sources of the different TimerElapsedEvent events. You can start a periodic timer using the function StartPeriodicTimer . TimerInfo StartPeriodicTimer(TimeSpan startDelay, TimeSpan period, TimerElapsedEvent customEvent) StartPeriodicTimer takes as argument: 1. TimeSpan startDelay , which is the amount of time to wait before sending the first timeout event. 2. TimeSpan period , which is the time interval between timeout events. 3. TimerElapsedEvent customEvent , an optional custom event (of a user-specified subclass of TimerElapsedEvent ) to raise instead of the default TimerElapsedEvent . Periodic timers work similarly to normal timers, however you need to manually stop a periodic timer using the StopTimer method if you want it to stop sending TimerElapsedEvent events. Note that when an actor halts , it automatically stops and disposes all its periodic and non-periodic timers. A sample which demonstrates the use of such timers is provided in the Timers Sample on github, which is explained in detail below. First you need to declare on your Actor that it is expecting to receive the TimerElapsedEvent so the class is defined like this: [OnEventDoAction(typeof(TimerElapsedEvent), nameof(HandleTimeout))] internal class Client : Actor { ... } To kick things off the initialization method starts a non-periodic timer: protected override Task OnInitializeAsync(Event initialEvent) { Console.WriteLine(\"<Client> Starting a non-periodic timer\"); this.StartTimer(TimeSpan.FromSeconds(1)); return base.OnInitializeAsync(initialEvent); } The HandleTimeout method then receives this timeout and starts a periodic timer as follows: private void HandleTimeout(Event e) { TimerElapsedEvent te = (TimerElapsedEvent)e; this.WriteMessage(\"<Client> Handling timeout from timer\"); this.WriteMessage(\"<Client> Starting a period timer\"); this.PeriodicTimer = this.StartPeriodicTimer(TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1), new CustomTimerEvent()); } In this case we use a CustomTimerEvent instead of the default TimerElapsedEvent , this custom event is defined as follows: internal class CustomTimerEvent : TimerElapsedEvent { /// <summary> /// Count of timeout events processed. /// </summary> internal int Count; } This custom event makes it possible to route the period timeouts to a different handler using this on the actor class: [OnEventDoAction(typeof(CustomTimerEvent), nameof(HandlePeriodicTimeout))] In the HandlePeriodicTimeout method we count the number of timeouts and stop when we reach 3: private void HandlePeriodicTimeout(Event e) { this.WriteMessage(\"<Client> Handling timeout from periodic timer\"); if (e is CustomTimerEvent ce) { ce.Count++; if (ce.Count == 3) { this.WriteMessage(\"<Client> Stopping the periodic timer\"); this.StopTimer(this.PeriodicTimer); } } } Notice how we can cast the Event into our custom CustomTimerEvent , and we get the same instance of CustomTimerEvent on each period call, so this way the CustomTimerEvent can contain useful state, in this case the Count . The output of this program is as follows: <Client> Starting a non-periodic timer <Client> Handling timeout from timer <Client> Starting a period timer <Client> Handling timeout from periodic timer <Client> Handling timeout from periodic timer <Client> Handling timeout from periodic timer <Client> Stopping the periodic timer Implementation notes Note that timers are implemented differently depending on what mode your program is running in. Normal \u201cproduction\u201d mode execution uses an optimized timer built on System.Threading.Timer . Timers that run during systematic testing, however, are quite different and are implemented in a MockTimerActor class. This mock actually removes all concept of real time intervals, and replaces that with a random decision to timeout or not to timeout. This makes your test run much faster. But it can also make your test see a lot more timeout events that you may be expecting. This is good for finding bugs, but can overwhelm the test with timeout events. To reduce the number of timeouts there is a --timeout-delay command line option on the coyote test tool. This timeout delay is given to the mock timer and it will only fire a timeout when RandomInteger(delay) == 0 . The default value of --timeout-delay is 10, which means timeouts only fire once every 10 times the timer gets scheduled by the systematic testing runtime. This turns out to be a pretty good default that stops your test from getting too overwhelmed by timeout events, but if you still see too many timeout events in your test logs, then you can increase this number.","title":"Using timers in actors"},{"location":"concepts/actors/timers/#using-timers-in-actors","text":"The Coyote actor programming model has built-in support for timers. Timers are themselves a type of Actor that send a TimerElapsedEvent upon timeout to the actor that created the timer. Timers are handy for modeling a common type of asynchronous behavior in distributed systems, so you can find more bugs in your code relating to how it deals with the uncertainty of various kinds of timeouts. Timers provide a once only timeout event or a periodic timeout, which can continually send such events on a user-defined interval until they are stopped. To make use of timers, you must include the Microsoft.Coyote.Actors.Timers namespace. You can start a non-periodic timer using the function StartTimer . TimerInfo StartTimer(TimeSpan startDelay, TimerElapsedEvent customEvent) StartTimer takes as argument: 1. TimeSpan startDelay , which is the amount of time to wait before sending the timeout event. 2. TimerElapsedEvent customEvent , an optional custom event (of a user-specified subclass of TimerElapsedEvent ) to raise instead of the default TimerElapsedEvent . StartTimer returns TimerInfo , which contains information about the created non-periodic timer. The non-periodic timer is automatically disposed after it timeouts. You can also pass the TimerInfo to the StopTimer method to manually stop and dispose the timer. The timer enqueues events of type TimerElapsedEvent (or of a user-specified subclass of TimerElapsedEvent ) in the inbox of the actor that created it. The TimerElapsedEvent contains as payload, the same TimerInfo returned during the timer creation. If you create multiple timers, then the TimerInfo object can be used to distinguish the sources of the different TimerElapsedEvent events. You can start a periodic timer using the function StartPeriodicTimer . TimerInfo StartPeriodicTimer(TimeSpan startDelay, TimeSpan period, TimerElapsedEvent customEvent) StartPeriodicTimer takes as argument: 1. TimeSpan startDelay , which is the amount of time to wait before sending the first timeout event. 2. TimeSpan period , which is the time interval between timeout events. 3. TimerElapsedEvent customEvent , an optional custom event (of a user-specified subclass of TimerElapsedEvent ) to raise instead of the default TimerElapsedEvent . Periodic timers work similarly to normal timers, however you need to manually stop a periodic timer using the StopTimer method if you want it to stop sending TimerElapsedEvent events. Note that when an actor halts , it automatically stops and disposes all its periodic and non-periodic timers. A sample which demonstrates the use of such timers is provided in the Timers Sample on github, which is explained in detail below. First you need to declare on your Actor that it is expecting to receive the TimerElapsedEvent so the class is defined like this: [OnEventDoAction(typeof(TimerElapsedEvent), nameof(HandleTimeout))] internal class Client : Actor { ... } To kick things off the initialization method starts a non-periodic timer: protected override Task OnInitializeAsync(Event initialEvent) { Console.WriteLine(\"<Client> Starting a non-periodic timer\"); this.StartTimer(TimeSpan.FromSeconds(1)); return base.OnInitializeAsync(initialEvent); } The HandleTimeout method then receives this timeout and starts a periodic timer as follows: private void HandleTimeout(Event e) { TimerElapsedEvent te = (TimerElapsedEvent)e; this.WriteMessage(\"<Client> Handling timeout from timer\"); this.WriteMessage(\"<Client> Starting a period timer\"); this.PeriodicTimer = this.StartPeriodicTimer(TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1), new CustomTimerEvent()); } In this case we use a CustomTimerEvent instead of the default TimerElapsedEvent , this custom event is defined as follows: internal class CustomTimerEvent : TimerElapsedEvent { /// <summary> /// Count of timeout events processed. /// </summary> internal int Count; } This custom event makes it possible to route the period timeouts to a different handler using this on the actor class: [OnEventDoAction(typeof(CustomTimerEvent), nameof(HandlePeriodicTimeout))] In the HandlePeriodicTimeout method we count the number of timeouts and stop when we reach 3: private void HandlePeriodicTimeout(Event e) { this.WriteMessage(\"<Client> Handling timeout from periodic timer\"); if (e is CustomTimerEvent ce) { ce.Count++; if (ce.Count == 3) { this.WriteMessage(\"<Client> Stopping the periodic timer\"); this.StopTimer(this.PeriodicTimer); } } } Notice how we can cast the Event into our custom CustomTimerEvent , and we get the same instance of CustomTimerEvent on each period call, so this way the CustomTimerEvent can contain useful state, in this case the Count . The output of this program is as follows: <Client> Starting a non-periodic timer <Client> Handling timeout from timer <Client> Starting a period timer <Client> Handling timeout from periodic timer <Client> Handling timeout from periodic timer <Client> Handling timeout from periodic timer <Client> Stopping the periodic timer","title":"Using timers in actors"},{"location":"concepts/actors/timers/#implementation-notes","text":"Note that timers are implemented differently depending on what mode your program is running in. Normal \u201cproduction\u201d mode execution uses an optimized timer built on System.Threading.Timer . Timers that run during systematic testing, however, are quite different and are implemented in a MockTimerActor class. This mock actually removes all concept of real time intervals, and replaces that with a random decision to timeout or not to timeout. This makes your test run much faster. But it can also make your test see a lot more timeout events that you may be expecting. This is good for finding bugs, but can overwhelm the test with timeout events. To reduce the number of timeouts there is a --timeout-delay command line option on the coyote test tool. This timeout delay is given to the mock timer and it will only fire a timeout when RandomInteger(delay) == 0 . The default value of --timeout-delay is 10, which means timeouts only fire once every 10 times the timer gets scheduled by the systematic testing runtime. This turns out to be a pretty good default that stops your test from getting too overwhelmed by timeout events, but if you still see too many timeout events in your test logs, then you can increase this number.","title":"Implementation notes"},{"location":"concepts/actors/uncaught-exceptions/","text":"Semantics of unhandled exceptions Coyote Actors can execute arbitrary C# code in their event handlers. This page discusses what happens if such code throws an exception that is not handled inside the action itself. As is usual in asynchronous programming , one should be careful with unhandled exceptions. In test mode (i.e., when running a test with coyote test ... ), all unhandled exceptions are an error and the test will fail. The coyote tester will stop the execution at that point and report an error. In production mode (i.e., when running a Coyote program outside of coyote test ), the Coyote runtime intercepts any unhandled exception in an actor. The exception is then delivered to the OnFailure delegate of the runtime. At this point, it is your responsibility to take the appropriate action. For instance, you can cause the program to crash and create a dump (for debugging later) as follows: runtime.OnFailure += delegate (Exception exception) { Environment.FailFast(exception.ToString(), exception); }; It is important that you induce a crash to stop the program, after perhaps taking some cleanup actions. If you don\u2019t do so, the runtime automatically enters a \u201cfailure\u201d mode. Actors may continue running their current action, but no additional work will take place. The runtime stops all Enqueue and Dequeue operations in the program. Thus, messages sent will not be delivered, and already-received messages will not be dequeued. If you wish to suppress an exception and have the rest of the program continue normal operation, then it is best to catch the exception in the action itself using a usual try { } catch { } block, or override the actor\u2019s OnException method to handle exceptions in one place. This override can return one of the following outcomes: // The outcome when an Microsoft.Coyote.Actors.Actor throws an exception. public enum OnExceptionOutcome { // The actor throws the exception causing the runtime to fail. ThrowException = 0, // The actor handles the exception and resumes execution. HandledException = 1, // The actor handles the exception and halts. Halt = 2 } Call Stack and debugging The runtime tries to call the OnFailure delegate with the stack intact. That is, if you launch a debugger from inside the OnFailure method, you will see the stack (with local variables) at the point the exception was thrown. However, this is not always the case. If the exception was thrown from an async action, then the stack may have gotten unwound even before the runtime gets to know of the exception (because of the way async continuations get compiled).","title":"Semantics of unhandled exceptions"},{"location":"concepts/actors/uncaught-exceptions/#semantics-of-unhandled-exceptions","text":"Coyote Actors can execute arbitrary C# code in their event handlers. This page discusses what happens if such code throws an exception that is not handled inside the action itself. As is usual in asynchronous programming , one should be careful with unhandled exceptions. In test mode (i.e., when running a test with coyote test ... ), all unhandled exceptions are an error and the test will fail. The coyote tester will stop the execution at that point and report an error. In production mode (i.e., when running a Coyote program outside of coyote test ), the Coyote runtime intercepts any unhandled exception in an actor. The exception is then delivered to the OnFailure delegate of the runtime. At this point, it is your responsibility to take the appropriate action. For instance, you can cause the program to crash and create a dump (for debugging later) as follows: runtime.OnFailure += delegate (Exception exception) { Environment.FailFast(exception.ToString(), exception); }; It is important that you induce a crash to stop the program, after perhaps taking some cleanup actions. If you don\u2019t do so, the runtime automatically enters a \u201cfailure\u201d mode. Actors may continue running their current action, but no additional work will take place. The runtime stops all Enqueue and Dequeue operations in the program. Thus, messages sent will not be delivered, and already-received messages will not be dequeued. If you wish to suppress an exception and have the rest of the program continue normal operation, then it is best to catch the exception in the action itself using a usual try { } catch { } block, or override the actor\u2019s OnException method to handle exceptions in one place. This override can return one of the following outcomes: // The outcome when an Microsoft.Coyote.Actors.Actor throws an exception. public enum OnExceptionOutcome { // The actor throws the exception causing the runtime to fail. ThrowException = 0, // The actor handles the exception and resumes execution. HandledException = 1, // The actor handles the exception and halts. Halt = 2 }","title":"Semantics of unhandled exceptions"},{"location":"concepts/actors/uncaught-exceptions/#call-stack-and-debugging","text":"The runtime tries to call the OnFailure delegate with the stack intact. That is, if you launch a debugger from inside the OnFailure method, you will see the stack (with local variables) at the point the exception was thrown. However, this is not always the case. If the exception was thrown from an async action, then the stack may have gotten unwound even before the runtime gets to know of the exception (because of the way async continuations get compiled).","title":"Call Stack and debugging"},{"location":"concepts/actors/why-actors/","text":"How are Coyote Actors different from existing Microsoft Actor frameworks? As you build highly concurrent systems, designed to defending against race conditions, arbitrary faults, etc, how do you test such systems? How do you know that you got the code right? These questions were the motivation behind creating Coyote. Coyote focuses on writing specifications and providing high-coverage testing via systematic testing . The capability of writing better tests, getting (much) better coverage, accelerates the development process. How is it different from other actor implementations? Coyote does not have a distributed runtime, so it cannot be a replacement for systems like Orleans , dapr , Azure Service Fabric , or Reliable Actors , each of which provide distributed hosting goodies such as state persistence, networking, load-balancing, etc. Coyote embodies its ideas in programming models such as actors and tasks . Each of these only have in-memory representations. Think of them in the same way as C# Tasks: they\u2019re just programming constructs. Coyote is complimentary to these other frameworks. Some Azure teams, for instance, use Service Fabric for hosting their application and Coyote for expressing the logic. There have also been instances where Reliable Actors were used, and each Reliable actor hosted a Coyote StateMachine inside. (The ReliableActor would receive messages and use them to drive the state machine.) Coyote testing vets correctness, and Service Fabric provides all the hosting capabilities. Coyote has minimal dependencies, so it should be easy to integrate. There is also a tutorial on how to use Coyote Actors to implement a Raft server cluster on top of Azure Service Bus. What scenarios to use Coyote as opposed to other systems? As mentioned above, using Coyote does not rule out the other systems. Use Coyote when there is complexity in your design and you\u2019re interested in high-coverage testing of your logic (against concurrency, failures, timers, race conditions, etc.) Coyote is not just for distributed systems. You can use it for single-box scenarios as well, e.g., asynchronous code using Tasks (running on a multi-core machine).","title":"Why Coyote actors?"},{"location":"concepts/actors/why-actors/#how-are-coyote-actors-different-from-existing-microsoft-actor-frameworks","text":"As you build highly concurrent systems, designed to defending against race conditions, arbitrary faults, etc, how do you test such systems? How do you know that you got the code right? These questions were the motivation behind creating Coyote. Coyote focuses on writing specifications and providing high-coverage testing via systematic testing . The capability of writing better tests, getting (much) better coverage, accelerates the development process.","title":"How are Coyote Actors different from existing Microsoft Actor frameworks?"},{"location":"concepts/actors/why-actors/#how-is-it-different-from-other-actor-implementations","text":"Coyote does not have a distributed runtime, so it cannot be a replacement for systems like Orleans , dapr , Azure Service Fabric , or Reliable Actors , each of which provide distributed hosting goodies such as state persistence, networking, load-balancing, etc. Coyote embodies its ideas in programming models such as actors and tasks . Each of these only have in-memory representations. Think of them in the same way as C# Tasks: they\u2019re just programming constructs. Coyote is complimentary to these other frameworks. Some Azure teams, for instance, use Service Fabric for hosting their application and Coyote for expressing the logic. There have also been instances where Reliable Actors were used, and each Reliable actor hosted a Coyote StateMachine inside. (The ReliableActor would receive messages and use them to drive the state machine.) Coyote testing vets correctness, and Service Fabric provides all the hosting capabilities. Coyote has minimal dependencies, so it should be easy to integrate. There is also a tutorial on how to use Coyote Actors to implement a Raft server cluster on top of Azure Service Bus.","title":"How is it different from other actor implementations?"},{"location":"concepts/actors/why-actors/#what-scenarios-to-use-coyote-as-opposed-to-other-systems","text":"As mentioned above, using Coyote does not rule out the other systems. Use Coyote when there is complexity in your design and you\u2019re interested in high-coverage testing of your logic (against concurrency, failures, timers, race conditions, etc.) Coyote is not just for distributed systems. You can use it for single-box scenarios as well, e.g., asynchronous code using Tasks (running on a multi-core machine).","title":"What scenarios to use Coyote as opposed to other systems?"},{"location":"concepts/tasks/async-lock/","text":"Controlled asynchronous lock The Coyote asynchronous tasks programming model provides an AsyncLock type that represents a non-reentrant mutual exclusion lock that can be acquired asynchronously in a FIFO order. During systematic testing, AsyncLock is controlled by coyote test to explore acquire/release interleavings and find concurrency bugs. Why is an asynchronous lock necessary? Although it is recommended that asynchronous code should be as lock-free as possible, in some scenarios it is still useful to serialize asynchronous access to a shared resource. Using the C# lock statement might not be an option as C# forbids the use of await inside the lock scope. This is because using await inside lock (which is implemented using System.Threading.Monitor APIs) can be prone to deadlocks due to its reentrancy semantics. The Coyote AsyncLock type does not have this limitation, and a controlled Task is free to await while holding an instance of this lock type. Awaiting on an AsyncLock also does not block the underlying thread allowing for a more efficient execution. Note that the C# lock statement is still supported by coyote test . However\u2014besides not using await in the body of lock \u2014you should also make sure to not call any Coyote API that can introduce a scheduling decision during systematic testing (such as Task.Run , Task.Delay or Task.Yield ), while holding a lock , as this can lead to deadlocks. How do you use it? You create an instance of an AsyncLock by calling the static method AsyncLock.Create() . The only instance-level method that AsyncLock provides is AcquireAsync() . This method tries to acquire the lock asynchronously, and returns a task that completes when the lock has been acquired. The returned task\u2019s result is of type AsyncLock.Releaser . This Releaser implements the IDisposable interface. It releases the lock when disposed. Note that AcquireAsync() is not a reentrant operation. AsyncLock exposes the IsAcquired boolean property, which is true if the lock has been acquired, else false. Finally, when the AsyncLock is acquired, your code can enter the scope of this lock and perform synchronized operations. As the Releaser implements IDisposable , this makes it possible (and convenient) to put the synchronized code inside a using statement. This ensures the AsyncLock is released when exiting the body of using in a way that is also exception safe. During systematic testing, coyote test injects scheduling points upon acquiring or releasing the lock, which allows it to explore interleavings and expose bugs (including deadlocks). Example usage The code below demonstrates AsyncLock in action: using Microsoft.Coyote.Tasks; public class LockExample { private int Value = 0; private bool IsRunning = false; private readonly AsyncLock Mutex = AsyncLock.Create(); public async Task FirstOperationAsync() { using (await this.Mutex.AcquireAsync()) { if (!this.IsRunning) { this.IsRunning = true; this.Value = 5; } } } public async Task SecondOperationAsync(bool reenter) { using (await this.Mutex.AcquireAsync()) { if (this.IsRunning) { this.IsRunning = false; this.Value = 0; } if (reenter) { // This causes a deadlock ... so don't do this! await this.SecondOperationAsync(reenter); } } } } In the above example, the FirstOperationAsync and SecondOperationAsync methods use an AsyncLock to avoid a race condition while testing and updating IsRunning and Value . You can write a test for this code as follows: using Microsoft.Coyote.Tasks; public static class Program { public static async System.Threading.Tasks.Task Main() { await RunTestAsync(); } [Microsoft.Coyote.SystematicTesting.Test] public static async Task RunTestAsync() { bool reenter = false; LockExample test = new LockExample(); for (int i = 0; i < 100; i++) { var task1 = test.FirstOperationAsync(); var task2 = test.SecondOperationAsync(reenter); await Task.WhenAll(task1, task2); } Console.WriteLine(\"Done testing.\"); } } When you run this test in the command line (by running the executable on its own, without coyote test ), then it normally finishes with the following output: Done testing. Next, change bool reenter = false; to true , build and run the test again (without coyote test ). This time execution is hanging forever and needs to be killed by pressing Ctrl-C. So, what happened? As you see from the code above, the SecondOperationAsync can invoke itself while holding AsyncLock when reenter is true. This results in a deadlock. Now, try to run the test with coyote test . Instead of hanging, coyote test will quickly detect a deadlock: Error: Deadlock detected. Task(0) is waiting to acquire a resource that is already acquired, but no other controlled tasks are enabled.","title":"Async lock"},{"location":"concepts/tasks/async-lock/#controlled-asynchronous-lock","text":"The Coyote asynchronous tasks programming model provides an AsyncLock type that represents a non-reentrant mutual exclusion lock that can be acquired asynchronously in a FIFO order. During systematic testing, AsyncLock is controlled by coyote test to explore acquire/release interleavings and find concurrency bugs.","title":"Controlled asynchronous lock"},{"location":"concepts/tasks/async-lock/#why-is-an-asynchronous-lock-necessary","text":"Although it is recommended that asynchronous code should be as lock-free as possible, in some scenarios it is still useful to serialize asynchronous access to a shared resource. Using the C# lock statement might not be an option as C# forbids the use of await inside the lock scope. This is because using await inside lock (which is implemented using System.Threading.Monitor APIs) can be prone to deadlocks due to its reentrancy semantics. The Coyote AsyncLock type does not have this limitation, and a controlled Task is free to await while holding an instance of this lock type. Awaiting on an AsyncLock also does not block the underlying thread allowing for a more efficient execution. Note that the C# lock statement is still supported by coyote test . However\u2014besides not using await in the body of lock \u2014you should also make sure to not call any Coyote API that can introduce a scheduling decision during systematic testing (such as Task.Run , Task.Delay or Task.Yield ), while holding a lock , as this can lead to deadlocks.","title":"Why is an asynchronous lock necessary?"},{"location":"concepts/tasks/async-lock/#how-do-you-use-it","text":"You create an instance of an AsyncLock by calling the static method AsyncLock.Create() . The only instance-level method that AsyncLock provides is AcquireAsync() . This method tries to acquire the lock asynchronously, and returns a task that completes when the lock has been acquired. The returned task\u2019s result is of type AsyncLock.Releaser . This Releaser implements the IDisposable interface. It releases the lock when disposed. Note that AcquireAsync() is not a reentrant operation. AsyncLock exposes the IsAcquired boolean property, which is true if the lock has been acquired, else false. Finally, when the AsyncLock is acquired, your code can enter the scope of this lock and perform synchronized operations. As the Releaser implements IDisposable , this makes it possible (and convenient) to put the synchronized code inside a using statement. This ensures the AsyncLock is released when exiting the body of using in a way that is also exception safe. During systematic testing, coyote test injects scheduling points upon acquiring or releasing the lock, which allows it to explore interleavings and expose bugs (including deadlocks).","title":"How do you use it?"},{"location":"concepts/tasks/async-lock/#example-usage","text":"The code below demonstrates AsyncLock in action: using Microsoft.Coyote.Tasks; public class LockExample { private int Value = 0; private bool IsRunning = false; private readonly AsyncLock Mutex = AsyncLock.Create(); public async Task FirstOperationAsync() { using (await this.Mutex.AcquireAsync()) { if (!this.IsRunning) { this.IsRunning = true; this.Value = 5; } } } public async Task SecondOperationAsync(bool reenter) { using (await this.Mutex.AcquireAsync()) { if (this.IsRunning) { this.IsRunning = false; this.Value = 0; } if (reenter) { // This causes a deadlock ... so don't do this! await this.SecondOperationAsync(reenter); } } } } In the above example, the FirstOperationAsync and SecondOperationAsync methods use an AsyncLock to avoid a race condition while testing and updating IsRunning and Value . You can write a test for this code as follows: using Microsoft.Coyote.Tasks; public static class Program { public static async System.Threading.Tasks.Task Main() { await RunTestAsync(); } [Microsoft.Coyote.SystematicTesting.Test] public static async Task RunTestAsync() { bool reenter = false; LockExample test = new LockExample(); for (int i = 0; i < 100; i++) { var task1 = test.FirstOperationAsync(); var task2 = test.SecondOperationAsync(reenter); await Task.WhenAll(task1, task2); } Console.WriteLine(\"Done testing.\"); } } When you run this test in the command line (by running the executable on its own, without coyote test ), then it normally finishes with the following output: Done testing. Next, change bool reenter = false; to true , build and run the test again (without coyote test ). This time execution is hanging forever and needs to be killed by pressing Ctrl-C. So, what happened? As you see from the code above, the SecondOperationAsync can invoke itself while holding AsyncLock when reenter is true. This results in a deadlock. Now, try to run the test with coyote test . Instead of hanging, coyote test will quickly detect a deadlock: Error: Deadlock detected. Task(0) is waiting to acquire a resource that is already acquired, but no other controlled tasks are enabled.","title":"Example usage"},{"location":"concepts/tasks/overview/","text":"Programming model: asynchronous tasks The asynchronous tasks programming model of Coyote is based on the task-based asynchronous pattern . Coyote provides a drop in replacement for the native .NET Task type that works with the async and await C# keywords . To avoid confusion we will use the following terminology: Short Name Fully Qualified Name native Task System.Threading.Tasks.Task controlled Task Microsoft.Coyote.Tasks.Task A controlled Task is similar to a native Task type and can be used alongside the native Task type to easily invoke external asynchronous APIs from your code. We will discuss this in more detail below. The benefit of using the controlled Task is that the Coyote runtime takes control of its execution and scheduling during systematic testing, enabling coyote test to explore various interleavings between controlled Task objects. In production, a controlled Task executes efficiently, as it a simple wrapper over a native Task , with operations being pass-through (Coyote takes control only during testing). Overview The core of the Coyote asynchronous tasks programming model is the controlled Task and Task<T> objects, which model asynchronous operations. They are supported by the async and await keywords. This programming model is fairly simple in most cases: - For I/O-bound code, you await an operation which returns a controlled Task or Task<T> inside of an async method. - For CPU-bound code, you await an operation which is started on a background thread with the Task.Run method. In more detail, a controlled Task is a construct used to implement what is known as the promise model of concurrency . A controlled Task basically offers you a promise that work will be completed at a later point, letting you coordinate with this promise using async and await . A controlled Task represents a single operation which does not return a value. A controlled Task<T> represents a single operation which returns a value of type T . It is important to reason about tasks as abstractions of work happening asynchronously, and not an abstraction over threading. By default, a controlled Task executes (using a Task ) on the current thread and delegates work to the operating system, as appropriate. Optionally, a controlled Task can be explicitly requested to run on a separate thread via the Task.Run API. The await keyword is where the magic happens. Using await yields control to the caller of the method that performed await , allowing your program to be responsive or a service to be elastic, since it can now perform useful work while a controlled Task is running on the background. Your code does not need to rely on callbacks or events to continue execution after the task has been completed. The C# language does that for you. If you\u2019re using controlled Task<T> , the await keyword will additionally unwrap the value returned when the controlled Task is complete. The details of how await works are further explained in the C# docs . During testing, using await allows the Coyote runtime to automatically inject scheduling points and thoroughly explore asynchronous interleavings to find concurrency bugs. You can choose to use the Microsoft.Coyote.Tasks.Task directly in your programs or you can use the automatic rewriting feature which will rewrite your compiled binaries that use System.Threading.Tasks.Task and inject the required Coyote controls so you can run coyote test on the rewritten binaries. What happens under the covers The C# compiler transforms an async method into a state machine (literally called IAsyncStateMachine) which keeps track of things like yielding execution when an await is reached and resuming execution when a background job has finished. The controlled Task type uses a C# 7 feature known as async task types (see here ) that allows framework developers to create custom task types that can be used with async and await . This is where the magic happens. In production, controlled Task enables C# to build a custom asynchronous state machine that uses regular Task objects. However, during testing, Coyote uses dependency injection to supply a custom asynchronous state machine that allows controlling the scheduling of controlled Task objects, and thus systematically exploring their interleavings. How to use asynchronous tasks We will now show how to write a program using the Coyote asynchronous task programming model. As mentioned before, the controlled Task type is a drop-in replacement for the Task type, and thus any prior experience writing asynchronous code using async and await is useful and relevant. If you are not already familiar with async and await , you can learn more in the C# docs . Say that you have the following simple C# program: // Use the Coyote controlled task type. using Microsoft.Coyote.Tasks; using Microsoft.Coyote.Specifications; public class Program { public int Value = 0; public async Task WriteWithDelayAsync(int value) { await Task.Delay(100); this.Value = value; } public async Task RunAsync() { Task task1 = WriteWithDelayAsync(3); Task task2 = WriteWithDelayAsync(5); await Task.WhenAll(task1, task2); Specification.Assert(this.Value == 5, \"Value is '{0}' instead of 5.\", this.Value); } } The above program contains a int Value that is updated by the WriteWithDelayAsync method. This is a C# async method that asynchronously waits for a controlled Task to complete after 100 ms (created via the Task.Delay(100) call), and then modifies the Value field. The asynchronous RunAsync method twice invokes the WriteWithDelayAsync method by passing the values 3 and 5 respectively. Each method call returns a controlled Task object, which can be awaited using await . The RunAsync method first invokes the two asynchronous method calls and then calls Task.WhenAll(...) to await on the completion of both tasks. Because WriteWithDelayAsync method awaits a Task.Delay to complete, it will yield control to the caller of the method, which is the RunAsync method. However, the RunAsync method is not awaiting immediately upon invoking the WriteWithDelayAsync method calls. This means that the two calls can happen asynchronously , and thus the resulting Value can be either 3 or 5 after Task.WhenAll(...) completes. Using Specification.Assert , Coyote allows you to write assertions that check these kinds of safety properties. In this case, the assertion will check if the Value is 5 or not, and if not it will throw an exception, or report an error together with a reproducible trace during testing. What about System.Collections.Concurrent? Yes, you can use the .NET thread safe collections to share information across tasks, but not the BlockingCollection as this can block and Coyote will not know about that which will lead to deadlocks during testing. The other thread safe collections do not have uncontrolled non-determinism, either from Task.Run, or from retry loops, timers or waits. The caveat is that Coyote has not instrumented the .NET concurrent collections, and so coyote does not systematically explore thread switching in the middle of these operations, therefore Coyote will not always find all data race conditions related to concurrent access on these collections. For example, two tasks calling TryAdd with the same key, one task will succeed the other will not, but Coyote will not systematically explore all possible orderings around this operation. You can help Coyote do better by using ExploreContextSwitch . Samples To try out more samples that show how to use Coyote to systematically test task-based programs see the following: Account manager Bounded buffer Coffee machine failover","title":"Overview"},{"location":"concepts/tasks/overview/#programming-model-asynchronous-tasks","text":"The asynchronous tasks programming model of Coyote is based on the task-based asynchronous pattern . Coyote provides a drop in replacement for the native .NET Task type that works with the async and await C# keywords . To avoid confusion we will use the following terminology: Short Name Fully Qualified Name native Task System.Threading.Tasks.Task controlled Task Microsoft.Coyote.Tasks.Task A controlled Task is similar to a native Task type and can be used alongside the native Task type to easily invoke external asynchronous APIs from your code. We will discuss this in more detail below. The benefit of using the controlled Task is that the Coyote runtime takes control of its execution and scheduling during systematic testing, enabling coyote test to explore various interleavings between controlled Task objects. In production, a controlled Task executes efficiently, as it a simple wrapper over a native Task , with operations being pass-through (Coyote takes control only during testing).","title":"Programming model: asynchronous tasks"},{"location":"concepts/tasks/overview/#overview","text":"The core of the Coyote asynchronous tasks programming model is the controlled Task and Task<T> objects, which model asynchronous operations. They are supported by the async and await keywords. This programming model is fairly simple in most cases: - For I/O-bound code, you await an operation which returns a controlled Task or Task<T> inside of an async method. - For CPU-bound code, you await an operation which is started on a background thread with the Task.Run method. In more detail, a controlled Task is a construct used to implement what is known as the promise model of concurrency . A controlled Task basically offers you a promise that work will be completed at a later point, letting you coordinate with this promise using async and await . A controlled Task represents a single operation which does not return a value. A controlled Task<T> represents a single operation which returns a value of type T . It is important to reason about tasks as abstractions of work happening asynchronously, and not an abstraction over threading. By default, a controlled Task executes (using a Task ) on the current thread and delegates work to the operating system, as appropriate. Optionally, a controlled Task can be explicitly requested to run on a separate thread via the Task.Run API. The await keyword is where the magic happens. Using await yields control to the caller of the method that performed await , allowing your program to be responsive or a service to be elastic, since it can now perform useful work while a controlled Task is running on the background. Your code does not need to rely on callbacks or events to continue execution after the task has been completed. The C# language does that for you. If you\u2019re using controlled Task<T> , the await keyword will additionally unwrap the value returned when the controlled Task is complete. The details of how await works are further explained in the C# docs . During testing, using await allows the Coyote runtime to automatically inject scheduling points and thoroughly explore asynchronous interleavings to find concurrency bugs. You can choose to use the Microsoft.Coyote.Tasks.Task directly in your programs or you can use the automatic rewriting feature which will rewrite your compiled binaries that use System.Threading.Tasks.Task and inject the required Coyote controls so you can run coyote test on the rewritten binaries.","title":"Overview"},{"location":"concepts/tasks/overview/#what-happens-under-the-covers","text":"The C# compiler transforms an async method into a state machine (literally called IAsyncStateMachine) which keeps track of things like yielding execution when an await is reached and resuming execution when a background job has finished. The controlled Task type uses a C# 7 feature known as async task types (see here ) that allows framework developers to create custom task types that can be used with async and await . This is where the magic happens. In production, controlled Task enables C# to build a custom asynchronous state machine that uses regular Task objects. However, during testing, Coyote uses dependency injection to supply a custom asynchronous state machine that allows controlling the scheduling of controlled Task objects, and thus systematically exploring their interleavings.","title":"What happens under the covers"},{"location":"concepts/tasks/overview/#how-to-use-asynchronous-tasks","text":"We will now show how to write a program using the Coyote asynchronous task programming model. As mentioned before, the controlled Task type is a drop-in replacement for the Task type, and thus any prior experience writing asynchronous code using async and await is useful and relevant. If you are not already familiar with async and await , you can learn more in the C# docs . Say that you have the following simple C# program: // Use the Coyote controlled task type. using Microsoft.Coyote.Tasks; using Microsoft.Coyote.Specifications; public class Program { public int Value = 0; public async Task WriteWithDelayAsync(int value) { await Task.Delay(100); this.Value = value; } public async Task RunAsync() { Task task1 = WriteWithDelayAsync(3); Task task2 = WriteWithDelayAsync(5); await Task.WhenAll(task1, task2); Specification.Assert(this.Value == 5, \"Value is '{0}' instead of 5.\", this.Value); } } The above program contains a int Value that is updated by the WriteWithDelayAsync method. This is a C# async method that asynchronously waits for a controlled Task to complete after 100 ms (created via the Task.Delay(100) call), and then modifies the Value field. The asynchronous RunAsync method twice invokes the WriteWithDelayAsync method by passing the values 3 and 5 respectively. Each method call returns a controlled Task object, which can be awaited using await . The RunAsync method first invokes the two asynchronous method calls and then calls Task.WhenAll(...) to await on the completion of both tasks. Because WriteWithDelayAsync method awaits a Task.Delay to complete, it will yield control to the caller of the method, which is the RunAsync method. However, the RunAsync method is not awaiting immediately upon invoking the WriteWithDelayAsync method calls. This means that the two calls can happen asynchronously , and thus the resulting Value can be either 3 or 5 after Task.WhenAll(...) completes. Using Specification.Assert , Coyote allows you to write assertions that check these kinds of safety properties. In this case, the assertion will check if the Value is 5 or not, and if not it will throw an exception, or report an error together with a reproducible trace during testing.","title":"How to use asynchronous tasks"},{"location":"concepts/tasks/overview/#what-about-systemcollectionsconcurrent","text":"Yes, you can use the .NET thread safe collections to share information across tasks, but not the BlockingCollection as this can block and Coyote will not know about that which will lead to deadlocks during testing. The other thread safe collections do not have uncontrolled non-determinism, either from Task.Run, or from retry loops, timers or waits. The caveat is that Coyote has not instrumented the .NET concurrent collections, and so coyote does not systematically explore thread switching in the middle of these operations, therefore Coyote will not always find all data race conditions related to concurrent access on these collections. For example, two tasks calling TryAdd with the same key, one task will succeed the other will not, but Coyote will not systematically explore all possible orderings around this operation. You can help Coyote do better by using ExploreContextSwitch .","title":"What about System.Collections.Concurrent?"},{"location":"concepts/tasks/overview/#samples","text":"To try out more samples that show how to use Coyote to systematically test task-based programs see the following: Account manager Bounded buffer Coffee machine failover","title":"Samples"},{"location":"concepts/tasks/semaphore/","text":"Controlled Semaphore The Coyote asynchronous tasks programming model provides a Semaphore type that limits the number of tasks that can access a resource. During testing, the semaphore is automatically replaced with a controlled mocked version so that Coyote can perform any desired scheduling and interleaving of asynchronous operations. Why is a semaphore necessary? A semaphore is used in scenarios where you have to limit the number of tasks that can use a resource simultaneously. There are two semaphore types provided in C#: Semaphore and SemaphoreSlim . However, you should not use these .NET semaphore types in a Coyote program because synchronization must be done via Coyote APIs. Using the controlled Semaphore type of Coyote allows coyote test to fully control the scheduling of asynchronous operations. How do you use it? You create an instance of a Semaphore by calling the static method Semaphore.Create(initialCount, maxCount) . This method requires you to specify two Int32 arguments: initialCount . The initial number of requests for the semaphore that can be granted concurrently. maxCount . The maximum number of requests for the semaphore that can be granted concurrently. The following relation should hold between the values of these arguments: 0 <= initialCount <= maxCount && maxCount > 0 If this is violated, Semaphore.Create(initialCount, maxCount) throws an exception in production mode or reports a test bug when run under coyote test. You can enter the so created semaphore by executing either of its void Wait() or Task WaitAsync() methods: The Wait() method blocks the task until it can enter the Semaphore . The WaitAsync() method returns a task that will complete when the semaphore has been entered. The CurrentCount property has as its value the current count of requests that can be granted. The Release() method. When you are done with handling the resource, you must exit the semaphore by invoking this method. Not releasing the granted access and staying inside the semaphore forever is a bug in your code that limits the capacity of the semaphore and if this bug happens repeatedly with other tasks, can lead to the semaphore getting full and permanently unavailable for use. Another possible error is to perform a Release() more times than the maxCount of a semaphore. This results in an exception (in production mode) and in a test bug when testing with Coyote. The Dispose() method. A Semaphore implements the IDisposable interface. Finally, when your code no longer needs the semaphore object you should dispose it using this method. Then it is a good practice to dispose of this Semaphore object, invoking this method. Example usage The code below demonstrates Semaphore in action: ```csharp using Microsoft.Coyote.Tasks; public class SemaphoreExample { private readonly Semaphore TheSemaphore; private int ProtectedValue = 0; private readonly int MaxCount; public SemaphoreExample(int initialCurrentCount, int maxCount) { this.MaxCount = maxCount; this.TheSemaphore = Semaphore.Create(initialCurrentCount, maxCount); } public async Task RunTask(string taskName, int sleepMilliseconds, int newValue) { this.WriteLine($\"{taskName}: About to enter the semaphore. TheSemaphore.CurrentCount: {this.TheSemaphore.CurrentCount}\"); await this.TheSemaphore.WaitAsync(); this.WriteLine($\"{taskName}: Entered the semaphore. TheSemaphore.CurrentCount: {this.TheSemaphore.CurrentCount}\"); await Task.Delay(sleepMilliseconds); this.ProtectedValue = newValue; this.WriteLine($\"{taskName}: Waited {sleepMilliseconds}ms. Now exiting the semaphore. TheSemaphore.CurrentCount: {this.TheSemaphore.CurrentCount}\"); this.TheSemaphore.Release(); this.WriteLine($\"{taskName}: Exited the semaphore. TheSemaphore.CurrentCount: {this.TheSemaphore.CurrentCount}\"); this.WriteLine($\"{taskName}: this.ProtectedValue: {this.ProtectedValue}\"); this.WriteLine(\"=====================================================================\\n\"); } public async Task RunTask2(string taskName) { var semaphoreCount = this.TheSemaphore.CurrentCount; Console.WriteLine($\"{taskName} starting. TheSemaphore.CurrentCount: {semaphoreCount}\"); for (var i = 1; i <= semaphoreCount + 1; i++) { Console.WriteLine($\"{taskName}: ({i}) Entering the semaphore. TheSemaphore.CurrentCount: {this.TheSemaphore.CurrentCount}\"); await this.TheSemaphore.WaitAsync(); } } private void WriteLine(string msg) { string indent = new string(' ', (this.MaxCount - this.TheSemaphore.CurrentCount) * 2); Console.Write(indent); Console.WriteLine(msg); } } ``` In the above example, the RunTask and RunTask2 methods use a Semaphore that allows only maxCount tasks to perform simultaneously inside the semaphore. The code below implements 2 test scenarios, and in the first of them invokes RunTask() to create 3 different tasks using the semaphore, specifying for the semaphore initialCount = 2, and maxCount = 2. using Microsoft.Coyote.Tasks; public static class Program { public static int Scenario = 1; public static void Main() { RunTest(); } [Microsoft.Coyote.SystematicTesting.Test] public static void RunTest() { switch (Scenario) { case 1: SemaphoreExample test1 = new SemaphoreExample(2, 2); var task1 = test1.RunTask(\"Task1\", 500, 1); var task2 = test1.RunTask(\"Task2\", 1000, 2); var task3 = test1.RunTask(\"Task3\", 1000, 3); Task.WaitAll(task1, task2, task3); Console.WriteLine(\"test complete\"); break; case 2: SemaphoreExample test2 = new SemaphoreExample(2, 2); var task4 = test2.RunTask2(\"Task4\"); Task.WaitAny(task4); break; } } } In the first scenario ( Scenario == 1 ) the method RunTask() is invoked 3 times and creates 3 tasks that run asynchronously, then the code awaits the completion of all three tasks. The first two tasks enter the semaphore and fill its capacity completely as its maxCount is 2. Inside the semaphore, task1 awaits for 500 milliseconds, then sets this.ProtectedValue = 1 and releases (exits) the semaphore. task2 is also inside the semaphore with task1 but it waits for 1000 milliseconds, thus it has to wait about 500 milliseconds more after task1 exits the semaphore. Exactly when task1 exits the semaphore, its current count is increased from 0 to 1 and this allows the third task, task3 waiting for semaphore to be granted access. Having entered the semaphore, task3 waits for 1000 milliseconds. The other occupant of the semaphore ( task2 ) needs to wait only about 500ms more, then it sets this.ProtectedValue = 2 and releases (exits) the semaphore. Thus for the remaining about 500 milliseconds task3 is waiting as the sole occupant of the semaphore. Then it finally sets this.ProtectedValue = 3 and releases (exits) the semaphore. When you build and run the sample, the expected output is produced: Task1: About to enter the semaphore. TheSemaphore.CurrentCount: 2 Task1: Entered the semaphore. TheSemaphore.CurrentCount: 1 Task2: About to enter the semaphore. TheSemaphore.CurrentCount: 1 Task2: Entered the semaphore. TheSemaphore.CurrentCount: 0 Task3: About to enter the semaphore. TheSemaphore.CurrentCount: 0 Task1: Waited 500ms. Now exiting the semaphore. TheSemaphore.CurrentCount: 0 Task1: Exited the semaphore. TheSemaphore.CurrentCount: 0 Task1: this.ProtectedValue: 1 Task3: Entered the semaphore. TheSemaphore.CurrentCount: 0 ===================================================================== Task2: Waited 1000ms. Now exiting the semaphore. TheSemaphore.CurrentCount: 0 Task2: Exited the semaphore. TheSemaphore.CurrentCount: 1 Task2: this.ProtectedValue: 2 ===================================================================== Task3: Waited 1000ms. Now exiting the semaphore. TheSemaphore.CurrentCount: 1 Task3: Exited the semaphore. TheSemaphore.CurrentCount: 2 Task3: this.ProtectedValue: 3 ===================================================================== Now, run the example with coyote test . The testing completes normally, without finding any test bugs. You will get output from the coyote test tool, similar to this: ... Testing statistics: ..... Found 0 bugs. ... Scheduling statistics: ..... Explored 2000 schedules: 2000 fair and 0 unfair. In the second scenario ( Scenario == 2 ) a new SemaphoreExample instance is created with initialCurrentCount and maxCount having the same value 2. Then a single method ( RunTask2 ) is invoked and the task it returns is awaited upon. Remarkably, the code of this task tries to enter the semaphore more times than its CurrentCount and this must end abnormally. In the sample, change this line: public static int Scenario = 1; to: public static int Scenario = 2; Then build and run. The execution hangs, you have to kill the program with Ctrl-C, and you see this output: Task4 starting. TheSemaphore.CurrentCount: 2 Task4: (1) Entering the semaphore. TheSemaphore.CurrentCount: 2 Task4: (2) Entering the semaphore. TheSemaphore.CurrentCount: 1 Task4: (3) Entering the semaphore. TheSemaphore.CurrentCount: 0 Now, run the sample with coyote test . This time there is no hanging and Coyote quickly finds and reports a test bug: ... Task 0 found a bug. ... Emitting task 0 traces: ..... Writing ...\\Semaphores_0_2.txt ..... Writing ...\\Semaphores_0_2.schedule ... Elapsed 0.1125501 sec. Looking into the error file Semaphores_0_2.txt reveals this error message: <ErrorLog> Deadlock detected. Task(0) is waiting to acquire a resource that is already acquired, but no other controlled tasks are enabled.","title":"Semaphore"},{"location":"concepts/tasks/semaphore/#controlled-semaphore","text":"The Coyote asynchronous tasks programming model provides a Semaphore type that limits the number of tasks that can access a resource. During testing, the semaphore is automatically replaced with a controlled mocked version so that Coyote can perform any desired scheduling and interleaving of asynchronous operations.","title":"Controlled Semaphore"},{"location":"concepts/tasks/semaphore/#why-is-a-semaphore-necessary","text":"A semaphore is used in scenarios where you have to limit the number of tasks that can use a resource simultaneously. There are two semaphore types provided in C#: Semaphore and SemaphoreSlim . However, you should not use these .NET semaphore types in a Coyote program because synchronization must be done via Coyote APIs. Using the controlled Semaphore type of Coyote allows coyote test to fully control the scheduling of asynchronous operations.","title":"Why is a semaphore necessary?"},{"location":"concepts/tasks/semaphore/#how-do-you-use-it","text":"You create an instance of a Semaphore by calling the static method Semaphore.Create(initialCount, maxCount) . This method requires you to specify two Int32 arguments: initialCount . The initial number of requests for the semaphore that can be granted concurrently. maxCount . The maximum number of requests for the semaphore that can be granted concurrently. The following relation should hold between the values of these arguments: 0 <= initialCount <= maxCount && maxCount > 0 If this is violated, Semaphore.Create(initialCount, maxCount) throws an exception in production mode or reports a test bug when run under coyote test. You can enter the so created semaphore by executing either of its void Wait() or Task WaitAsync() methods: The Wait() method blocks the task until it can enter the Semaphore . The WaitAsync() method returns a task that will complete when the semaphore has been entered. The CurrentCount property has as its value the current count of requests that can be granted. The Release() method. When you are done with handling the resource, you must exit the semaphore by invoking this method. Not releasing the granted access and staying inside the semaphore forever is a bug in your code that limits the capacity of the semaphore and if this bug happens repeatedly with other tasks, can lead to the semaphore getting full and permanently unavailable for use. Another possible error is to perform a Release() more times than the maxCount of a semaphore. This results in an exception (in production mode) and in a test bug when testing with Coyote. The Dispose() method. A Semaphore implements the IDisposable interface. Finally, when your code no longer needs the semaphore object you should dispose it using this method. Then it is a good practice to dispose of this Semaphore object, invoking this method.","title":"How do you use it?"},{"location":"concepts/tasks/semaphore/#example-usage","text":"The code below demonstrates Semaphore in action: ```csharp using Microsoft.Coyote.Tasks; public class SemaphoreExample { private readonly Semaphore TheSemaphore; private int ProtectedValue = 0; private readonly int MaxCount; public SemaphoreExample(int initialCurrentCount, int maxCount) { this.MaxCount = maxCount; this.TheSemaphore = Semaphore.Create(initialCurrentCount, maxCount); } public async Task RunTask(string taskName, int sleepMilliseconds, int newValue) { this.WriteLine($\"{taskName}: About to enter the semaphore. TheSemaphore.CurrentCount: {this.TheSemaphore.CurrentCount}\"); await this.TheSemaphore.WaitAsync(); this.WriteLine($\"{taskName}: Entered the semaphore. TheSemaphore.CurrentCount: {this.TheSemaphore.CurrentCount}\"); await Task.Delay(sleepMilliseconds); this.ProtectedValue = newValue; this.WriteLine($\"{taskName}: Waited {sleepMilliseconds}ms. Now exiting the semaphore. TheSemaphore.CurrentCount: {this.TheSemaphore.CurrentCount}\"); this.TheSemaphore.Release(); this.WriteLine($\"{taskName}: Exited the semaphore. TheSemaphore.CurrentCount: {this.TheSemaphore.CurrentCount}\"); this.WriteLine($\"{taskName}: this.ProtectedValue: {this.ProtectedValue}\"); this.WriteLine(\"=====================================================================\\n\"); } public async Task RunTask2(string taskName) { var semaphoreCount = this.TheSemaphore.CurrentCount; Console.WriteLine($\"{taskName} starting. TheSemaphore.CurrentCount: {semaphoreCount}\"); for (var i = 1; i <= semaphoreCount + 1; i++) { Console.WriteLine($\"{taskName}: ({i}) Entering the semaphore. TheSemaphore.CurrentCount: {this.TheSemaphore.CurrentCount}\"); await this.TheSemaphore.WaitAsync(); } } private void WriteLine(string msg) { string indent = new string(' ', (this.MaxCount - this.TheSemaphore.CurrentCount) * 2); Console.Write(indent); Console.WriteLine(msg); } } ``` In the above example, the RunTask and RunTask2 methods use a Semaphore that allows only maxCount tasks to perform simultaneously inside the semaphore. The code below implements 2 test scenarios, and in the first of them invokes RunTask() to create 3 different tasks using the semaphore, specifying for the semaphore initialCount = 2, and maxCount = 2. using Microsoft.Coyote.Tasks; public static class Program { public static int Scenario = 1; public static void Main() { RunTest(); } [Microsoft.Coyote.SystematicTesting.Test] public static void RunTest() { switch (Scenario) { case 1: SemaphoreExample test1 = new SemaphoreExample(2, 2); var task1 = test1.RunTask(\"Task1\", 500, 1); var task2 = test1.RunTask(\"Task2\", 1000, 2); var task3 = test1.RunTask(\"Task3\", 1000, 3); Task.WaitAll(task1, task2, task3); Console.WriteLine(\"test complete\"); break; case 2: SemaphoreExample test2 = new SemaphoreExample(2, 2); var task4 = test2.RunTask2(\"Task4\"); Task.WaitAny(task4); break; } } } In the first scenario ( Scenario == 1 ) the method RunTask() is invoked 3 times and creates 3 tasks that run asynchronously, then the code awaits the completion of all three tasks. The first two tasks enter the semaphore and fill its capacity completely as its maxCount is 2. Inside the semaphore, task1 awaits for 500 milliseconds, then sets this.ProtectedValue = 1 and releases (exits) the semaphore. task2 is also inside the semaphore with task1 but it waits for 1000 milliseconds, thus it has to wait about 500 milliseconds more after task1 exits the semaphore. Exactly when task1 exits the semaphore, its current count is increased from 0 to 1 and this allows the third task, task3 waiting for semaphore to be granted access. Having entered the semaphore, task3 waits for 1000 milliseconds. The other occupant of the semaphore ( task2 ) needs to wait only about 500ms more, then it sets this.ProtectedValue = 2 and releases (exits) the semaphore. Thus for the remaining about 500 milliseconds task3 is waiting as the sole occupant of the semaphore. Then it finally sets this.ProtectedValue = 3 and releases (exits) the semaphore. When you build and run the sample, the expected output is produced: Task1: About to enter the semaphore. TheSemaphore.CurrentCount: 2 Task1: Entered the semaphore. TheSemaphore.CurrentCount: 1 Task2: About to enter the semaphore. TheSemaphore.CurrentCount: 1 Task2: Entered the semaphore. TheSemaphore.CurrentCount: 0 Task3: About to enter the semaphore. TheSemaphore.CurrentCount: 0 Task1: Waited 500ms. Now exiting the semaphore. TheSemaphore.CurrentCount: 0 Task1: Exited the semaphore. TheSemaphore.CurrentCount: 0 Task1: this.ProtectedValue: 1 Task3: Entered the semaphore. TheSemaphore.CurrentCount: 0 ===================================================================== Task2: Waited 1000ms. Now exiting the semaphore. TheSemaphore.CurrentCount: 0 Task2: Exited the semaphore. TheSemaphore.CurrentCount: 1 Task2: this.ProtectedValue: 2 ===================================================================== Task3: Waited 1000ms. Now exiting the semaphore. TheSemaphore.CurrentCount: 1 Task3: Exited the semaphore. TheSemaphore.CurrentCount: 2 Task3: this.ProtectedValue: 3 ===================================================================== Now, run the example with coyote test . The testing completes normally, without finding any test bugs. You will get output from the coyote test tool, similar to this: ... Testing statistics: ..... Found 0 bugs. ... Scheduling statistics: ..... Explored 2000 schedules: 2000 fair and 0 unfair. In the second scenario ( Scenario == 2 ) a new SemaphoreExample instance is created with initialCurrentCount and maxCount having the same value 2. Then a single method ( RunTask2 ) is invoked and the task it returns is awaited upon. Remarkably, the code of this task tries to enter the semaphore more times than its CurrentCount and this must end abnormally. In the sample, change this line: public static int Scenario = 1; to: public static int Scenario = 2; Then build and run. The execution hangs, you have to kill the program with Ctrl-C, and you see this output: Task4 starting. TheSemaphore.CurrentCount: 2 Task4: (1) Entering the semaphore. TheSemaphore.CurrentCount: 2 Task4: (2) Entering the semaphore. TheSemaphore.CurrentCount: 1 Task4: (3) Entering the semaphore. TheSemaphore.CurrentCount: 0 Now, run the sample with coyote test . This time there is no hanging and Coyote quickly finds and reports a test bug: ... Task 0 found a bug. ... Emitting task 0 traces: ..... Writing ...\\Semaphores_0_2.txt ..... Writing ...\\Semaphores_0_2.schedule ... Elapsed 0.1125501 sec. Looking into the error file Semaphores_0_2.txt reveals this error message: <ErrorLog> Deadlock detected. Task(0) is waiting to acquire a resource that is already acquired, but no other controlled tasks are enabled.","title":"Example usage"},{"location":"concepts/tasks/synchronized-block/","text":"Controlled synchronized block The Coyote asynchronous tasks programming model provides a Microsoft.Coyote.Tasks.SynchronizedBlock type that can be used to synchronize multiple tasks around access to a shared resource. In production this construct is a thin wrapper on System.Threading.Monitor , and during testing, the SynchronizedBlock is automatically replaced with a controlled mocked version so that Coyote can explore the scheduling and interleaving of asynchronous operations that are synchronized this way. Why is a synchronized block necessary? C# provides a built in lock keyword that uses System.Threading.Monitor under the covers. This keyword is often used to protect local state from data race conditions like this: class Foo { int count; object syncObject = new object(); public int Increment() { lock(syncObject) { return ++count; } } } The ++operator is not atomic, and therefore it is not thread safe, so the lock statement ensures that it becomes an atomic operation and so now the Increment method can be safely used in parallel situations. For added convenience, this lock statement is also re-entrant, so your class can call another method that also enters the lock and this is fine. This makes it easier to manage code reuse within your class. The Monitor class also has a very useful feature in the Wait and Pulse and PulseAll methods that is hard to replace with anything else. In this case one task can Wait while it is inside the lock for another task to signal it using Pulse . The Wait call releases the lock so another task can get the lock and call Pulse , when the lock is released, the waiting task can proceed as it now has the lock. These primitives form the core of very useful \u201csynchronization\u201d logic. Note that it is very important to also point out that C# does not allow await keyword to be used inside a lock statement as this can lead to deadlocks. How do you use it? Coyote provides a drop in replacement for System.Threading.Monitor called Microsoft.Coyote.Tasks.SynchronizedBlock . To get Coyote test control over your synchronized blocks simply replace: lock (this.syncObject) with: using (var monitor = SynchronizedBlock.Lock(this.syncObject)) and replace calls to System.Threading.Monitor.Wait and System.Threading.Monitor.Pulse with calls to the new variable monitor.Wait and monitor.Pulse instead. Then when you run your coyote test on this code you will get systematic testing of all interleavings around this lock. Note: you must also avoid using await on asynchronous tasks inside a SynchronizedBlock.Lock . If Coyote detects any task switching inside a synchronized block you will see an error message saying \u201cObject synchronization method was called from a task that did not create this SynchronizedBlock\u201d . Bugs involving System.Threading.Monitor can be extremely tricky to debug due to their heisenbug nature. Coyote testing eliminates this problem and can given you clear 100% reproducible bug schedules that you can replay as slowly as you need to see what is really going on leading up to such bugs. Sample For a complete example see the Extreme Programming meets systematic testing using Coyote and the associated BoundedBuffer example source code .","title":"Synchronized block"},{"location":"concepts/tasks/synchronized-block/#controlled-synchronized-block","text":"The Coyote asynchronous tasks programming model provides a Microsoft.Coyote.Tasks.SynchronizedBlock type that can be used to synchronize multiple tasks around access to a shared resource. In production this construct is a thin wrapper on System.Threading.Monitor , and during testing, the SynchronizedBlock is automatically replaced with a controlled mocked version so that Coyote can explore the scheduling and interleaving of asynchronous operations that are synchronized this way.","title":"Controlled synchronized block"},{"location":"concepts/tasks/synchronized-block/#why-is-a-synchronized-block-necessary","text":"C# provides a built in lock keyword that uses System.Threading.Monitor under the covers. This keyword is often used to protect local state from data race conditions like this: class Foo { int count; object syncObject = new object(); public int Increment() { lock(syncObject) { return ++count; } } } The ++operator is not atomic, and therefore it is not thread safe, so the lock statement ensures that it becomes an atomic operation and so now the Increment method can be safely used in parallel situations. For added convenience, this lock statement is also re-entrant, so your class can call another method that also enters the lock and this is fine. This makes it easier to manage code reuse within your class. The Monitor class also has a very useful feature in the Wait and Pulse and PulseAll methods that is hard to replace with anything else. In this case one task can Wait while it is inside the lock for another task to signal it using Pulse . The Wait call releases the lock so another task can get the lock and call Pulse , when the lock is released, the waiting task can proceed as it now has the lock. These primitives form the core of very useful \u201csynchronization\u201d logic. Note that it is very important to also point out that C# does not allow await keyword to be used inside a lock statement as this can lead to deadlocks.","title":"Why is a synchronized block necessary?"},{"location":"concepts/tasks/synchronized-block/#how-do-you-use-it","text":"Coyote provides a drop in replacement for System.Threading.Monitor called Microsoft.Coyote.Tasks.SynchronizedBlock . To get Coyote test control over your synchronized blocks simply replace: lock (this.syncObject) with: using (var monitor = SynchronizedBlock.Lock(this.syncObject)) and replace calls to System.Threading.Monitor.Wait and System.Threading.Monitor.Pulse with calls to the new variable monitor.Wait and monitor.Pulse instead. Then when you run your coyote test on this code you will get systematic testing of all interleavings around this lock. Note: you must also avoid using await on asynchronous tasks inside a SynchronizedBlock.Lock . If Coyote detects any task switching inside a synchronized block you will see an error message saying \u201cObject synchronization method was called from a task that did not create this SynchronizedBlock\u201d . Bugs involving System.Threading.Monitor can be extremely tricky to debug due to their heisenbug nature. Coyote testing eliminates this problem and can given you clear 100% reproducible bug schedules that you can replay as slowly as you need to see what is really going on leading up to such bugs.","title":"How do you use it?"},{"location":"concepts/tasks/synchronized-block/#sample","text":"For a complete example see the Extreme Programming meets systematic testing using Coyote and the associated BoundedBuffer example source code .","title":"Sample"},{"location":"concepts/tasks/tcs/","text":"Controlled task completion source The Coyote asynchronous tasks programming model provides a Microsoft.Coyote.Tasks.TaskCompletionSource<TResult> type that is controlled by coyote test during systematic testing to explore interleavings and find concurrency bugs. In production, this type is simply a thin wrapper over the native .NET System.Threading.Tasks.TaskCompletionSource<TResult> type, providing the same operational semantics that you are familiar with. Why is a task completion source necessary? In many asynchronous scenarios, it is useful to create a Task<TResult> and pass it to one or more consumers, which can then await for this task to complete to get its result. The controlled TaskCompletionSource<TResult> type of Coyote acts as the producer for such a Task<TResult> . The owner of the TaskCompletionSource<TResult> is able to control the state of the produced Task<TResult> and complete it by setting its result. You can learn more about the semantics of a task completion source in the .NET documentation of the native TaskCompletionSource<T> type . How do you use it? First, create a new controlled TaskCompletionSource<TResult> using the static method TaskCompletionSource.Create<TResult>() . Then, you can get the controlled Task<TResult> associated with this task completion source, using the TaskCompletionSource.Task property, and share it with one or more consumers. Finally, you can use the TaskCompletionSource to complete the produced Task<TResult> . You can do this using the methods of the controlled task completion source: SetResult() SetException() SetCanceled() , or their TrySet* variants: TrySetResult() TrySetException() TrySetCanceled() Why are there two sets of methods, namely, the Set* methods that return void and their TrySet* variants that return bool ? The reason is that the controlled Task<TResult> associated with the TaskCompletionSource<TResult> may only be completed once, thus attempting to set this task into a completed state when it\u2019s already in a completed state is an error, and the Set* methods will throw. However, as we\u2019re dealing with concurrency here, and there are some situations where races may be expected between multiple threads trying to resolve the completion source, the TrySet* variants return bool indicating success rather than throwing an exception. Example code The code below demonstrates a controlled TaskCompletionSource<TResult> in action. This represents the most typical scenario in which programmers need and use a task completion source, namely to know when a long-running operation, that itself is not awaitable, has finished. using Microsoft.Coyote.Tasks; public void StartLongOperation(TaskCompletionSource<bool> tcs) { Console.WriteLine(\"Producer: Running a long operation...\"); // ... do something that takes a long time. // This may include calling a 3rd party library that is not awaitable. Console.WriteLine(\"Producer: Completed the long operation.\"); tcs.SetResult(true); Console.WriteLine(\"Producer: Completed the task completion source.\"); } The above StartLongOperation method is responsible for running some long operation. Although the method is not awaitable, as it returns void , it can signal its completion by setting the result of the controlled TaskCompletionSource<bool> to true . A consumer of the task produced by this task completion source can await on its completion using the following code: using Microsoft.Coyote.Tasks; // The input task is the task produced by the task completion source. public async Task Consumer(Task<bool> task) { Console.WriteLine(\"Consumer: Waiting the long operation to complete...\"); await task; Console.WriteLine(\"Consumer: The long operation has completed so we can proceed with other work.\"); } You can now use a TaskCompletionSource to coordinate this long running operation with another async Task that needs to wait on the completion of that operation like this: private async Task RunTest() { var completion = TaskCompletionSource.Create<bool>(); this.StartLongOperation(completion); await this.Consumer(completion.Task); Console.WriteLine(\"Main test complete!\"); } The output of this program will look something like this: Producer: Running a long operation... Consumer: Waiting the long operation to complete... Producer: Completed the long operation. Consumer: The long operation has completed so we can proceed with other work. Main test complete! Producer: Completed the task completion source. Note : You must be careful to specify the namespace Microsoft.Coyote.Tasks to use the controlled TaskCompletionSource<TResult> , otherwise you could get the native .NET TaskCompletionSource<TResult> instead! You might also be puzzled by a build error if you try and do this: static async Task Main(string[] args) { Program p = new Program(); await p.RunTest(); } saying: error CS5001: Program does not contain a static 'Main' method suitable for an entry point The reason is C# doesn\u2019t know about the coyote Task , so the fix is to fully qualify that Main entry point task like this: static async System.Threading.Tasks.Task Main(string[] args) { Program p = new Program(); await p.RunTest(); } Hopefully this is the only place in your code that you will need to explicitly use a native .NET Task .","title":"Tcs"},{"location":"concepts/tasks/tcs/#controlled-task-completion-source","text":"The Coyote asynchronous tasks programming model provides a Microsoft.Coyote.Tasks.TaskCompletionSource<TResult> type that is controlled by coyote test during systematic testing to explore interleavings and find concurrency bugs. In production, this type is simply a thin wrapper over the native .NET System.Threading.Tasks.TaskCompletionSource<TResult> type, providing the same operational semantics that you are familiar with.","title":"Controlled task completion source"},{"location":"concepts/tasks/tcs/#why-is-a-task-completion-source-necessary","text":"In many asynchronous scenarios, it is useful to create a Task<TResult> and pass it to one or more consumers, which can then await for this task to complete to get its result. The controlled TaskCompletionSource<TResult> type of Coyote acts as the producer for such a Task<TResult> . The owner of the TaskCompletionSource<TResult> is able to control the state of the produced Task<TResult> and complete it by setting its result. You can learn more about the semantics of a task completion source in the .NET documentation of the native TaskCompletionSource<T> type .","title":"Why is a task completion source necessary?"},{"location":"concepts/tasks/tcs/#how-do-you-use-it","text":"First, create a new controlled TaskCompletionSource<TResult> using the static method TaskCompletionSource.Create<TResult>() . Then, you can get the controlled Task<TResult> associated with this task completion source, using the TaskCompletionSource.Task property, and share it with one or more consumers. Finally, you can use the TaskCompletionSource to complete the produced Task<TResult> . You can do this using the methods of the controlled task completion source: SetResult() SetException() SetCanceled() , or their TrySet* variants: TrySetResult() TrySetException() TrySetCanceled() Why are there two sets of methods, namely, the Set* methods that return void and their TrySet* variants that return bool ? The reason is that the controlled Task<TResult> associated with the TaskCompletionSource<TResult> may only be completed once, thus attempting to set this task into a completed state when it\u2019s already in a completed state is an error, and the Set* methods will throw. However, as we\u2019re dealing with concurrency here, and there are some situations where races may be expected between multiple threads trying to resolve the completion source, the TrySet* variants return bool indicating success rather than throwing an exception.","title":"How do you use it?"},{"location":"concepts/tasks/tcs/#example-code","text":"The code below demonstrates a controlled TaskCompletionSource<TResult> in action. This represents the most typical scenario in which programmers need and use a task completion source, namely to know when a long-running operation, that itself is not awaitable, has finished. using Microsoft.Coyote.Tasks; public void StartLongOperation(TaskCompletionSource<bool> tcs) { Console.WriteLine(\"Producer: Running a long operation...\"); // ... do something that takes a long time. // This may include calling a 3rd party library that is not awaitable. Console.WriteLine(\"Producer: Completed the long operation.\"); tcs.SetResult(true); Console.WriteLine(\"Producer: Completed the task completion source.\"); } The above StartLongOperation method is responsible for running some long operation. Although the method is not awaitable, as it returns void , it can signal its completion by setting the result of the controlled TaskCompletionSource<bool> to true . A consumer of the task produced by this task completion source can await on its completion using the following code: using Microsoft.Coyote.Tasks; // The input task is the task produced by the task completion source. public async Task Consumer(Task<bool> task) { Console.WriteLine(\"Consumer: Waiting the long operation to complete...\"); await task; Console.WriteLine(\"Consumer: The long operation has completed so we can proceed with other work.\"); } You can now use a TaskCompletionSource to coordinate this long running operation with another async Task that needs to wait on the completion of that operation like this: private async Task RunTest() { var completion = TaskCompletionSource.Create<bool>(); this.StartLongOperation(completion); await this.Consumer(completion.Task); Console.WriteLine(\"Main test complete!\"); } The output of this program will look something like this: Producer: Running a long operation... Consumer: Waiting the long operation to complete... Producer: Completed the long operation. Consumer: The long operation has completed so we can proceed with other work. Main test complete! Producer: Completed the task completion source. Note : You must be careful to specify the namespace Microsoft.Coyote.Tasks to use the controlled TaskCompletionSource<TResult> , otherwise you could get the native .NET TaskCompletionSource<TResult> instead! You might also be puzzled by a build error if you try and do this: static async Task Main(string[] args) { Program p = new Program(); await p.RunTest(); } saying: error CS5001: Program does not contain a static 'Main' method suitable for an entry point The reason is C# doesn\u2019t know about the coyote Task , so the fix is to fully qualify that Main entry point task like this: static async System.Threading.Tasks.Task Main(string[] args) { Program p = new Program(); await p.RunTest(); } Hopefully this is the only place in your code that you will need to explicitly use a native .NET Task .","title":"Example code"},{"location":"get-started/build-source/","text":"Build from source If you plan to contribute a Pull Request to Coyote then you need to be able to build the source code and run the tests. Clone the github repo Prerequisites .NET 5.0 SDK Optional: Visual Studio 2019 on Windows. Visual Studio Code is handy to have on other platforms. Building the Coyote project Clone the Coyote repo , then open Coyote.sln and build. You can also use the following PowerShell command line from a Visual Studio 2019 Developer Command Prompt: powershell -f Scripts/build.ps1 Building the NuGet packages In the Coyote project run this PowerShell command line from a Visual Studio 2019 Developer Command Prompt: powershell -f .\\Scripts\\create-nuget-packages.ps1 Installing the Coyote command line tool package You can install the coyote tool from this locally built package using: dotnet tool install --global --add-source ./bin/nuget Microsoft.Coyote.CLI To update your version of the tool you will have to first uninstall the previous version using: dotnet tool uninstall --global Microsoft.Coyote.CLI Using a local NuGet package The samples use the published Microsoft.Coyote NuGet package by default. If you want the samples to use the same Coyote bits you built from the Coyote repo, then edit the NuGet.config file and uncomment the following line: <add key=\"Coyote\" value=\"../Coyote/bin/nuget\"/> Now you can rebuild the samples and so long as the Common\\version.props file contains the same version in both coyote and coyote-samples then it will pick up your newly created NuGet package and use that. Note: this can make debugging into the Coyote runtime possible. Now you are ready to start using Coyote . Running the tests To run all available tests, execute the following PowerShell command line from a Visual Studio 2019 Developer Command Prompt: powershell -f Scripts/run-tests.ps1 You can also run a specific category of tests by adding the -test option to specify the category name, for example: powershell -f Scripts/run-tests.ps1 -test core","title":"Building from source"},{"location":"get-started/build-source/#build-from-source","text":"If you plan to contribute a Pull Request to Coyote then you need to be able to build the source code and run the tests. Clone the github repo","title":"Build from source"},{"location":"get-started/build-source/#prerequisites","text":".NET 5.0 SDK Optional: Visual Studio 2019 on Windows. Visual Studio Code is handy to have on other platforms.","title":"Prerequisites"},{"location":"get-started/build-source/#building-the-coyote-project","text":"Clone the Coyote repo , then open Coyote.sln and build. You can also use the following PowerShell command line from a Visual Studio 2019 Developer Command Prompt: powershell -f Scripts/build.ps1","title":"Building the Coyote project"},{"location":"get-started/build-source/#building-the-nuget-packages","text":"In the Coyote project run this PowerShell command line from a Visual Studio 2019 Developer Command Prompt: powershell -f .\\Scripts\\create-nuget-packages.ps1","title":"Building the NuGet packages"},{"location":"get-started/build-source/#installing-the-coyote-command-line-tool-package","text":"You can install the coyote tool from this locally built package using: dotnet tool install --global --add-source ./bin/nuget Microsoft.Coyote.CLI To update your version of the tool you will have to first uninstall the previous version using: dotnet tool uninstall --global Microsoft.Coyote.CLI","title":"Installing the Coyote command line tool package"},{"location":"get-started/build-source/#using-a-local-nuget-package","text":"The samples use the published Microsoft.Coyote NuGet package by default. If you want the samples to use the same Coyote bits you built from the Coyote repo, then edit the NuGet.config file and uncomment the following line: <add key=\"Coyote\" value=\"../Coyote/bin/nuget\"/> Now you can rebuild the samples and so long as the Common\\version.props file contains the same version in both coyote and coyote-samples then it will pick up your newly created NuGet package and use that. Note: this can make debugging into the Coyote runtime possible. Now you are ready to start using Coyote .","title":"Using a local NuGet package"},{"location":"get-started/build-source/#running-the-tests","text":"To run all available tests, execute the following PowerShell command line from a Visual Studio 2019 Developer Command Prompt: powershell -f Scripts/run-tests.ps1 You can also run a specific category of tests by adding the -test option to specify the category name, for example: powershell -f Scripts/run-tests.ps1 -test core","title":"Running the tests"},{"location":"get-started/install/","text":"Installing Coyote Coyote is a NuGet library and works on .NET Core which means it can be used on Windows, Linux and macOS. Prerequisites .NET 5.0 SDK Optional: Visual Studio 2019 if you are on Windows. Visual Studio Code is handy to have on other platforms. Add the DGML editor feature of Visual Studio 2019. Installing the NuGet package Install Coyote package Install Coyote Test package The Coyote libraries can be easily installed by adding the Microsoft.Coyote NuGet package and the Microsoft.Coyote.Test NuGet package to your C# project. You can then immediately start programming the Coyote API as shown in the samples . You can manually add Coyote to your C# project by using: dotnet add <yourproject>.csproj package Microsoft.Coyote dotnet add <yourproject>.csproj package Microsoft.Coyote.Test Installing the .NET 5.0 Coyote tool You can also install the dotnet tool named coyote for .NET 5.0 using the following command: dotnet tool install --global Microsoft.Coyote.CLI Now you can run the coyote test tool without having to build Coyote from source. Type coyote --help to see if it is working. The dotnet tool install can also install coyote to a --local folder if you prefer that. You can update the global coyote tool by running the following command: dotnet tool update --global Microsoft.Coyote.CLI You can remove the global coyote tool by running the following command: dotnet tool uninstall --global Microsoft.Coyote.CLI Note: this command line tool is only for .NET Core. If you need a version of coyote.exe that runs on .NET Framework, this is installed from the Microsoft.Coyote.Test package, and you can run it from the bin folder of your Coyote application. Using the Coyote tool To learn how to use the Coyote tool read here . Troubleshooting The element \u2018metadata\u2019 in namespace nuspec.xsd has invalid child element \u2018repository\u2019\u2026 If you get an error building the nuget package, you may need to download a new version of nuget.exe from https://www.nuget.org/downloads .","title":"Installing Coyote"},{"location":"get-started/install/#installing-coyote","text":"Coyote is a NuGet library and works on .NET Core which means it can be used on Windows, Linux and macOS.","title":"Installing Coyote"},{"location":"get-started/install/#prerequisites","text":".NET 5.0 SDK Optional: Visual Studio 2019 if you are on Windows. Visual Studio Code is handy to have on other platforms. Add the DGML editor feature of Visual Studio 2019.","title":"Prerequisites"},{"location":"get-started/install/#installing-the-nuget-package","text":"Install Coyote package Install Coyote Test package The Coyote libraries can be easily installed by adding the Microsoft.Coyote NuGet package and the Microsoft.Coyote.Test NuGet package to your C# project. You can then immediately start programming the Coyote API as shown in the samples . You can manually add Coyote to your C# project by using: dotnet add <yourproject>.csproj package Microsoft.Coyote dotnet add <yourproject>.csproj package Microsoft.Coyote.Test","title":"Installing the NuGet package"},{"location":"get-started/install/#installing-the-net-50-coyote-tool","text":"You can also install the dotnet tool named coyote for .NET 5.0 using the following command: dotnet tool install --global Microsoft.Coyote.CLI Now you can run the coyote test tool without having to build Coyote from source. Type coyote --help to see if it is working. The dotnet tool install can also install coyote to a --local folder if you prefer that. You can update the global coyote tool by running the following command: dotnet tool update --global Microsoft.Coyote.CLI You can remove the global coyote tool by running the following command: dotnet tool uninstall --global Microsoft.Coyote.CLI Note: this command line tool is only for .NET Core. If you need a version of coyote.exe that runs on .NET Framework, this is installed from the Microsoft.Coyote.Test package, and you can run it from the bin folder of your Coyote application.","title":"Installing the .NET 5.0 Coyote tool"},{"location":"get-started/install/#using-the-coyote-tool","text":"To learn how to use the Coyote tool read here .","title":"Using the Coyote tool"},{"location":"get-started/install/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"get-started/install/#the-element-metadata-in-namespace-nuspecxsd-has-invalid-child-element-repository","text":"If you get an error building the nuget package, you may need to download a new version of nuget.exe from https://www.nuget.org/downloads .","title":"The element 'metadata' in namespace nuspec.xsd has invalid child element 'repository'..."},{"location":"get-started/telemetry/","text":"Telemetry in Coyote The coyote tool collects usage data in order to help improve your experience. The data is anonymous. It is collected by Microsoft and shared with the community. You can opt-out of telemetry by setting the following environment variable to 1 or true : set COYOTE_CLI_TELEMETRY_OPTOUT=1 First time usage of coyote is detected by the presence of the following file: [Windows] %USERPROFILE%\\AppData\\Local\\Microsoft\\Coyote\\CoyoteMachineId.txt [Linux] $(HOME)/.microsoft/coyote/CoyoteMachineId.txt This file contains a generated GUID representing the local machine which helps telemetry get some vague idea of the number of folks that are using the coyote tool. The following metrics are collected: - the number of times coyote test is invoked and the time taken to complete each test. - the number of times coyote replay is invoked and the time taken to complete the replay. - the number of bugs reported by coyote test . - whether or not coyote is running in the debugger, which is an indication the user is trying to debug an interesting bug found by coyote. - the version of the .NET framework. The telemetry also collects which operating system is being used (windows, linux, macOS). This data is collected using Azure Application Insights and is stored in an Azure account belonging to Microsoft and accessible only by the Microsoft Coyote team members. See also information about data retention and privacy .","title":"Telemetry"},{"location":"get-started/telemetry/#telemetry-in-coyote","text":"The coyote tool collects usage data in order to help improve your experience. The data is anonymous. It is collected by Microsoft and shared with the community. You can opt-out of telemetry by setting the following environment variable to 1 or true : set COYOTE_CLI_TELEMETRY_OPTOUT=1 First time usage of coyote is detected by the presence of the following file: [Windows] %USERPROFILE%\\AppData\\Local\\Microsoft\\Coyote\\CoyoteMachineId.txt [Linux] $(HOME)/.microsoft/coyote/CoyoteMachineId.txt This file contains a generated GUID representing the local machine which helps telemetry get some vague idea of the number of folks that are using the coyote tool. The following metrics are collected: - the number of times coyote test is invoked and the time taken to complete each test. - the number of times coyote replay is invoked and the time taken to complete the replay. - the number of bugs reported by coyote test . - whether or not coyote is running in the debugger, which is an indication the user is trying to debug an interesting bug found by coyote. - the version of the .NET framework. The telemetry also collects which operating system is being used (windows, linux, macOS). This data is collected using Azure Application Insights and is stored in an Azure account belonging to Microsoft and accessible only by the Microsoft Coyote team members. See also information about data retention and privacy .","title":"Telemetry in Coyote"},{"location":"get-started/upgrade-from-psharp/","text":"Upgrading from P# to Coyote This document contains a list of changes from P# to Coyote. Please follow this guide in order to upgrade your applications and services. Contact us if you have any questions or face any issues. General changes Consume the Microsoft.Coyote NuGet package, instead of the Microsoft.PSharp NuGet package. Namespace changes Rename each using Microsoft.PSharp.* to Microsoft.Coyote.* . State machines are now under the new Microsoft.Coyote.Actors namespace, to make it explicit that state machines are implementations of the actor programming model. The Monitor type is now under the Microsoft.Coyote.Specifications namespace. Type changes Machine was renamed to StateMachine to make it explicit that its a state machine. MachineState was renamed to State , as it is now a nested class inside StateMachine . MonitorState was renamed to State , as it is now a nested class inside Monitor . MachineId was renamed to ActorId , as state machines are implementations of the actor programming model. Halt was renamed to HaltEvent to make it explicit that its an event. Default was renamed to DefaultEvent to make it explicit that its an event. IMachineRuntime was renamed to IActorRuntime . IMachineRuntimeLog was renamed to IActorRuntimeLog . RuntimeLogWriter was renamed to ActorRuntimeLogWriter . Runtime API changes The static runtime factory was renamed from PSharpRuntime to RuntimeFactory , so you can now do RuntimeFactory.Create() to get an actor runtime instance (that can execute state machines). IMachineRuntime.CreateMachine was renamed to IActorRuntime.CreateActor . The previously deprecated method IMachineRuntime.CreateMachineAndExecute has been removed, please use IActorRuntime.CreateActorAndExecuteAsync instead (same semantics, just different method name). The previously deprecated method IMachineRuntime.SendEventAndExecute has been removed, please use IActorRuntime.SendEventAndExecuteAsync instead (same semantics, just different method name). Machine API changes Machine.CreateMachine was renamed StateMachine.CreateActor . Machine.Raise was renamed StateMachine.RaiseEvent to become more descriptive. Machine.Goto was renamed StateMachine.RaiseGotoStateEvent to become more descriptive. Machine.Push was renamed StateMachine.RaisePushStateEvent to become more descriptive. Machine.Pop was renamed StateMachine.RaisePopStateEvent to become more descriptive. Machine.Receive was renamed StateMachine.ReceiveEventAsync to become more descriptive. Machine.Send was renamed StateMachine.SendEvent to become more descriptive and match the runtime API. The ReceivedEvent property has been removed. You can now declare event handlers that take a single Event as an in-parameter, which is the Event that triggered the handler. A handler that does not require access to this Event can be still declared without an in-parameter. Some of the user callbacks (e.g. OnException and OnHaltAsync ) now give access to the last dequeued event. Introduced new API RaiseHaltEvent for raising the HaltEvent on yourself (this is more efficient than halting via a RaiseEvent ). Event API changes Halt (now HaltEvent ) can no longer be constructed, use HaltEvent.Instance instead to get access to a singleton instance created once to reduce unnecessary allocations. Monitor API changes Monitor.Raise was renamed to Monitor.RaiseEvent to become more descriptive. Similar to the Machine type, Goto is RaiseGotoStateEvent . Test attribute changes [Microsoft.PSharp.Test] was renamed to [Microsoft.Coyote.SystematicTesting.Test] Command line tool changes The PSharpTester and PSharpReplayer executables have now been merged into the coyote command line tool. To invoke the tester, you do coyote test ... . To invoke the replayer you do coyote replay ... . The command line options remain pretty much the same, but the way they are declared has changed from (for example) -max-steps:100 to --max-steps 100 (single character arguments are used with a single - , e.g. -i 100 ). Read more details in the documentation on using the coyote command line tool here .","title":"Upgrade from psharp"},{"location":"get-started/upgrade-from-psharp/#upgrading-from-p-to-coyote","text":"This document contains a list of changes from P# to Coyote. Please follow this guide in order to upgrade your applications and services. Contact us if you have any questions or face any issues.","title":"Upgrading from P# to Coyote"},{"location":"get-started/upgrade-from-psharp/#general-changes","text":"Consume the Microsoft.Coyote NuGet package, instead of the Microsoft.PSharp NuGet package.","title":"General changes"},{"location":"get-started/upgrade-from-psharp/#namespace-changes","text":"Rename each using Microsoft.PSharp.* to Microsoft.Coyote.* . State machines are now under the new Microsoft.Coyote.Actors namespace, to make it explicit that state machines are implementations of the actor programming model. The Monitor type is now under the Microsoft.Coyote.Specifications namespace.","title":"Namespace changes"},{"location":"get-started/upgrade-from-psharp/#type-changes","text":"Machine was renamed to StateMachine to make it explicit that its a state machine. MachineState was renamed to State , as it is now a nested class inside StateMachine . MonitorState was renamed to State , as it is now a nested class inside Monitor . MachineId was renamed to ActorId , as state machines are implementations of the actor programming model. Halt was renamed to HaltEvent to make it explicit that its an event. Default was renamed to DefaultEvent to make it explicit that its an event. IMachineRuntime was renamed to IActorRuntime . IMachineRuntimeLog was renamed to IActorRuntimeLog . RuntimeLogWriter was renamed to ActorRuntimeLogWriter .","title":"Type changes"},{"location":"get-started/upgrade-from-psharp/#runtime-api-changes","text":"The static runtime factory was renamed from PSharpRuntime to RuntimeFactory , so you can now do RuntimeFactory.Create() to get an actor runtime instance (that can execute state machines). IMachineRuntime.CreateMachine was renamed to IActorRuntime.CreateActor . The previously deprecated method IMachineRuntime.CreateMachineAndExecute has been removed, please use IActorRuntime.CreateActorAndExecuteAsync instead (same semantics, just different method name). The previously deprecated method IMachineRuntime.SendEventAndExecute has been removed, please use IActorRuntime.SendEventAndExecuteAsync instead (same semantics, just different method name).","title":"Runtime API changes"},{"location":"get-started/upgrade-from-psharp/#machine-api-changes","text":"Machine.CreateMachine was renamed StateMachine.CreateActor . Machine.Raise was renamed StateMachine.RaiseEvent to become more descriptive. Machine.Goto was renamed StateMachine.RaiseGotoStateEvent to become more descriptive. Machine.Push was renamed StateMachine.RaisePushStateEvent to become more descriptive. Machine.Pop was renamed StateMachine.RaisePopStateEvent to become more descriptive. Machine.Receive was renamed StateMachine.ReceiveEventAsync to become more descriptive. Machine.Send was renamed StateMachine.SendEvent to become more descriptive and match the runtime API. The ReceivedEvent property has been removed. You can now declare event handlers that take a single Event as an in-parameter, which is the Event that triggered the handler. A handler that does not require access to this Event can be still declared without an in-parameter. Some of the user callbacks (e.g. OnException and OnHaltAsync ) now give access to the last dequeued event. Introduced new API RaiseHaltEvent for raising the HaltEvent on yourself (this is more efficient than halting via a RaiseEvent ).","title":"Machine API changes"},{"location":"get-started/upgrade-from-psharp/#event-api-changes","text":"Halt (now HaltEvent ) can no longer be constructed, use HaltEvent.Instance instead to get access to a singleton instance created once to reduce unnecessary allocations.","title":"Event API changes"},{"location":"get-started/upgrade-from-psharp/#monitor-api-changes","text":"Monitor.Raise was renamed to Monitor.RaiseEvent to become more descriptive. Similar to the Machine type, Goto is RaiseGotoStateEvent .","title":"Monitor API changes"},{"location":"get-started/upgrade-from-psharp/#test-attribute-changes","text":"[Microsoft.PSharp.Test] was renamed to [Microsoft.Coyote.SystematicTesting.Test]","title":"Test attribute changes"},{"location":"get-started/upgrade-from-psharp/#command-line-tool-changes","text":"The PSharpTester and PSharpReplayer executables have now been merged into the coyote command line tool. To invoke the tester, you do coyote test ... . To invoke the replayer you do coyote replay ... . The command line options remain pretty much the same, but the way they are declared has changed from (for example) -max-steps:100 to --max-steps 100 (single character arguments are used with a single - , e.g. -i 100 ). Read more details in the documentation on using the coyote command line tool here .","title":"Command line tool changes"},{"location":"get-started/using-coyote/","text":"Using Coyote After you have installed Coyote , to run the coyote tool use the following command: coyote -? This will list the full command line options. If you are using the .NET Core version of the tool then you can simply run dotnet coyote.dll instead. Rewrite your binaries for testing The coyote command line tool can be used to automatically rewrite any .NET binary to take over concurrency that is built using System.Threading.Tasks.Task . For details on what kinds of rewriting is supported see Rewriting binaries . To invoke the rewriter use the following command: coyote rewrite ${YOUR_PROGRAM} ${YOUR_PROGRAM} is the path to your application or library to be rewritten or a folder containing all the libraries you want rewritten. Type coyote rewrite -? to see the full command line options. Example usage Read this introductory tutorial to see how Coyote can be used to rewrite the binary of a simple application for for testing. Configuration You can provide more rewriting options in a JSON file like this: { \"AssembliesPath\": \"bin/net5.0\", \"OutputPath\": \"bin/net5.0/rewritten\", \"Assemblies\": [ \"BoundedBuffer.dll\", \"MyOtherLibrary.dll\", \"FooBar123.dll\" ] } AssembliesPath is the folder containing the original binaries. This property is required. OutputPath allows you to specify a different location for the rewritten assemblies. The OutputPath can be omitted in which case it is assumed to be the same as AssembliesPath and in that case the original assemblies will be replaced. Assemblies is an optional list of specific assemblies in AssembliesPath to be rewritten. You can also pull in another assembly by providing a full path to something outside the AssembliesPath . If this list is not provided then the tool will rewrite all assemblies found in the specified AssembliesPath . Then pass this config file on the command line: coyote rewrite config.json . Strong name signing For .NET 4.6.2 and 4.8, you may need to resign your rewritten binaries in order for tests to run properly. This can be done by providing the same strong name key that you provided during the original build. This can be done using the --strong-name-key-file command line argument (or -snk for the abbreviated option name). For example, from your coyote repo: coyote rewrite d:\\git\\Coyote\\Tests\\Tests.BugFinding\\bin\\net48\\rewrite.coyote.json --strong-name-key-file Common\\Key.snk You can also provide this key in the JSON file using the StrongNameKeyFile property. Test your binaries The coyote command line tool can be used to automatically test a Coyote program to find and deterministically reproduce bugs in your code while also enforcing your safety and liveness specifications . To invoke the tester use the following command: coyote test ${YOUR_PROGRAM} ${YOUR_PROGRAM} is the path to your application or library that contains a method annotated with the [Microsoft.Coyote.SystematicTesting.Test] attribute. This method is the entry point to the test. Type coyote test -? to see the full command line options. Controlled and reproducible testing In its essence, the Coyote tester: serializes the execution of an asynchronous program, takes control of the underlying task scheduler and any declared sources of non-determinism in the program, explores scheduling decisions and non-deterministic choices to trigger bugs. Because of the above capabilities, the coyote tester is capable of quickly discovering bugs that would be very hard to discover using traditional testing techniques. During testing, the coyote tester executes a program from start to finish for a given number of testing iterations. During each iteration, the tester is exploring a potentially different serialized execution path. If a bug is discovered, the tester will terminate and dump a reproducible trace (including a human readable version of it). See below to learn how to reproduce traces and debug them using a supported version of Visual Studio. Test entry point A Coyote test method can be declared as follows: [Microsoft.Coyote.SystematicTesting.Test] public static void Execute() { ... } The above method acts as the entry point to each testing iteration. The coyote test tool supports calling the following test method signatures: [Microsoft.Coyote.SystematicTesting.Test] public static void Execute(); [Microsoft.Coyote.SystematicTesting.Test] public static async Task Execute(); [Microsoft.Coyote.SystematicTesting.Test] public static void Execute(IActorRuntime runtime); [Microsoft.Coyote.SystematicTesting.Test] public static async Task Execute(IActorRuntime runtime); Note that similar to unit-testing, static state should be appropriately reset before each test iteration because the iterations run in shared memory. However, parallel instances of the tester run in separate processes, which provides isolation. Testing options To see the list of available command line options use the flag -? . You can optionally give the number of testing iterations to perform using --iterations N (where N is an integer > 1). If this option is not provided, the tester will perform 1 iteration by default. You can also provide a timeout, by providing the flag --timeout N (where N > 0), specifying how many seconds before the timeout. If no iterations are specified (thus the default number of iterations is used), then the tester will perform testing iterations until the timeout is reached. Another important flag is --max-steps N . This limits each test iteration to be N steps, after which the iteration is killed and a new one is started. Here, steps are counted as the number of times a synchronization point is reached in the program. The tester provides output at the end of a test run on the iteration lengths that it saw. Use this output for calibrating the best value of N for your case. This flag is usually only needed when your test has the potential of generating non-terminating executions (like an infinite series of ping pong events, for example). In such cases, if you do not provide max-steps then the tester can appear to can get stuck running one iteration forever. This is related to liveness checking . Parallel and portfolio testing The Coyote tester supports parallel testing, often used with a portfolio of different schedulers. To enable parallel testing, you must run coyote , and provide the flag --parallel N (where N > 0), with N specifying the number of parallel testing processes to be spawned. By default, the tester spawns the same testing process multiple times (using different random seeds). When doing parallel testing it is often useful to provide the --sch-portfolio flag. This option allocates different exploration strategies to each spawned test process which increases the chance that one of the test processes will find a particularly difficult bug. Reproducing and debugging traces The coyote replayer can be used to deterministically reproduce and debug buggy executions (found by coyote test ). To run the replayer use the following command: coyote replay ${YOUR_PROGRAM} ${SCHEDULE_TRACE}.schedule Where ${SCHEDULE_TRACE}}.schedule is the trace file dumped by coyote test . You can attach the Visual Studio debugger on this trace by using --break . When using this flag, Coyote will automatically instrument a breakpoint when the bug is found. You can also insert your own breakpoints in the source code as usual. --break uses System.Diagnostics.Debugger.Launch which does not seem to work on MacOS or Linux, see troubleshooting below for an alternate way of debugging replay schedules. See the replay options section of the help output from invoking coyote -? . Supported scenarios Out of the box, Coyote supports finding and reproducing bugs in programs written using: The async , await and lock C# keywords. The most common System.Threading.Tasks types in the .NET Task Parallel Library: Including the Task , Task<TResult> and TaskCompletionSource<TResult> types. The Monitor type in System.Threading . Coyote will let you know with an informative error if it detects a type that it does not support, or if the test invokes an external concurrent API that you have not mocked or rewritten its assembly. For these scenarios, Coyote provides the --no-repro command line option, which allows you to ignore these errors by disabling the ability to reproduce bug traces (i.e., no .schedule file will be produced when a bug is found). Alternatively, if you are using the Coyote test runner from inside another unit testing framework , you can run Coyote in this mode by enabling the Configuration.WithNoBugTraceRepro() option. In the --no-repro mode, you can continue using Coyote to expose tricky concurrency (and other nondeterministic) bugs. As Coyote adds supports for more .NET APIs, you will be able to reproduce bugs in increasingly more scenarios. We are adding support for more APIs over time, but if something you need is missing please open an issue on GitHub or contribute a PR ! Graphing the results The --graph command line option produces a DGML diagram containing a graphical trace of all the state transitions that happened in all test iterations. The --graph-bug command line option is similar but produces a graph only of the last test iteration leading up to a bug. These graphs are different from the graph generated by --coverage activity because the coverage graph collapses all machine instances into one group, so you can more easily see the whole coverage of that machine type. The --graph options are handy when you need to see the difference in state that happened in different machine instances. See animating state machine demo for a visual explanation of what coyote test does when it is looking for bugs. In the animation you will see why the test failed, two of the server nodes have taken on the Leader role, which is not allowed. See also the DGML diagram which you can open in Visual Studio. Here the Server state machines are colored in green, and the Leader states in red to highlight the bug found. Note: this feature is currently only available for programs written using the advanced actor programming model of Coyote. Unit Testing To use Coyote tester in a unit test environment (e.g. with MSTest or xUnit) see Unit Testing . Next steps Now that you have installed and learned how to use the coyote tool, you can jump right into action by checking out this tutorial to learn how to write your first concurrency unit test, which is also available as a video on YouTube . You can also read about the core concepts behind Coyote. There are many more tutorials and samples available for you to explore Coyote further! Troubleshooting Format of the executable (.exe) or library (.dll) is invalid. If you are using a .NET Core target platform then on Windows you will get executable program with .exe file extension, like coyote-samples\\bin\\net5.0\\BoundedBuffer.exe These are not rewritable assemblies. You must instead rewrite and test the associated library, in this case BoundedBuffer.dll . \u2013break does not seem to work on MacOS or Linux --break depends on System.Diagnostics.Debugger.Launch and it seems that this is not supported on MacOS or Linux. So another way to debug a replay is to follow these steps: Create a new Run Configuration Execute the coyote binary, which you can find in ~/.dotnet/tools/coyote if you installed the dotnet tool called Microsoft.Coyote.CLI . Add the arguments ${YOUR_PROGRAM} ${SCHEDULE_TRACE}.schedule Insert the breakpoints where needed and start debugging.","title":"Using Coyote"},{"location":"get-started/using-coyote/#using-coyote","text":"After you have installed Coyote , to run the coyote tool use the following command: coyote -? This will list the full command line options. If you are using the .NET Core version of the tool then you can simply run dotnet coyote.dll instead.","title":"Using Coyote"},{"location":"get-started/using-coyote/#rewrite-your-binaries-for-testing","text":"The coyote command line tool can be used to automatically rewrite any .NET binary to take over concurrency that is built using System.Threading.Tasks.Task . For details on what kinds of rewriting is supported see Rewriting binaries . To invoke the rewriter use the following command: coyote rewrite ${YOUR_PROGRAM} ${YOUR_PROGRAM} is the path to your application or library to be rewritten or a folder containing all the libraries you want rewritten. Type coyote rewrite -? to see the full command line options.","title":"Rewrite your binaries for testing"},{"location":"get-started/using-coyote/#example-usage","text":"Read this introductory tutorial to see how Coyote can be used to rewrite the binary of a simple application for for testing.","title":"Example usage"},{"location":"get-started/using-coyote/#configuration","text":"You can provide more rewriting options in a JSON file like this: { \"AssembliesPath\": \"bin/net5.0\", \"OutputPath\": \"bin/net5.0/rewritten\", \"Assemblies\": [ \"BoundedBuffer.dll\", \"MyOtherLibrary.dll\", \"FooBar123.dll\" ] } AssembliesPath is the folder containing the original binaries. This property is required. OutputPath allows you to specify a different location for the rewritten assemblies. The OutputPath can be omitted in which case it is assumed to be the same as AssembliesPath and in that case the original assemblies will be replaced. Assemblies is an optional list of specific assemblies in AssembliesPath to be rewritten. You can also pull in another assembly by providing a full path to something outside the AssembliesPath . If this list is not provided then the tool will rewrite all assemblies found in the specified AssembliesPath . Then pass this config file on the command line: coyote rewrite config.json .","title":"Configuration"},{"location":"get-started/using-coyote/#strong-name-signing","text":"For .NET 4.6.2 and 4.8, you may need to resign your rewritten binaries in order for tests to run properly. This can be done by providing the same strong name key that you provided during the original build. This can be done using the --strong-name-key-file command line argument (or -snk for the abbreviated option name). For example, from your coyote repo: coyote rewrite d:\\git\\Coyote\\Tests\\Tests.BugFinding\\bin\\net48\\rewrite.coyote.json --strong-name-key-file Common\\Key.snk You can also provide this key in the JSON file using the StrongNameKeyFile property.","title":"Strong name signing"},{"location":"get-started/using-coyote/#test-your-binaries","text":"The coyote command line tool can be used to automatically test a Coyote program to find and deterministically reproduce bugs in your code while also enforcing your safety and liveness specifications . To invoke the tester use the following command: coyote test ${YOUR_PROGRAM} ${YOUR_PROGRAM} is the path to your application or library that contains a method annotated with the [Microsoft.Coyote.SystematicTesting.Test] attribute. This method is the entry point to the test. Type coyote test -? to see the full command line options.","title":"Test your binaries"},{"location":"get-started/using-coyote/#controlled-and-reproducible-testing","text":"In its essence, the Coyote tester: serializes the execution of an asynchronous program, takes control of the underlying task scheduler and any declared sources of non-determinism in the program, explores scheduling decisions and non-deterministic choices to trigger bugs. Because of the above capabilities, the coyote tester is capable of quickly discovering bugs that would be very hard to discover using traditional testing techniques. During testing, the coyote tester executes a program from start to finish for a given number of testing iterations. During each iteration, the tester is exploring a potentially different serialized execution path. If a bug is discovered, the tester will terminate and dump a reproducible trace (including a human readable version of it). See below to learn how to reproduce traces and debug them using a supported version of Visual Studio.","title":"Controlled and reproducible testing"},{"location":"get-started/using-coyote/#test-entry-point","text":"A Coyote test method can be declared as follows: [Microsoft.Coyote.SystematicTesting.Test] public static void Execute() { ... } The above method acts as the entry point to each testing iteration. The coyote test tool supports calling the following test method signatures: [Microsoft.Coyote.SystematicTesting.Test] public static void Execute(); [Microsoft.Coyote.SystematicTesting.Test] public static async Task Execute(); [Microsoft.Coyote.SystematicTesting.Test] public static void Execute(IActorRuntime runtime); [Microsoft.Coyote.SystematicTesting.Test] public static async Task Execute(IActorRuntime runtime); Note that similar to unit-testing, static state should be appropriately reset before each test iteration because the iterations run in shared memory. However, parallel instances of the tester run in separate processes, which provides isolation.","title":"Test entry point"},{"location":"get-started/using-coyote/#testing-options","text":"To see the list of available command line options use the flag -? . You can optionally give the number of testing iterations to perform using --iterations N (where N is an integer > 1). If this option is not provided, the tester will perform 1 iteration by default. You can also provide a timeout, by providing the flag --timeout N (where N > 0), specifying how many seconds before the timeout. If no iterations are specified (thus the default number of iterations is used), then the tester will perform testing iterations until the timeout is reached. Another important flag is --max-steps N . This limits each test iteration to be N steps, after which the iteration is killed and a new one is started. Here, steps are counted as the number of times a synchronization point is reached in the program. The tester provides output at the end of a test run on the iteration lengths that it saw. Use this output for calibrating the best value of N for your case. This flag is usually only needed when your test has the potential of generating non-terminating executions (like an infinite series of ping pong events, for example). In such cases, if you do not provide max-steps then the tester can appear to can get stuck running one iteration forever. This is related to liveness checking .","title":"Testing options"},{"location":"get-started/using-coyote/#parallel-and-portfolio-testing","text":"The Coyote tester supports parallel testing, often used with a portfolio of different schedulers. To enable parallel testing, you must run coyote , and provide the flag --parallel N (where N > 0), with N specifying the number of parallel testing processes to be spawned. By default, the tester spawns the same testing process multiple times (using different random seeds). When doing parallel testing it is often useful to provide the --sch-portfolio flag. This option allocates different exploration strategies to each spawned test process which increases the chance that one of the test processes will find a particularly difficult bug.","title":"Parallel and portfolio testing"},{"location":"get-started/using-coyote/#reproducing-and-debugging-traces","text":"The coyote replayer can be used to deterministically reproduce and debug buggy executions (found by coyote test ). To run the replayer use the following command: coyote replay ${YOUR_PROGRAM} ${SCHEDULE_TRACE}.schedule Where ${SCHEDULE_TRACE}}.schedule is the trace file dumped by coyote test . You can attach the Visual Studio debugger on this trace by using --break . When using this flag, Coyote will automatically instrument a breakpoint when the bug is found. You can also insert your own breakpoints in the source code as usual. --break uses System.Diagnostics.Debugger.Launch which does not seem to work on MacOS or Linux, see troubleshooting below for an alternate way of debugging replay schedules. See the replay options section of the help output from invoking coyote -? .","title":"Reproducing and debugging traces"},{"location":"get-started/using-coyote/#supported-scenarios","text":"Out of the box, Coyote supports finding and reproducing bugs in programs written using: The async , await and lock C# keywords. The most common System.Threading.Tasks types in the .NET Task Parallel Library: Including the Task , Task<TResult> and TaskCompletionSource<TResult> types. The Monitor type in System.Threading . Coyote will let you know with an informative error if it detects a type that it does not support, or if the test invokes an external concurrent API that you have not mocked or rewritten its assembly. For these scenarios, Coyote provides the --no-repro command line option, which allows you to ignore these errors by disabling the ability to reproduce bug traces (i.e., no .schedule file will be produced when a bug is found). Alternatively, if you are using the Coyote test runner from inside another unit testing framework , you can run Coyote in this mode by enabling the Configuration.WithNoBugTraceRepro() option. In the --no-repro mode, you can continue using Coyote to expose tricky concurrency (and other nondeterministic) bugs. As Coyote adds supports for more .NET APIs, you will be able to reproduce bugs in increasingly more scenarios. We are adding support for more APIs over time, but if something you need is missing please open an issue on GitHub or contribute a PR !","title":"Supported scenarios"},{"location":"get-started/using-coyote/#graphing-the-results","text":"The --graph command line option produces a DGML diagram containing a graphical trace of all the state transitions that happened in all test iterations. The --graph-bug command line option is similar but produces a graph only of the last test iteration leading up to a bug. These graphs are different from the graph generated by --coverage activity because the coverage graph collapses all machine instances into one group, so you can more easily see the whole coverage of that machine type. The --graph options are handy when you need to see the difference in state that happened in different machine instances. See animating state machine demo for a visual explanation of what coyote test does when it is looking for bugs. In the animation you will see why the test failed, two of the server nodes have taken on the Leader role, which is not allowed. See also the DGML diagram which you can open in Visual Studio. Here the Server state machines are colored in green, and the Leader states in red to highlight the bug found. Note: this feature is currently only available for programs written using the advanced actor programming model of Coyote.","title":"Graphing the results"},{"location":"get-started/using-coyote/#unit-testing","text":"To use Coyote tester in a unit test environment (e.g. with MSTest or xUnit) see Unit Testing .","title":"Unit Testing"},{"location":"get-started/using-coyote/#next-steps","text":"Now that you have installed and learned how to use the coyote tool, you can jump right into action by checking out this tutorial to learn how to write your first concurrency unit test, which is also available as a video on YouTube . You can also read about the core concepts behind Coyote. There are many more tutorials and samples available for you to explore Coyote further!","title":"Next steps"},{"location":"get-started/using-coyote/#troubleshooting","text":"Format of the executable (.exe) or library (.dll) is invalid. If you are using a .NET Core target platform then on Windows you will get executable program with .exe file extension, like coyote-samples\\bin\\net5.0\\BoundedBuffer.exe These are not rewritable assemblies. You must instead rewrite and test the associated library, in this case BoundedBuffer.dll . \u2013break does not seem to work on MacOS or Linux --break depends on System.Diagnostics.Debugger.Launch and it seems that this is not supported on MacOS or Linux. So another way to debug a replay is to follow these steps: Create a new Run Configuration Execute the coyote binary, which you can find in ~/.dotnet/tools/coyote if you installed the dotnet tool called Microsoft.Coyote.CLI . Add the arguments ${YOUR_PROGRAM} ${SCHEDULE_TRACE}.schedule Insert the breakpoints where needed and start debugging.","title":"Troubleshooting"},{"location":"how-to/coverage/","text":"Track code and actor activity coverage Standard code coverage tools record the percentage of code lines that are actually executed by test cases. Coyote additionally defines the higher-level metric Actor Activity Coverage that reports state transitions and the percentage of possible events that are actually executed during a run of coyote tester. Coyote coverage options Running coyote /? displays a summary of command-line options. Here is the section describing options to report code and activity coverage: Code and activity coverage options: ----------------------------------- -c, --coverage string : Generate code coverage statistics (via VS instrumentation) with zero or more values equal to: code: Generate code coverage statistics (via VS instrumentation) activity: Generate activity (state machine, event, etc.) coverage statistics activity-debug: Print activity coverage statistics with debug info -instr, --instrument string : Additional file spec(s) to instrument for code coverage (wildcards supported) -instr-list, --instrument-list string : File containing the paths to additional file(s) to instrument for code coverage, one per line, wildcards supported, lines starting with '//' are skipped Detailed descriptions are provided in subsequent sections. The following provides a quick overview. Note that --coverage is the equivalent of specifying --coverage code activity . If --coverage or --coverage code is specified, all DLLs in the dependency chain between the assembly being tested (specified by the path argument) and any Microsoft.Coyote.*.dll are instrumented to collect code coverage data. The --instrument options allow you specify other DLLs that don\u2019t depend on Coyote but should also be instrumented (for example, utility libraries). File names can be absolute or relative to the assembly being tested (specified by the path argument). --coverage activity and --coverage activity-debug do not instrument assemblies. In this case Coyote maintains the history of events and state transitions for reporting the coverage of the actors and state machines being tested. Output file locations By default, at the end of testing the report files are written to a directory named Output/[assemblyToTest]/CoyoteOutput in the directory specified by the path argument. If --outdir outputDirectory is specified, then the files are written to the directory [outputDirectory]/CoyoteOutput . Details of the report files that are created for the separate coverage types are provided in subsequent sections. Actor activity coverage Actor activity coverage includes event coverage, which is defined in the following section, as well as a summary of states that were entered and exited and which state transitions occurred. Definition of event coverage A tuple (M, S, E) is said to be defined if state S of machine M is prepared to receive an event of type E, i.e., it has an action defined for the event. A tuple (M, S, E) is said to be covered by a test run if state S of machine M actually dequeues an event of type E during an execution. Event coverage is the number of tuples covered divided by the number of tuples defined in the program. The higher this metric, the better testing exercised all these combinations in the program. As with other coverage metrics, obtaining 100% coverage may be unrealistic as it depends on the particular test harness being used. Activity coverage output files If the option --coverage , --coverage activity , or --coverage activity-debug is passed to coyote , the following files will be written to the output directory (for example, given path equal to PingPong.exe ): * PingPong.coverage.txt . This file contains the Event Coverage metric along with a breakdown per machine and per state. It also summarizes other useful coverage information. * PingPong.dgml . This file contains the Event Coverage visualization as described below. * PingPong.sci . This is the serialized CoverageInfo object for the test run. Such \u2018sci\u2019 files from multiple runs can be passed to CoyoteCoverageReportMerger.exe to create a merged report. * If --coverage activity-debug was specified, then there will also be a Debug directory containing the same files as above for each process, with the filename qualified by a sequential process id, e.g: PingPong.coverage_0.txt Note that while --coverage is a shortcut for specifying both --coverage code and --coverage activity , you must specify --coverage activity-debug explicitly. Activity coverage visualization example The activity coverage can additionally be displayed in DGML diagram format. Run coyote as described in the coyote examples section below. This produces a file in the DGML format as described in the activity coverage output files section. Open the file using Visual Studio. It captures machines, states and transitions witnessed during the testing of the program. The file also contains inter-machine transitions. These transitions are usually auto-hidden when opened in Visual Studio, but visible when you click on a state. Code coverage For code coverage, coyote instruments the path assembly and the binaries it depends upon via VSInstr.exe . VSPerfCmd.exe is launched while the test runs, and is terminated when the test is complete. For code coverage to work you must ensure your project is built using Full PDBs which you can do by specifying the following build properties: <PropertyGroup> <DebugType>full</DebugType> <DebugSymbols>true</DebugSymbols> </PropertyGroup> VSPerfCmd.exe collects data from all running processes, so do not run multiple coverage tests at the same time. Code coverage binary instrumentation coyote instruments the following binaries (via VSInstr.exe ): * path : this is the path to the assembly that is being tested. * Each DLL in the dependency graph of the assembly specified by the path argument - not including Microsoft.Coyote.dll , mscorlib or any System* assemblies. * Any additional assemblies specified by one of the --instrument or --instrument-list options. By default the VS 2019 tools are used. These are set in coyote.exe.config and are based on the environment variable $(DevEnvDir) which is automatically defined if you use a Visual Studio Developer Command Prompt. The actual paths can be overridden by environment variables with the same names as the app settings: VSInstrToolPath VSPerfCmdToolPath Code coverage output files If the option --coverage or --coverage code is passed to coyote , the following files will be written to the output directory (for example, if path is PingPong.exe ): PingPong.coverage . This file contains the code coverage data that can be read by Visual Studio. To do so, load it as a file into VS, then select Mixed Debugging. The same Coyote output folder will contain all the instrumented binaries that were used to run the test. The original binaries are left unchanged. The instrumented binaries are retained because VS requires the matching instrumented binaries to be able to load the .coverage file. If you want keep track of code-coverage improvements over time you can use the coyote test --outdir option to collect multiple coverage files in different locations. Coyote test examples First build the coyote-samples repo by running the following command: powershell -f build.ps1 Then run coyote with one of the coverage flags, as well as the other options you want. Here are some minimal examples: coyote test ./bin/net5.0/Monitors.exe -i 10 --coverage This will create the directory ./bin/net5.0/Output/Monitors.exe/CoyoteOutput/ , then it generates coverage files for code coverage which you can load into Visual Studio to see the results. coyote test ./bin/net5.0/Monitors.exe -i 10 -coverage activity -o \"/Coyote_Coverage/Monitors\" This will create the directory /Coyote_Coverage/Monitors/CoyoteOutput , then it generates only activity coverage. coyote test ./bin/net5.0/Monitors.exe -i 10 --coverage code activity-debug This generates code and activity coverage, including debug activity output. Troubleshooting Error VSP1394: Could not start profile monitor This could happen if you are trying to run coyote test from a current directory that contains conflicting binaries from the ones you are testing. Try cd to some other location and run coyote test with a full path to the binary being tested. Exception thrown: \u2018System.BadImageFormatException\u2019 in System.Private.CoreLib.dll This could happen on a .NET Core build if you are referencing a .exe instead of the .dll assembly for testing. Error: Could not find dependent assembly \u2026 You may need to add --instrument or --instrument-list option to specify the location of that additional assembly. Code coverage is empty If a .coverage file is produced but it is empty, and contains no coverage information then try running VSInst manually and check for any errors.","title":"Track code and actor activity coverage"},{"location":"how-to/coverage/#track-code-and-actor-activity-coverage","text":"Standard code coverage tools record the percentage of code lines that are actually executed by test cases. Coyote additionally defines the higher-level metric Actor Activity Coverage that reports state transitions and the percentage of possible events that are actually executed during a run of coyote tester.","title":"Track code and actor activity coverage"},{"location":"how-to/coverage/#coyote-coverage-options","text":"Running coyote /? displays a summary of command-line options. Here is the section describing options to report code and activity coverage: Code and activity coverage options: ----------------------------------- -c, --coverage string : Generate code coverage statistics (via VS instrumentation) with zero or more values equal to: code: Generate code coverage statistics (via VS instrumentation) activity: Generate activity (state machine, event, etc.) coverage statistics activity-debug: Print activity coverage statistics with debug info -instr, --instrument string : Additional file spec(s) to instrument for code coverage (wildcards supported) -instr-list, --instrument-list string : File containing the paths to additional file(s) to instrument for code coverage, one per line, wildcards supported, lines starting with '//' are skipped Detailed descriptions are provided in subsequent sections. The following provides a quick overview. Note that --coverage is the equivalent of specifying --coverage code activity . If --coverage or --coverage code is specified, all DLLs in the dependency chain between the assembly being tested (specified by the path argument) and any Microsoft.Coyote.*.dll are instrumented to collect code coverage data. The --instrument options allow you specify other DLLs that don\u2019t depend on Coyote but should also be instrumented (for example, utility libraries). File names can be absolute or relative to the assembly being tested (specified by the path argument). --coverage activity and --coverage activity-debug do not instrument assemblies. In this case Coyote maintains the history of events and state transitions for reporting the coverage of the actors and state machines being tested.","title":"Coyote coverage options"},{"location":"how-to/coverage/#output-file-locations","text":"By default, at the end of testing the report files are written to a directory named Output/[assemblyToTest]/CoyoteOutput in the directory specified by the path argument. If --outdir outputDirectory is specified, then the files are written to the directory [outputDirectory]/CoyoteOutput . Details of the report files that are created for the separate coverage types are provided in subsequent sections.","title":"Output file locations"},{"location":"how-to/coverage/#actor-activity-coverage","text":"Actor activity coverage includes event coverage, which is defined in the following section, as well as a summary of states that were entered and exited and which state transitions occurred.","title":"Actor activity coverage"},{"location":"how-to/coverage/#definition-of-event-coverage","text":"A tuple (M, S, E) is said to be defined if state S of machine M is prepared to receive an event of type E, i.e., it has an action defined for the event. A tuple (M, S, E) is said to be covered by a test run if state S of machine M actually dequeues an event of type E during an execution. Event coverage is the number of tuples covered divided by the number of tuples defined in the program. The higher this metric, the better testing exercised all these combinations in the program. As with other coverage metrics, obtaining 100% coverage may be unrealistic as it depends on the particular test harness being used.","title":"Definition of event coverage"},{"location":"how-to/coverage/#activity-coverage-output-files","text":"If the option --coverage , --coverage activity , or --coverage activity-debug is passed to coyote , the following files will be written to the output directory (for example, given path equal to PingPong.exe ): * PingPong.coverage.txt . This file contains the Event Coverage metric along with a breakdown per machine and per state. It also summarizes other useful coverage information. * PingPong.dgml . This file contains the Event Coverage visualization as described below. * PingPong.sci . This is the serialized CoverageInfo object for the test run. Such \u2018sci\u2019 files from multiple runs can be passed to CoyoteCoverageReportMerger.exe to create a merged report. * If --coverage activity-debug was specified, then there will also be a Debug directory containing the same files as above for each process, with the filename qualified by a sequential process id, e.g: PingPong.coverage_0.txt Note that while --coverage is a shortcut for specifying both --coverage code and --coverage activity , you must specify --coverage activity-debug explicitly.","title":"Activity coverage output files"},{"location":"how-to/coverage/#activity-coverage-visualization-example","text":"The activity coverage can additionally be displayed in DGML diagram format. Run coyote as described in the coyote examples section below. This produces a file in the DGML format as described in the activity coverage output files section. Open the file using Visual Studio. It captures machines, states and transitions witnessed during the testing of the program. The file also contains inter-machine transitions. These transitions are usually auto-hidden when opened in Visual Studio, but visible when you click on a state.","title":"Activity coverage visualization example"},{"location":"how-to/coverage/#code-coverage","text":"For code coverage, coyote instruments the path assembly and the binaries it depends upon via VSInstr.exe . VSPerfCmd.exe is launched while the test runs, and is terminated when the test is complete. For code coverage to work you must ensure your project is built using Full PDBs which you can do by specifying the following build properties: <PropertyGroup> <DebugType>full</DebugType> <DebugSymbols>true</DebugSymbols> </PropertyGroup> VSPerfCmd.exe collects data from all running processes, so do not run multiple coverage tests at the same time.","title":"Code coverage"},{"location":"how-to/coverage/#code-coverage-binary-instrumentation","text":"coyote instruments the following binaries (via VSInstr.exe ): * path : this is the path to the assembly that is being tested. * Each DLL in the dependency graph of the assembly specified by the path argument - not including Microsoft.Coyote.dll , mscorlib or any System* assemblies. * Any additional assemblies specified by one of the --instrument or --instrument-list options. By default the VS 2019 tools are used. These are set in coyote.exe.config and are based on the environment variable $(DevEnvDir) which is automatically defined if you use a Visual Studio Developer Command Prompt. The actual paths can be overridden by environment variables with the same names as the app settings: VSInstrToolPath VSPerfCmdToolPath","title":"Code coverage binary instrumentation"},{"location":"how-to/coverage/#code-coverage-output-files","text":"If the option --coverage or --coverage code is passed to coyote , the following files will be written to the output directory (for example, if path is PingPong.exe ): PingPong.coverage . This file contains the code coverage data that can be read by Visual Studio. To do so, load it as a file into VS, then select Mixed Debugging. The same Coyote output folder will contain all the instrumented binaries that were used to run the test. The original binaries are left unchanged. The instrumented binaries are retained because VS requires the matching instrumented binaries to be able to load the .coverage file. If you want keep track of code-coverage improvements over time you can use the coyote test --outdir option to collect multiple coverage files in different locations.","title":"Code coverage output files"},{"location":"how-to/coverage/#coyote-test-examples","text":"First build the coyote-samples repo by running the following command: powershell -f build.ps1 Then run coyote with one of the coverage flags, as well as the other options you want. Here are some minimal examples: coyote test ./bin/net5.0/Monitors.exe -i 10 --coverage This will create the directory ./bin/net5.0/Output/Monitors.exe/CoyoteOutput/ , then it generates coverage files for code coverage which you can load into Visual Studio to see the results. coyote test ./bin/net5.0/Monitors.exe -i 10 -coverage activity -o \"/Coyote_Coverage/Monitors\" This will create the directory /Coyote_Coverage/Monitors/CoyoteOutput , then it generates only activity coverage. coyote test ./bin/net5.0/Monitors.exe -i 10 --coverage code activity-debug This generates code and activity coverage, including debug activity output.","title":"Coyote test examples"},{"location":"how-to/coverage/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"how-to/coverage/#error-vsp1394-could-not-start-profile-monitor","text":"This could happen if you are trying to run coyote test from a current directory that contains conflicting binaries from the ones you are testing. Try cd to some other location and run coyote test with a full path to the binary being tested.","title":"Error VSP1394: Could not start profile monitor"},{"location":"how-to/coverage/#exception-thrown-systembadimageformatexception-in-systemprivatecorelibdll","text":"This could happen on a .NET Core build if you are referencing a .exe instead of the .dll assembly for testing.","title":"Exception thrown: 'System.BadImageFormatException' in System.Private.CoreLib.dll"},{"location":"how-to/coverage/#error-could-not-find-dependent-assembly","text":"You may need to add --instrument or --instrument-list option to specify the location of that additional assembly.","title":"Error: Could not find dependent assembly ..."},{"location":"how-to/coverage/#code-coverage-is-empty","text":"If a .coverage file is produced but it is empty, and contains no coverage information then try running VSInst manually and check for any errors.","title":"Code coverage is empty"},{"location":"how-to/generate-dgml/","text":"Generate DGML diagrams Coyote generates Directed Graph Markup Language ( DGML ) diagrams showing the states and events discovered during testing of a state machine. DGML diagrams can be viewed using Visual Studio if you have the DGML Editor feature installed. The DGML Editor feature of Visual Studio 2019 can be installed if you click Modify on the Visual Studio Installer, select \u201cAdditional Components\u201d tab and scroll down to \u201cDGML Editor\u201d and make sure it is checked. The Enterprise version of Visual Studio can also produce DGML diagrams of your code, this is how the following diagrams were produced for the Raft Mocking Example :","title":"Generate DGML diagrams"},{"location":"how-to/generate-dgml/#generate-dgml-diagrams","text":"Coyote generates Directed Graph Markup Language ( DGML ) diagrams showing the states and events discovered during testing of a state machine. DGML diagrams can be viewed using Visual Studio if you have the DGML Editor feature installed. The DGML Editor feature of Visual Studio 2019 can be installed if you click Modify on the Visual Studio Installer, select \u201cAdditional Components\u201d tab and scroll down to \u201cDGML Editor\u201d and make sure it is checked. The Enterprise version of Visual Studio can also produce DGML diagrams of your code, this is how the following diagrams were produced for the Raft Mocking Example :","title":"Generate DGML diagrams"},{"location":"how-to/liveness-checking/","text":"Find liveness bugs effectively Now that you learned how to write liveness specifications in Coyote, let\u2019s see how to effectively test for liveness bugs. The presence of monitors that have Hot and Cold states implicitly specifies two assertions. Monitor states that are marked neither Hot nor Cold are called warm states. First, any terminated execution of the program must not have a monitor in a hot state. Second, the program should not have infinite executions that remain in hot (or warm) states infinitely without transitioning to a cold state. While the former is a safety property and easily checked, the latter requires generation of infinite executions, which is not really possible in practice and we must resort to heuristics. Coyote maintains a temperature for each monitor. The temperature goes up by a unit if the monitor transitions to a hot state, it goes to zero on a transition to a cold state and stays the same on transition to a warm state. The Coyote tester looks for executions where the temperature of a monitor exceeds a particular large threshold because it indicates a long suffix stuck in hot/warm states without transitioning to a cold state. The definition of what is large is where you can help the tester. The tester accepts a flag --max-steps N . Using this flag, you can say that the program is expected to execute around N steps per test iteration. Executions substantially longer than N are treated as potential infinite executions. But what is a step and how does one estimate N? This can be done using a few iterations of the tester. For example, consider the failover coffee machine using actors sample program. Assuming you have built the samples you can test it with the coyote tool as follows, setting N steps as 200. From the coyote-samples folder: coyote test ./bin/net5.0/CoffeeMachineActors.dll -i 10 -ms 200 -p 4 --sch-portfolio The coyote test tool will produce output, ending with something like the following: ... Testing statistics: ..... Found 0 bugs. ... Scheduling statistics: ..... Explored 40 schedules: 40 fair and 0 unfair. ..... Number of scheduling points in fair terminating schedules: 153 (min), 457 (avg), 1066 (max). ..... Exceeded the max-steps bound of '200' in 95.00% of the fair schedules. ... Elapsed 1.4882005 sec. . Done Note the line that reads Exceeded the max-steps bound of '200' in 95.00% of the fair schedules . It means that the program execution exceeded 200 steps several times (95% of the times) to reach termination. The line above it indicates that execution lengths ranged from 153 steps to 1066 steps, averaging 457 steps. Going by this output, let\u2019s decide to increase the bound to 1000 and re-run coyote test . coyote test ./bin/net5.0/CoffeeMachineActors.dll -i 10 -ms 1000 -p 4 --sch-portfolio This time the output will be something like: ... Testing statistics: ..... Found 0 bugs. ... Scheduling statistics: ..... Explored 40 schedules: 40 fair and 0 unfair. ..... Number of scheduling points in fair terminating schedules: 88 (min), 657 (avg), 2411 (max). ..... Exceeded the max-steps bound of '1000' in 27.50% of the fair schedules. ... Elapsed 3.3885497 sec. . Done The testing is a little bit slower: taking a bit more than 3 seconds for the same number of iterations. But the tester hit the bound much fewer times, making the testing much more effective as it more often covers the entire length of program execution. In general, it is not necessary to make this percentage go to zero. Often times, programs can exceed their expected length of execution, either because of bugs, or because of corner-case scheduling that delays important events more than usual. You could pick a max-steps bound that is very large. However, this will slow down the tester (when using unfair schedulers; see the next section for details). Thus, it is recommended that you do a few iterations with the tester before settling down on the desired max-steps bound. To understand the details behind fair and unfair scheduling that is mentioned in the output above, let\u2019s move on to next section targeted towards more advanced usage of Coyote. Fair and unfair scheduling See the following technical paper that explains the concept behind fair and unfair scheduling: Fair stateless model checking. Madan Musuvathi and Shaz Qadeer. PLDI 2008. Consider a program with two actors A and B. The actor A continuously sends an event to itself until it receives a message from B. The actor B is ready to send the message to A immediately upon creation. (Contrast this example to Figure 3 of the paper.) This program has an infinite execution: where A is continuously scheduled without giving B a chance. Such an infinite execution is called unfair because B is starved over an infinitely long period of time, which is unrealistic in modern systems. The coyote test tool works by taking over the scheduling of the Coyote program. It uses one of several schedulers : algorithms that decide which actor to schedule next. A scheduler is called fair if it is not expected to generate unfair executions. For example, the random scheduler, which makes decisions on the next actor to schedule randomly, is fair. In the program described above, it is very likely that B will be given a chance to execute. Some schedulers don\u2019t have this property and are called unfair schedulers. Unfair schedulers have a role to play in finding violations of safety properties, but not in finding violations of liveness properties. The pct scheduler of Coyote (enabled with the --sch-pct N option) is unfair. Because of their nature, unfair schedulers are expected to generate longer than usual executions. The unfairness in scheduling can lead to starvation of certain actors, which may stall progress. The expected length of a program\u2019s execution is best determined by looking at lengths of \u201cfair terminating executions\u201d, i.e., executions that terminate under a fair scheduler. For this reason, we provide the fairpct scheduler (enabled with the --sch-fairpct N option) which uses the pct scheduler for a prefix of each execution and then switches to the default fair random scheduler for the remaining of the execution. When a user supplies the flag --max-steps N , executions under an unfair scheduler are forced to stop after N steps. Whereas, an execution under a fair scheduler can go to up 10N steps. Further, if the execution stays in a hot state for more than 5N steps, a liveness bug is flagged. You can additionally supply the flag -max-steps N M to limit fair schedulers to explore only up to M steps (instead of 10N). There are other smarter heuristics available in the tester as well that do away with the need for such bounds by looking for lasso shaped executions. If interested, read more about it in the following paper from Microsoft Research. Lasso Detection using Partial-State Caching. FMCAD 2017. To avoid having to think which scheduler works best for which situation, we recommend running coyote test in parallel (enabled with the -p N option), using the portfolio scheduler (enabled with the --sch-portfolio option) which consists of a carefully tuned selection of fair schedulers (including random and fairpct ).","title":"Find liveness bugs effectively"},{"location":"how-to/liveness-checking/#find-liveness-bugs-effectively","text":"Now that you learned how to write liveness specifications in Coyote, let\u2019s see how to effectively test for liveness bugs. The presence of monitors that have Hot and Cold states implicitly specifies two assertions. Monitor states that are marked neither Hot nor Cold are called warm states. First, any terminated execution of the program must not have a monitor in a hot state. Second, the program should not have infinite executions that remain in hot (or warm) states infinitely without transitioning to a cold state. While the former is a safety property and easily checked, the latter requires generation of infinite executions, which is not really possible in practice and we must resort to heuristics. Coyote maintains a temperature for each monitor. The temperature goes up by a unit if the monitor transitions to a hot state, it goes to zero on a transition to a cold state and stays the same on transition to a warm state. The Coyote tester looks for executions where the temperature of a monitor exceeds a particular large threshold because it indicates a long suffix stuck in hot/warm states without transitioning to a cold state. The definition of what is large is where you can help the tester. The tester accepts a flag --max-steps N . Using this flag, you can say that the program is expected to execute around N steps per test iteration. Executions substantially longer than N are treated as potential infinite executions. But what is a step and how does one estimate N? This can be done using a few iterations of the tester. For example, consider the failover coffee machine using actors sample program. Assuming you have built the samples you can test it with the coyote tool as follows, setting N steps as 200. From the coyote-samples folder: coyote test ./bin/net5.0/CoffeeMachineActors.dll -i 10 -ms 200 -p 4 --sch-portfolio The coyote test tool will produce output, ending with something like the following: ... Testing statistics: ..... Found 0 bugs. ... Scheduling statistics: ..... Explored 40 schedules: 40 fair and 0 unfair. ..... Number of scheduling points in fair terminating schedules: 153 (min), 457 (avg), 1066 (max). ..... Exceeded the max-steps bound of '200' in 95.00% of the fair schedules. ... Elapsed 1.4882005 sec. . Done Note the line that reads Exceeded the max-steps bound of '200' in 95.00% of the fair schedules . It means that the program execution exceeded 200 steps several times (95% of the times) to reach termination. The line above it indicates that execution lengths ranged from 153 steps to 1066 steps, averaging 457 steps. Going by this output, let\u2019s decide to increase the bound to 1000 and re-run coyote test . coyote test ./bin/net5.0/CoffeeMachineActors.dll -i 10 -ms 1000 -p 4 --sch-portfolio This time the output will be something like: ... Testing statistics: ..... Found 0 bugs. ... Scheduling statistics: ..... Explored 40 schedules: 40 fair and 0 unfair. ..... Number of scheduling points in fair terminating schedules: 88 (min), 657 (avg), 2411 (max). ..... Exceeded the max-steps bound of '1000' in 27.50% of the fair schedules. ... Elapsed 3.3885497 sec. . Done The testing is a little bit slower: taking a bit more than 3 seconds for the same number of iterations. But the tester hit the bound much fewer times, making the testing much more effective as it more often covers the entire length of program execution. In general, it is not necessary to make this percentage go to zero. Often times, programs can exceed their expected length of execution, either because of bugs, or because of corner-case scheduling that delays important events more than usual. You could pick a max-steps bound that is very large. However, this will slow down the tester (when using unfair schedulers; see the next section for details). Thus, it is recommended that you do a few iterations with the tester before settling down on the desired max-steps bound. To understand the details behind fair and unfair scheduling that is mentioned in the output above, let\u2019s move on to next section targeted towards more advanced usage of Coyote.","title":"Find liveness bugs effectively"},{"location":"how-to/liveness-checking/#fair-and-unfair-scheduling","text":"See the following technical paper that explains the concept behind fair and unfair scheduling: Fair stateless model checking. Madan Musuvathi and Shaz Qadeer. PLDI 2008. Consider a program with two actors A and B. The actor A continuously sends an event to itself until it receives a message from B. The actor B is ready to send the message to A immediately upon creation. (Contrast this example to Figure 3 of the paper.) This program has an infinite execution: where A is continuously scheduled without giving B a chance. Such an infinite execution is called unfair because B is starved over an infinitely long period of time, which is unrealistic in modern systems. The coyote test tool works by taking over the scheduling of the Coyote program. It uses one of several schedulers : algorithms that decide which actor to schedule next. A scheduler is called fair if it is not expected to generate unfair executions. For example, the random scheduler, which makes decisions on the next actor to schedule randomly, is fair. In the program described above, it is very likely that B will be given a chance to execute. Some schedulers don\u2019t have this property and are called unfair schedulers. Unfair schedulers have a role to play in finding violations of safety properties, but not in finding violations of liveness properties. The pct scheduler of Coyote (enabled with the --sch-pct N option) is unfair. Because of their nature, unfair schedulers are expected to generate longer than usual executions. The unfairness in scheduling can lead to starvation of certain actors, which may stall progress. The expected length of a program\u2019s execution is best determined by looking at lengths of \u201cfair terminating executions\u201d, i.e., executions that terminate under a fair scheduler. For this reason, we provide the fairpct scheduler (enabled with the --sch-fairpct N option) which uses the pct scheduler for a prefix of each execution and then switches to the default fair random scheduler for the remaining of the execution. When a user supplies the flag --max-steps N , executions under an unfair scheduler are forced to stop after N steps. Whereas, an execution under a fair scheduler can go to up 10N steps. Further, if the execution stays in a hot state for more than 5N steps, a liveness bug is flagged. You can additionally supply the flag -max-steps N M to limit fair schedulers to explore only up to M steps (instead of 10N). There are other smarter heuristics available in the tester as well that do away with the need for such bounds by looking for lasso shaped executions. If interested, read more about it in the following paper from Microsoft Research. Lasso Detection using Partial-State Caching. FMCAD 2017. To avoid having to think which scheduler works best for which situation, we recommend running coyote test in parallel (enabled with the -p N option), using the portfolio scheduler (enabled with the --sch-portfolio option) which consists of a carefully tuned selection of fair schedulers (including random and fairpct ).","title":"Fair and unfair scheduling"},{"location":"how-to/unit-testing/","text":"Integrate Coyote with a unit testing framework Common unit testing frameworks like MSTest , xUnit.net and nunit cannot easily call the coyote command line tool for testing. In this case you can use the Coyote TestingEngine directly. The Coyote TestingEngine is included in the Microsoft.Coyote.Test package. The following shows a complete example using xUnit. The project simply includes xUnit and the Coyote packages: <Project Sdk=\"Microsoft.NET.Sdk\"> <PropertyGroup> <TargetFramework>net5.0</TargetFramework> </PropertyGroup> <ItemGroup> <PackageReference Include=\"Microsoft.Coyote\" Version=\"1.2.1\" /> <PackageReference Include=\"Microsoft.Coyote.Test\" Version=\"1.2.1\" /> <PackageReference Include=\"xunit\" Version=\"2.4.1\" /> <PackageReference Include=\"xunit.runner.visualstudio\" Version=\"2.4.2\"> <PrivateAssets>all</PrivateAssets> <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets> </PackageReference> </ItemGroup> </Project> And then your [Fact] method which runs as an xUnit unit test can create a TestingEngine to run a Coyote test method. This test code can run in the Visual Studio Test Explorer or from a dotnet test command line: public class Test { ITestOutputHelper Output; public Test(ITestOutputHelper output) { this.Output = output; } [Fact(Timeout = 5000)] public void RunCoyoteTest() { var config = Configuration.Create(); TestingEngine engine = TestingEngine.Create(config, CoyoteTestMethod); engine.Run(); var report = engine.TestReport; Output.WriteLine(\"Coyote found {0} bug.\", report.NumOfFoundBugs); Assert.True(report.NumOfFoundBugs == 0, $\"Coyote found {report.NumOfFoundBugs} bug(s).\"); } private async Task CoyoteTestMethod() { // This is running as a Coyote test. await Task.Delay(10); Specification.Assert(false, \"This test failed!\"); } } This will produce the following test output because the Specification.Assert is hard wired to fail. Coyote found 1 bug. Most of the command line options you see on coyote test are available in the Configuration class. Use the With* helper methods to set the various configurations, for example, to specify --sch-pct 10 use the following: var config = Configuration.Create().WithPCTStrategy(false, 10); For --iterations use WithTestingIterations . The --graph option maps to the Configuration method WithDgmlGraphEnabled , while the --coverage option maps to WithActivityCoverageEnabled . The --xml-trace option becomes WithXmlLogEnabled and so on. If you want the rich Coyote log files, you can use the TryEmitTraces method on the TestingEngine to produce those log files in the folder of your choice like this: List<string> filenames = new List<string>(engine.TryEmitTraces(\"d:\\\\temp\\\\test\", \"mytest\")); foreach (var item in filenames) { Output.WriteLine(\"See log file: {0}\", item); } Note: TryEmitTraces is an iterator method, which means you must iterate the result in order to produce the log files. You will see the following output: Coyote found 1 bugs See log file: d:\\temp\\test\\mytest_0.txt See log file: d:\\temp\\test\\mytest_0.schedule And the log file contains the familiar output of coyote test as follows: <TestLog> Running test. <ErrorLog> This test failed! <StackTrace> at Microsoft.Coyote.SystematicTesting.OperationScheduler.NotifyAssertionFailure( String text, Boolean killTasks, Boolean cancelExecution) at Microsoft.Coyote.SystematicTesting.ControlledRuntime.Assert(Boolean predicate, String s) at ConsoleApp14.Test.CoyoteTestMethod() at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[TStateMachine]() at ConsoleApp14.Test.CoyoteTestMethod() at Microsoft.Coyote.SystematicTesting.ControlledRuntime.RunTestb__0d.MoveNext() at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[TStateMachine]() at Microsoft.Coyote.SystematicTesting.ControlledRuntime.RunTestb__0() at System.Threading.Tasks.Task.InnerInvoke() at System.Threading.Tasks.Task.c.cctorb__274_0(Object obj) at System.Threading.ExecutionContext.RunFromThreadPoolDispatchLoop( Thread threadPoolThread, ExecutionContext executionContext, ContextCallback callback) at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task currentTaskSlot) at System.Threading.Tasks.Task.ExecuteEntryUnsafe(Thread threadPoolThread) at System.Threading.Tasks.Task.ExecuteFromThreadPool(Thread threadPoolThread) at System.Threading.ThreadPoolWorkQueue.Dispatch() at System.Threading._ThreadPoolWaitCallback.PerformWaitCallback() <StrategyLog> Found bug using 'random' strategy. <StrategyLog> Testing statistics: <StrategyLog> Found 1 bug. <StrategyLog> Scheduling statistics: <StrategyLog> Explored 1 schedule: 1 fair and 0 unfair. <StrategyLog> Found 100.00% buggy schedules. <StrategyLog> Number of scheduling points in fair terminating schedules: 3 (min), 3 (avg), 3 (max). The TestEngine.Create method has overloads for supporting Coyote test methods with the following signatures: Action Action<ICoyoteRuntime> Action<IActorRuntime> Func<Task> Func<ICoyoteRuntime, Task> Func<IActorRuntime, Task> Notice that you never create an ICoyoteRuntime or IActorRuntime yourself, the TestingEngine will do that for you so it can provide the non-production systematic test version of those runtimes. Replaying a trace You can also easily replay and debug a trace, similar to using coyote replay from the command line tool. To do this you need to configure the TestingEngine to run in replay mode: var trace = ... var config = Configuration.Create().WithReplayStrategy(trace); The input to the WithReplayStrategy method should either be the contents of a .schedule file or the string value of TestingEngine.ReproducibleTrace (from a previous run). Then you add breakpoints to debug and replay as follows: var trace = ... var config = Configuration.Create().WithReplayStrategy(trace); TestingEngine engine = TestingEngine.Create(config, CoyoteTestMethod); engine.Run(); Testing actors Actors run asynchronously, so you will need to design your actors in a way such that you know when they have finished doing what they are supposed to do. One way to do that is to use the Coyote TaskCompletionSource<bool> as follows: class TestConfigEvent : Event { public TaskCompletionSource<bool> Completed = TaskCompletionSource.Create<bool>(); } private async Task CoyoteTestActors(IActorRuntime runtime) { // this method can be run by the Coyote TestingEngine. TestConfigEvent config = new TestConfigEvent(); runtime.CreateActor(typeof(MyTestActor), config); await config.Completed.Task; Output.WriteLine(\"Coyote actor test passed\"); } Where MyTestActor sets the result on the TaskCompletionSource as follows: [OnEventDoAction(typeof(MyEvent), nameof(HandleEvent))] class MyTestActor : Actor { TestConfigEvent config; protected override System.Threading.Tasks.Task OnInitializeAsync(Event initialEvent) { config = (TestConfigEvent)initialEvent; var actor = this.CreateActor(typeof(MyActor)); this.SendEvent(actor, new MyEvent() { Caller = this.Id }); return base.OnInitializeAsync(initialEvent); } private void HandleEvent(Event e) { config.Completed.SetResult(true); } } This test actor creates MyActor , sends an event to it, waits for a response, then sets the TaskCompletionSource result. MyActor is a simple ping-pong style actor: class MyEvent : Event { public ActorId Caller; } [OnEventDoAction(typeof(MyEvent), nameof(HandleEvent))] class MyActor : Actor { private void HandleEvent(Event e) { ActorId caller = ((MyEvent)e).Caller; this.SendEvent(caller, new MyEvent() { Caller = this.Id }); } } If you run this test setting WithXmlLogEnabled(true) on the Configuration you will get the following DGML diagram showing you what happened during this test: See the following API documentation for more information: TestingEngine TestReport Configuration","title":"Integrate with a unit testing framework"},{"location":"how-to/unit-testing/#integrate-coyote-with-a-unit-testing-framework","text":"Common unit testing frameworks like MSTest , xUnit.net and nunit cannot easily call the coyote command line tool for testing. In this case you can use the Coyote TestingEngine directly. The Coyote TestingEngine is included in the Microsoft.Coyote.Test package. The following shows a complete example using xUnit. The project simply includes xUnit and the Coyote packages: <Project Sdk=\"Microsoft.NET.Sdk\"> <PropertyGroup> <TargetFramework>net5.0</TargetFramework> </PropertyGroup> <ItemGroup> <PackageReference Include=\"Microsoft.Coyote\" Version=\"1.2.1\" /> <PackageReference Include=\"Microsoft.Coyote.Test\" Version=\"1.2.1\" /> <PackageReference Include=\"xunit\" Version=\"2.4.1\" /> <PackageReference Include=\"xunit.runner.visualstudio\" Version=\"2.4.2\"> <PrivateAssets>all</PrivateAssets> <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets> </PackageReference> </ItemGroup> </Project> And then your [Fact] method which runs as an xUnit unit test can create a TestingEngine to run a Coyote test method. This test code can run in the Visual Studio Test Explorer or from a dotnet test command line: public class Test { ITestOutputHelper Output; public Test(ITestOutputHelper output) { this.Output = output; } [Fact(Timeout = 5000)] public void RunCoyoteTest() { var config = Configuration.Create(); TestingEngine engine = TestingEngine.Create(config, CoyoteTestMethod); engine.Run(); var report = engine.TestReport; Output.WriteLine(\"Coyote found {0} bug.\", report.NumOfFoundBugs); Assert.True(report.NumOfFoundBugs == 0, $\"Coyote found {report.NumOfFoundBugs} bug(s).\"); } private async Task CoyoteTestMethod() { // This is running as a Coyote test. await Task.Delay(10); Specification.Assert(false, \"This test failed!\"); } } This will produce the following test output because the Specification.Assert is hard wired to fail. Coyote found 1 bug. Most of the command line options you see on coyote test are available in the Configuration class. Use the With* helper methods to set the various configurations, for example, to specify --sch-pct 10 use the following: var config = Configuration.Create().WithPCTStrategy(false, 10); For --iterations use WithTestingIterations . The --graph option maps to the Configuration method WithDgmlGraphEnabled , while the --coverage option maps to WithActivityCoverageEnabled . The --xml-trace option becomes WithXmlLogEnabled and so on. If you want the rich Coyote log files, you can use the TryEmitTraces method on the TestingEngine to produce those log files in the folder of your choice like this: List<string> filenames = new List<string>(engine.TryEmitTraces(\"d:\\\\temp\\\\test\", \"mytest\")); foreach (var item in filenames) { Output.WriteLine(\"See log file: {0}\", item); } Note: TryEmitTraces is an iterator method, which means you must iterate the result in order to produce the log files. You will see the following output: Coyote found 1 bugs See log file: d:\\temp\\test\\mytest_0.txt See log file: d:\\temp\\test\\mytest_0.schedule And the log file contains the familiar output of coyote test as follows: <TestLog> Running test. <ErrorLog> This test failed! <StackTrace> at Microsoft.Coyote.SystematicTesting.OperationScheduler.NotifyAssertionFailure( String text, Boolean killTasks, Boolean cancelExecution) at Microsoft.Coyote.SystematicTesting.ControlledRuntime.Assert(Boolean predicate, String s) at ConsoleApp14.Test.CoyoteTestMethod() at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[TStateMachine]() at ConsoleApp14.Test.CoyoteTestMethod() at Microsoft.Coyote.SystematicTesting.ControlledRuntime.RunTestb__0d.MoveNext() at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[TStateMachine]() at Microsoft.Coyote.SystematicTesting.ControlledRuntime.RunTestb__0() at System.Threading.Tasks.Task.InnerInvoke() at System.Threading.Tasks.Task.c.cctorb__274_0(Object obj) at System.Threading.ExecutionContext.RunFromThreadPoolDispatchLoop( Thread threadPoolThread, ExecutionContext executionContext, ContextCallback callback) at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task currentTaskSlot) at System.Threading.Tasks.Task.ExecuteEntryUnsafe(Thread threadPoolThread) at System.Threading.Tasks.Task.ExecuteFromThreadPool(Thread threadPoolThread) at System.Threading.ThreadPoolWorkQueue.Dispatch() at System.Threading._ThreadPoolWaitCallback.PerformWaitCallback() <StrategyLog> Found bug using 'random' strategy. <StrategyLog> Testing statistics: <StrategyLog> Found 1 bug. <StrategyLog> Scheduling statistics: <StrategyLog> Explored 1 schedule: 1 fair and 0 unfair. <StrategyLog> Found 100.00% buggy schedules. <StrategyLog> Number of scheduling points in fair terminating schedules: 3 (min), 3 (avg), 3 (max). The TestEngine.Create method has overloads for supporting Coyote test methods with the following signatures: Action Action<ICoyoteRuntime> Action<IActorRuntime> Func<Task> Func<ICoyoteRuntime, Task> Func<IActorRuntime, Task> Notice that you never create an ICoyoteRuntime or IActorRuntime yourself, the TestingEngine will do that for you so it can provide the non-production systematic test version of those runtimes.","title":"Integrate Coyote with a unit testing framework"},{"location":"how-to/unit-testing/#replaying-a-trace","text":"You can also easily replay and debug a trace, similar to using coyote replay from the command line tool. To do this you need to configure the TestingEngine to run in replay mode: var trace = ... var config = Configuration.Create().WithReplayStrategy(trace); The input to the WithReplayStrategy method should either be the contents of a .schedule file or the string value of TestingEngine.ReproducibleTrace (from a previous run). Then you add breakpoints to debug and replay as follows: var trace = ... var config = Configuration.Create().WithReplayStrategy(trace); TestingEngine engine = TestingEngine.Create(config, CoyoteTestMethod); engine.Run();","title":"Replaying a trace"},{"location":"how-to/unit-testing/#testing-actors","text":"Actors run asynchronously, so you will need to design your actors in a way such that you know when they have finished doing what they are supposed to do. One way to do that is to use the Coyote TaskCompletionSource<bool> as follows: class TestConfigEvent : Event { public TaskCompletionSource<bool> Completed = TaskCompletionSource.Create<bool>(); } private async Task CoyoteTestActors(IActorRuntime runtime) { // this method can be run by the Coyote TestingEngine. TestConfigEvent config = new TestConfigEvent(); runtime.CreateActor(typeof(MyTestActor), config); await config.Completed.Task; Output.WriteLine(\"Coyote actor test passed\"); } Where MyTestActor sets the result on the TaskCompletionSource as follows: [OnEventDoAction(typeof(MyEvent), nameof(HandleEvent))] class MyTestActor : Actor { TestConfigEvent config; protected override System.Threading.Tasks.Task OnInitializeAsync(Event initialEvent) { config = (TestConfigEvent)initialEvent; var actor = this.CreateActor(typeof(MyActor)); this.SendEvent(actor, new MyEvent() { Caller = this.Id }); return base.OnInitializeAsync(initialEvent); } private void HandleEvent(Event e) { config.Completed.SetResult(true); } } This test actor creates MyActor , sends an event to it, waits for a response, then sets the TaskCompletionSource result. MyActor is a simple ping-pong style actor: class MyEvent : Event { public ActorId Caller; } [OnEventDoAction(typeof(MyEvent), nameof(HandleEvent))] class MyActor : Actor { private void HandleEvent(Event e) { ActorId caller = ((MyEvent)e).Caller; this.SendEvent(caller, new MyEvent() { Caller = this.Id }); } } If you run this test setting WithXmlLogEnabled(true) on the Configuration you will get the following DGML diagram showing you what happened during this test: See the following API documentation for more information: TestingEngine TestReport Configuration","title":"Testing actors"},{"location":"overview/benefits/","text":"Key benefits Coyote helps solve the complexity of developing asynchronous software. It helps you with design and implementation by providing optional high-level programming abstractions. It helps with testing by providing support for writing detailed system specifications and a very effective high-coverage testing tool . The integration of these features into the same product helps you iterate faster through the design-implement-test-revise cycle of software development. Coyote allows you to develop with confidence! That confidence comes from having your code changes be backed by powerful automated testing. This has allowed teams to move at a faster pace, often finishing features in a fraction of the time compared to developing with legacy techniques where the uncertainty of vetting corner-cases (especially with concurrency, failures, etc.) weighs you down heavily. The confidence also results in better performant code because Coyote helps you validate even highly-concurrent designs. Testing with Coyote is designed to be easy and effective. It removes the mystery associated with finding concurrency bugs and the pain associated with debugging them. Any bugs reported by the tester can be replayed: something that does not come for free otherwise for programs with concurrency. Coyote testing can be integrated with standard unit-testing frameworks, or easily parallelized for boosting coverage. It also makes it easy to visualize the coverage obtained for a test. Coyote is designed to be lightweight, adding no runtime overhead through binary rewriting for testing unmodified task-based programs. You can also choose to build your application logic using the more advanced asynchronous actor programming model of Coyote, which is high-performant and used by several teams inside Azure. It is easy to get started: simple design will have simple implementations, and a smooth on-ramp from simple to advanced usage of Coyote where the return on your investment depends on how much of Coyote you use in your system. Coyote has been battle-tested by Azure . There are several Azure services written using Coyote that are currently running live in production. We build on the experience of various teams that cover a wide spectrum of requirements.","title":"Key benefits"},{"location":"overview/benefits/#key-benefits","text":"Coyote helps solve the complexity of developing asynchronous software. It helps you with design and implementation by providing optional high-level programming abstractions. It helps with testing by providing support for writing detailed system specifications and a very effective high-coverage testing tool . The integration of these features into the same product helps you iterate faster through the design-implement-test-revise cycle of software development. Coyote allows you to develop with confidence! That confidence comes from having your code changes be backed by powerful automated testing. This has allowed teams to move at a faster pace, often finishing features in a fraction of the time compared to developing with legacy techniques where the uncertainty of vetting corner-cases (especially with concurrency, failures, etc.) weighs you down heavily. The confidence also results in better performant code because Coyote helps you validate even highly-concurrent designs. Testing with Coyote is designed to be easy and effective. It removes the mystery associated with finding concurrency bugs and the pain associated with debugging them. Any bugs reported by the tester can be replayed: something that does not come for free otherwise for programs with concurrency. Coyote testing can be integrated with standard unit-testing frameworks, or easily parallelized for boosting coverage. It also makes it easy to visualize the coverage obtained for a test. Coyote is designed to be lightweight, adding no runtime overhead through binary rewriting for testing unmodified task-based programs. You can also choose to build your application logic using the more advanced asynchronous actor programming model of Coyote, which is high-performant and used by several teams inside Azure. It is easy to get started: simple design will have simple implementations, and a smooth on-ramp from simple to advanced usage of Coyote where the return on your investment depends on how much of Coyote you use in your system. Coyote has been battle-tested by Azure . There are several Azure services written using Coyote that are currently running live in production. We build on the experience of various teams that cover a wide spectrum of requirements.","title":"Key benefits"},{"location":"overview/faq/","text":"Frequently asked questions Seems magical, how does Coyote really work? I\u2019m glad you asked. See how does it work . What programming languages does Coyote support? Coyote currently only supports C#. Is Coyote only available with Azure? No, Coyote can run in any Windows or Linux machine, regardless if it is a local machine or a VM on the cloud. What type of projects will benefit most from using Coyote? Projects that have to deal with asynchrony/concurrency or other non-deterministic issues (such as timeouts, failures and re-orderings). Will Coyote slow down my production code? No, Coyote testing works on unmodified code . If you decide to use the optional Coyote actors API to build your system, then there is minimal production overhead as Coyote actors were designed to be lightweight (they are in-memory objects that execute on top of a C# task) and have been battle-tested by several teams inside Azure. At what stage of the development lifecycle is it best to start using Coyote? Ideally at the very beginning. It is better to do testing while developing, not after you are ready to ship :) Will using Coyote affect the total budget for a software development project? It will have minimal impact initially, as developers ramp up on Coyote concepts. In the long run, our experience with Azure teams suggests that it will help reduce the total budget. Coyote is designed to add agility so that the development and testing processes move at a faster pace. How much time will developers need to learn Coyote? We have been working hard towards making Coyote accessible to all developers, however, we cannot give a conclusive answer yet. We think that it won\u2019t take long. A junior engineer that recently joined an Azure team using Coyote said: \u201c being a new developer to the team, one of the first few things I worked on was Coyote, it was really quick to onboard, writing actual code is simple and straightforward \u201d. Tell us about your experience! How much additional effort is needed to test an existing system with Coyote? Depends on what programming model and concurrency APIs you used for developing your existing system because, for Coyote testing to work, it needs to understand the non-determinism in your system. If you write your code using typical task-based APIs in C#, then most likely you do not need to do anything as Coyote testing works on unmodified code . In other cases, you would also have to model additional non-determinism, such as timers and external services. In general, we recommend using Coyote in early stages of development. How do Coyote actors compare against other actor frameworks? Read how are Coyote Actors different from existing Microsoft Actor frameworks . How is Coyote different from other similar systems out there? One comparison point for Coyote would be other offerings that help build reliable systems. It would be difficult to give an exhaustive answer here, but Coyote is quite unique in its combination of powerful testing and minimal runtime requirements (i.e., it requires the .NET Core only). Other systems might require a buy-in to a particular distributed runtime or messaging system, or might not help much in the way of testing custom business logic. You can adapt Coyote to work with whatever platform you are using today. How many machines do you need to run a Coyote actor-based program? A Coyote actor-based program is hosted in a .NET process, so it can easily run on just one machine. You can also create a distributed Coyote actor-based program by connecting multiple processes, each running Coyote. You are free to use any distributed host platform as well as any messaging system that you want. Can Coyote actors be used with any existing distributed host and communication platform? Yes, Coyote does not constrain you. Coyote is built on top of the .NET Task Parallel Library, and on its own only executes in-memory in the scope of a single .NET process. To build a distributed Coyote program, you are free to use any distributed host and communication mechanism that you like. All you need to do is host your .NET processes (that execute your Coyote code) using your favorite distributed system/framework (such as Kubernetes or Azure Service Fabric ) and connect these processes using your favorite communication/messaging mechanism (such as gRPC , Apache Kafka or Azure Service Bus ). To help you, there is a sample that shows how Coyote can be used with Azure Service Bus . Is it meaningful to use Coyote for a program that runs on a single machine only? Sure, in fact most testing with Coyote is performed on a single machine. Many Coyote users today build reliable cloud services, and Coyote itself is not service-specific. You can use it to build and test any kind of asynchronous .NET program that needs to be reliable. How is Coyote being maintained and what level of support can we expect? Coyote is currently an open source project on GitHub under the MIT license. Microsoft continues to invest in Coyote and accepts community contributions as well. Issues can be posted there and will be resolved in a timely manner.","title":"FAQ"},{"location":"overview/faq/#frequently-asked-questions","text":"","title":"Frequently asked questions"},{"location":"overview/faq/#seems-magical-how-does-coyote-really-work","text":"I\u2019m glad you asked. See how does it work .","title":"Seems magical, how does Coyote really work?"},{"location":"overview/faq/#what-programming-languages-does-coyote-support","text":"Coyote currently only supports C#.","title":"What programming languages does Coyote support?"},{"location":"overview/faq/#is-coyote-only-available-with-azure","text":"No, Coyote can run in any Windows or Linux machine, regardless if it is a local machine or a VM on the cloud.","title":"Is Coyote only available with Azure?"},{"location":"overview/faq/#what-type-of-projects-will-benefit-most-from-using-coyote","text":"Projects that have to deal with asynchrony/concurrency or other non-deterministic issues (such as timeouts, failures and re-orderings).","title":"What type of projects will benefit most from using Coyote?"},{"location":"overview/faq/#will-coyote-slow-down-my-production-code","text":"No, Coyote testing works on unmodified code . If you decide to use the optional Coyote actors API to build your system, then there is minimal production overhead as Coyote actors were designed to be lightweight (they are in-memory objects that execute on top of a C# task) and have been battle-tested by several teams inside Azure.","title":"Will Coyote slow down my production code?"},{"location":"overview/faq/#at-what-stage-of-the-development-lifecycle-is-it-best-to-start-using-coyote","text":"Ideally at the very beginning. It is better to do testing while developing, not after you are ready to ship :)","title":"At what stage of the development lifecycle is it best to start using Coyote?"},{"location":"overview/faq/#will-using-coyote-affect-the-total-budget-for-a-software-development-project","text":"It will have minimal impact initially, as developers ramp up on Coyote concepts. In the long run, our experience with Azure teams suggests that it will help reduce the total budget. Coyote is designed to add agility so that the development and testing processes move at a faster pace.","title":"Will using Coyote affect the total budget for a software development project?"},{"location":"overview/faq/#how-much-time-will-developers-need-to-learn-coyote","text":"We have been working hard towards making Coyote accessible to all developers, however, we cannot give a conclusive answer yet. We think that it won\u2019t take long. A junior engineer that recently joined an Azure team using Coyote said: \u201c being a new developer to the team, one of the first few things I worked on was Coyote, it was really quick to onboard, writing actual code is simple and straightforward \u201d. Tell us about your experience!","title":"How much time will developers need to learn Coyote?"},{"location":"overview/faq/#how-much-additional-effort-is-needed-to-test-an-existing-system-with-coyote","text":"Depends on what programming model and concurrency APIs you used for developing your existing system because, for Coyote testing to work, it needs to understand the non-determinism in your system. If you write your code using typical task-based APIs in C#, then most likely you do not need to do anything as Coyote testing works on unmodified code . In other cases, you would also have to model additional non-determinism, such as timers and external services. In general, we recommend using Coyote in early stages of development.","title":"How much additional effort is needed to test an existing system with Coyote?"},{"location":"overview/faq/#how-do-coyote-actors-compare-against-other-actor-frameworks","text":"Read how are Coyote Actors different from existing Microsoft Actor frameworks .","title":"How do Coyote actors compare against other actor frameworks?"},{"location":"overview/faq/#how-is-coyote-different-from-other-similar-systems-out-there","text":"One comparison point for Coyote would be other offerings that help build reliable systems. It would be difficult to give an exhaustive answer here, but Coyote is quite unique in its combination of powerful testing and minimal runtime requirements (i.e., it requires the .NET Core only). Other systems might require a buy-in to a particular distributed runtime or messaging system, or might not help much in the way of testing custom business logic. You can adapt Coyote to work with whatever platform you are using today.","title":"How is Coyote different from other similar systems out there?"},{"location":"overview/faq/#how-many-machines-do-you-need-to-run-a-coyote-actor-based-program","text":"A Coyote actor-based program is hosted in a .NET process, so it can easily run on just one machine. You can also create a distributed Coyote actor-based program by connecting multiple processes, each running Coyote. You are free to use any distributed host platform as well as any messaging system that you want.","title":"How many machines do you need to run a Coyote actor-based program?"},{"location":"overview/faq/#can-coyote-actors-be-used-with-any-existing-distributed-host-and-communication-platform","text":"Yes, Coyote does not constrain you. Coyote is built on top of the .NET Task Parallel Library, and on its own only executes in-memory in the scope of a single .NET process. To build a distributed Coyote program, you are free to use any distributed host and communication mechanism that you like. All you need to do is host your .NET processes (that execute your Coyote code) using your favorite distributed system/framework (such as Kubernetes or Azure Service Fabric ) and connect these processes using your favorite communication/messaging mechanism (such as gRPC , Apache Kafka or Azure Service Bus ). To help you, there is a sample that shows how Coyote can be used with Azure Service Bus .","title":"Can Coyote actors be used with any existing distributed host and communication platform?"},{"location":"overview/faq/#is-it-meaningful-to-use-coyote-for-a-program-that-runs-on-a-single-machine-only","text":"Sure, in fact most testing with Coyote is performed on a single machine. Many Coyote users today build reliable cloud services, and Coyote itself is not service-specific. You can use it to build and test any kind of asynchronous .NET program that needs to be reliable.","title":"Is it meaningful to use Coyote for a program that runs on a single machine only?"},{"location":"overview/faq/#how-is-coyote-being-maintained-and-what-level-of-support-can-we-expect","text":"Coyote is currently an open source project on GitHub under the MIT license. Microsoft continues to invest in Coyote and accepts community contributions as well. Issues can be posted there and will be resolved in a timely manner.","title":"How is Coyote being maintained and what level of support can we expect?"},{"location":"overview/how/","text":"How does it work? First, you need to write a concurrency unit test . These tests allow (and encourage) the use of concurrency and non-determinism , which you would normally avoid in traditional unit tests due to flakiness. By writing such a test, Coyote allows you to exercise what happens, for example, when two requests execute concurrently in your service, as if it was deployed in production. To use Coyote, you do not need to change a single line in your production code! Using binary rewriting , the coyote rewrite tool will instrument your program-under-test with hooks and stubs that allow Coyote to take control of Task objects and related concurrency types from the .NET Task Parallel Library. This is where the magic happens. Coyote controls the execution of each Task so that it can explore various different interleavings to find and deterministically reproduce concurrency bugs. Although Coyote supports testing unmodified task-based programs, it also gives you the option to use the Coyote in-memory actor and state machine types from the Microsoft.Coyote.Actors library. This is a more advanced asynchronous reactive programming model. This approach requires you to change the design of your application, but gives you powerful (and battle-tested inside Azure) constructs for building highly-reliable applications. Regardless if you use Coyote binary rewriting on your unmodified program or wrote your code using Coyote actors, the next step is to use Coyote to systematically test your code! The coyote test tool takes over the scheduling of a Coyote program. It is able to do this reliably because it deeply understands the concurrency in .NET applications. The tool knows all concurrent operations in a test as well as sources of synchronization between them. By controlling the program schedule, Coyote can reliably explore different interleavings of operations. The coyote test tool uses several state-of-the-art exploration strategies that have been known to find very deep bugs easily. The tool can run a portfolio of available strategies in parallel, maximizing chances of revealing bugs. Coyote refers to these exploration strategies as scheduling strategies and makes it easy to incorporate new strategies, as they come out of research . New scheduling strategies are being developed in Microsoft Research based on a wealth of experience gathered from the Microsoft product groups that are using Coyote today. During testing, Coyote will repeatedly run a test from start to completion, each time exercising different scheduling choices. This methodology has proven to be very effective at providing high coverage, especially concurrency coverage, in a short amount of time. In a similar way, the tool can also take over other sources of non-determinism, such as the delivery of timeouts or injection of failures. If a bug is found, the coyote test tool reports a reproducible bug trace that provides the global order of all scheduling decisions and nondeterministic choices made during the execution of a test. The trace can be replayed reliably over and over again, until the bug is identified. This makes a bug reported by the tool significantly easier to debug than regular unit-/integration-tests and logs from production or stress tests, which are typically nondeterministic. No more Heisenbugs ! See animating state machine demo for a visual explanation of what Coyote does when it is looking for bugs. Follow this tutorial to to write your first concurrency unit test with Coyote. For more information see dealing with nondeterminism and concurrency unit Testing .","title":"How does it work"},{"location":"overview/how/#how-does-it-work","text":"First, you need to write a concurrency unit test . These tests allow (and encourage) the use of concurrency and non-determinism , which you would normally avoid in traditional unit tests due to flakiness. By writing such a test, Coyote allows you to exercise what happens, for example, when two requests execute concurrently in your service, as if it was deployed in production. To use Coyote, you do not need to change a single line in your production code! Using binary rewriting , the coyote rewrite tool will instrument your program-under-test with hooks and stubs that allow Coyote to take control of Task objects and related concurrency types from the .NET Task Parallel Library. This is where the magic happens. Coyote controls the execution of each Task so that it can explore various different interleavings to find and deterministically reproduce concurrency bugs. Although Coyote supports testing unmodified task-based programs, it also gives you the option to use the Coyote in-memory actor and state machine types from the Microsoft.Coyote.Actors library. This is a more advanced asynchronous reactive programming model. This approach requires you to change the design of your application, but gives you powerful (and battle-tested inside Azure) constructs for building highly-reliable applications. Regardless if you use Coyote binary rewriting on your unmodified program or wrote your code using Coyote actors, the next step is to use Coyote to systematically test your code! The coyote test tool takes over the scheduling of a Coyote program. It is able to do this reliably because it deeply understands the concurrency in .NET applications. The tool knows all concurrent operations in a test as well as sources of synchronization between them. By controlling the program schedule, Coyote can reliably explore different interleavings of operations. The coyote test tool uses several state-of-the-art exploration strategies that have been known to find very deep bugs easily. The tool can run a portfolio of available strategies in parallel, maximizing chances of revealing bugs. Coyote refers to these exploration strategies as scheduling strategies and makes it easy to incorporate new strategies, as they come out of research . New scheduling strategies are being developed in Microsoft Research based on a wealth of experience gathered from the Microsoft product groups that are using Coyote today. During testing, Coyote will repeatedly run a test from start to completion, each time exercising different scheduling choices. This methodology has proven to be very effective at providing high coverage, especially concurrency coverage, in a short amount of time. In a similar way, the tool can also take over other sources of non-determinism, such as the delivery of timeouts or injection of failures. If a bug is found, the coyote test tool reports a reproducible bug trace that provides the global order of all scheduling decisions and nondeterministic choices made during the execution of a test. The trace can be replayed reliably over and over again, until the bug is identified. This makes a bug reported by the tool significantly easier to debug than regular unit-/integration-tests and logs from production or stress tests, which are typically nondeterministic. No more Heisenbugs ! See animating state machine demo for a visual explanation of what Coyote does when it is looking for bugs. Follow this tutorial to to write your first concurrency unit test with Coyote. For more information see dealing with nondeterminism and concurrency unit Testing .","title":"How does it work?"},{"location":"overview/publications/","text":"Publications Coyote (which is the evolution of the P# project, and is often published under the name of P#) builds on cutting-edge research. Learning-based controlled concurrency testing . Suvam Mukherjee, Pantazis Deligiannis, Arpita Biswas and Akash Lal. In the 35th ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), 2020. (Won the Distinguished Artifact Award .) Building reliable cloud services using P# (experience report) . Pantazis Deligiannis, Narayanan Ganapathy, Akash Lal and Shaz Qadeer. ArXiv abs/2002.04903, 2020. Reliable State Machines: a framework for programming reliable cloud services . Suvam Mukherjee, Nitin John Raj, Krishnan Govindraj, Pantazis Deligiannis, Chandramouleswaran Ravichandran, Akash Lal, Aseem Rastogi and Raja Krishnaswamy. In the 33rd European Conference on Object-Oriented Programming (ECOOP), 2019. Lasso detection using partial-state caching . Rashmi Mudduluru, Pantazis Deligiannis, Ankush Desai, Akash Lal and Shaz Qadeer. In the 17th International Conference on Formal Methods in Computer-Aided Design (FMCAD), 2017. Uncovering bugs in distributed storage systems during testing (not in production!) . Pantazis Deligiannis, Matt McCutchen, Paul Thomson, Shuo Chen, Alastair F. Donaldson, John Erickson, Cheng Huang, Akash Lal, Rashmi Mudduluru, Shaz Qadeer and Wolfram Schulte. In the 14th USENIX Conference on File and Storage Technologies (FAST), 2016. Asynchronous programming, analysis and testing with state machines . Pantazis Deligiannis, Alastair F. Donaldson, Jeroen Ketema, Akash Lal and Paul Thomson. In the 36th Annual ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), 2015.","title":"Publications"},{"location":"overview/publications/#publications","text":"Coyote (which is the evolution of the P# project, and is often published under the name of P#) builds on cutting-edge research. Learning-based controlled concurrency testing . Suvam Mukherjee, Pantazis Deligiannis, Arpita Biswas and Akash Lal. In the 35th ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), 2020. (Won the Distinguished Artifact Award .) Building reliable cloud services using P# (experience report) . Pantazis Deligiannis, Narayanan Ganapathy, Akash Lal and Shaz Qadeer. ArXiv abs/2002.04903, 2020. Reliable State Machines: a framework for programming reliable cloud services . Suvam Mukherjee, Nitin John Raj, Krishnan Govindraj, Pantazis Deligiannis, Chandramouleswaran Ravichandran, Akash Lal, Aseem Rastogi and Raja Krishnaswamy. In the 33rd European Conference on Object-Oriented Programming (ECOOP), 2019. Lasso detection using partial-state caching . Rashmi Mudduluru, Pantazis Deligiannis, Ankush Desai, Akash Lal and Shaz Qadeer. In the 17th International Conference on Formal Methods in Computer-Aided Design (FMCAD), 2017. Uncovering bugs in distributed storage systems during testing (not in production!) . Pantazis Deligiannis, Matt McCutchen, Paul Thomson, Shuo Chen, Alastair F. Donaldson, John Erickson, Cheng Huang, Akash Lal, Rashmi Mudduluru, Shaz Qadeer and Wolfram Schulte. In the 14th USENIX Conference on File and Storage Technologies (FAST), 2016. Asynchronous programming, analysis and testing with state machines . Pantazis Deligiannis, Alastair F. Donaldson, Jeroen Ketema, Akash Lal and Paul Thomson. In the 36th Annual ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), 2015.","title":"Publications"},{"location":"overview/videos/","text":"Overview on the Microsoft Tech Minutes Series Learn how Coyote can automatically find and reproduce deep concurrency bugs in your code, helping increase the reliability of your service, in this high-level overview of Coyote: Introductory tutorial on Coyote This YouTube video will show you how to write your first concurrency unit test and use Coyote to test your unmodified task-based C# code: Webinar This is an 1 hour Microsoft Research Webinar on Coyote. Sign up to watch the video and you will receive a link to the video in email: The actor programming model This Channel 9 On-NET show is a deeper dive into the actor programming model :","title":"Videos"},{"location":"overview/videos/#overview-on-the-microsoft-tech-minutes-series","text":"Learn how Coyote can automatically find and reproduce deep concurrency bugs in your code, helping increase the reliability of your service, in this high-level overview of Coyote:","title":"Overview on the Microsoft Tech Minutes Series"},{"location":"overview/videos/#introductory-tutorial-on-coyote","text":"This YouTube video will show you how to write your first concurrency unit test and use Coyote to test your unmodified task-based C# code:","title":"Introductory tutorial on Coyote"},{"location":"overview/videos/#webinar","text":"This is an 1 hour Microsoft Research Webinar on Coyote. Sign up to watch the video and you will receive a link to the video in email:","title":"Webinar"},{"location":"overview/videos/#the-actor-programming-model","text":"This Channel 9 On-NET show is a deeper dive into the actor programming model :","title":"The actor programming model"},{"location":"ref/Microsoft.Coyote.Actors.CoverageNamespace/","text":"Microsoft.Coyote.Actors.Coverage namespace public type description class ActorRuntimeLogGraphBuilder Implements the IActorRuntimeLog and builds a directed graph from the recorded events and state transitions. class CoverageInfo Class for storing actor coverage-specific data across multiple testing iterations. class EventCoverage This class maintains information about events received and sent from each state of each actor. class Graph A directed graph made up of Nodes and Links. class GraphLink A Link represents a directed graph connection between two Nodes. class GraphNode A Node of a Graph. class GraphObject A Node of a Graph.","title":"Namespace Overview"},{"location":"ref/Microsoft.Coyote.Actors.CoverageNamespace/#microsoftcoyoteactorscoverage-namespace","text":"public type description class ActorRuntimeLogGraphBuilder Implements the IActorRuntimeLog and builds a directed graph from the recorded events and state transitions. class CoverageInfo Class for storing actor coverage-specific data across multiple testing iterations. class EventCoverage This class maintains information about events received and sent from each state of each actor. class Graph A directed graph made up of Nodes and Links. class GraphLink A Link represents a directed graph connection between two Nodes. class GraphNode A Node of a Graph. class GraphObject A Node of a Graph.","title":"Microsoft.Coyote.Actors.Coverage namespace"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjectsNamespace/","text":"Microsoft.Coyote.Actors.SharedObjects namespace public type description class SharedCounter A thread-safe counter that can be shared in-memory by actors. class SharedDictionary<TKey,TValue> A thread-safe dictionary that can be shared in-memory by actors. static class SharedDictionary A thread-safe dictionary that can be shared in-memory by actors. class SharedRegister<T> A thread-safe register that can be shared in-memory by actors. static class SharedRegister A thread-safe register that can be shared in-memory by actors.","title":"Namespace Overview"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjectsNamespace/#microsoftcoyoteactorssharedobjects-namespace","text":"public type description class SharedCounter A thread-safe counter that can be shared in-memory by actors. class SharedDictionary<TKey,TValue> A thread-safe dictionary that can be shared in-memory by actors. static class SharedDictionary A thread-safe dictionary that can be shared in-memory by actors. class SharedRegister<T> A thread-safe register that can be shared in-memory by actors. static class SharedRegister A thread-safe register that can be shared in-memory by actors.","title":"Microsoft.Coyote.Actors.SharedObjects namespace"},{"location":"ref/Microsoft.Coyote.Actors.TimersNamespace/","text":"Microsoft.Coyote.Actors.Timers namespace public type description class TimerElapsedEvent Defines a timer elapsed event that is sent from a timer to the actor that owns the timer. class TimerInfo Stores information about a timer that can send timeout events to its owner actor.","title":"Namespace Overview"},{"location":"ref/Microsoft.Coyote.Actors.TimersNamespace/#microsoftcoyoteactorstimers-namespace","text":"public type description class TimerElapsedEvent Defines a timer elapsed event that is sent from a timer to the actor that owns the timer. class TimerInfo Stores information about a timer that can send timeout events to its owner actor.","title":"Microsoft.Coyote.Actors.Timers namespace"},{"location":"ref/Microsoft.Coyote.ActorsNamespace/","text":"Microsoft.Coyote.Actors namespace public type description abstract class Actor Type that implements an actor. Inherit from this class to declare a custom actor. class ActorId Unique actor id. class ActorRuntimeLogTextFormatter This class implements IActorRuntimeLog and generates output in a a human readable text format. class AwaitableEventGroup<T> An object representing an awaitable long running context involving one or more actors. An AwaitableEventGroup can be provided as an optional argument in CreateActor and SendEvent. If a null AwaitableEventGroup is passed then the EventGroup is inherited from the sender or target actors (based on which ever one has a CurrentEventGroup ). In this way an AwaitableEventGroup is automatically communicated to all actors involved in completing some larger operation. Each actor involved can find the AwaitableEventGroup using their CurrentEventGroup property. class DefaultEvent A default event that is generated by the runtime when no user-defined event is dequeued or received. enum DequeueStatus The status returned as the result of an Actor dequeue operation. class EventGroup An object representing a long running context involving one or more actors. An EventGroup can be provided as an optional argument in CreateActor and SendEvent. If a null EventGroup is passed then the EventGroup is inherited from the sender or target actors (based on which ever one has a CurrentEventGroup ). In this way an EventGroup is automatically communicated to all actors involved in completing some larger operation. Each actor involved can find the EventGroup using their CurrentEventGroup property. class HaltEvent The halt event. interface IActorRuntime Interface that exposes runtime methods for creating and executing actors. interface IActorRuntimeLog Interface that allows an external module to track what is happening in the IActorRuntime . delegate OnEventDroppedHandler Handles the OnEventDropped event. enum OnExceptionOutcome The outcome when an Actor throws an exception. static class RuntimeFactory Provides methods for creating a IActorRuntime runtime. class SendOptions Represents a send event configuration that is used during testing. abstract class StateMachine Type that implements a state machine actor. Inherit from this class to declare a custom actor with states, state transitions and event handlers. class UnhandledEventException Signals that an Actor received an unhandled event. class WildCardEvent The wild card event.","title":"Namespace Overview"},{"location":"ref/Microsoft.Coyote.ActorsNamespace/#microsoftcoyoteactors-namespace","text":"public type description abstract class Actor Type that implements an actor. Inherit from this class to declare a custom actor. class ActorId Unique actor id. class ActorRuntimeLogTextFormatter This class implements IActorRuntimeLog and generates output in a a human readable text format. class AwaitableEventGroup<T> An object representing an awaitable long running context involving one or more actors. An AwaitableEventGroup can be provided as an optional argument in CreateActor and SendEvent. If a null AwaitableEventGroup is passed then the EventGroup is inherited from the sender or target actors (based on which ever one has a CurrentEventGroup ). In this way an AwaitableEventGroup is automatically communicated to all actors involved in completing some larger operation. Each actor involved can find the AwaitableEventGroup using their CurrentEventGroup property. class DefaultEvent A default event that is generated by the runtime when no user-defined event is dequeued or received. enum DequeueStatus The status returned as the result of an Actor dequeue operation. class EventGroup An object representing a long running context involving one or more actors. An EventGroup can be provided as an optional argument in CreateActor and SendEvent. If a null EventGroup is passed then the EventGroup is inherited from the sender or target actors (based on which ever one has a CurrentEventGroup ). In this way an EventGroup is automatically communicated to all actors involved in completing some larger operation. Each actor involved can find the EventGroup using their CurrentEventGroup property. class HaltEvent The halt event. interface IActorRuntime Interface that exposes runtime methods for creating and executing actors. interface IActorRuntimeLog Interface that allows an external module to track what is happening in the IActorRuntime . delegate OnEventDroppedHandler Handles the OnEventDropped event. enum OnExceptionOutcome The outcome when an Actor throws an exception. static class RuntimeFactory Provides methods for creating a IActorRuntime runtime. class SendOptions Represents a send event configuration that is used during testing. abstract class StateMachine Type that implements a state machine actor. Inherit from this class to declare a custom actor with states, state transitions and event handlers. class UnhandledEventException Signals that an Actor received an unhandled event. class WildCardEvent The wild card event.","title":"Microsoft.Coyote.Actors namespace"},{"location":"ref/Microsoft.Coyote.IONamespace/","text":"Microsoft.Coyote.IO namespace public type description class ConsoleLogger Logger that writes text to the console. interface ILogger A logger is used to capture messages, warnings and errors. class InMemoryLogger Thread safe logger that writes text to an in-memory buffer. The buffered text can be extracted using the ToString() method. enum LogSeverity Flag indicating the type of logging information being provided to the ILogger . class TextWriterLogger Bridges custom user provided TextWriter logger so it can be passed into Coyote via the ILogger interface.","title":"Namespace Overview"},{"location":"ref/Microsoft.Coyote.IONamespace/#microsoftcoyoteio-namespace","text":"public type description class ConsoleLogger Logger that writes text to the console. interface ILogger A logger is used to capture messages, warnings and errors. class InMemoryLogger Thread safe logger that writes text to an in-memory buffer. The buffered text can be extracted using the ToString() method. enum LogSeverity Flag indicating the type of logging information being provided to the ILogger . class TextWriterLogger Bridges custom user provided TextWriter logger so it can be passed into Coyote via the ILogger interface.","title":"Microsoft.Coyote.IO namespace"},{"location":"ref/Microsoft.Coyote.RandomNamespace/","text":"Microsoft.Coyote.Random namespace public type description class Generator Represents a pseudo-random value generator, which is an algorithm that produces a sequence of values that meet certain statistical requirements for randomness. During systematic testing, the generation of random values is controlled, which allows the runtime to explore combinations of choices to find bugs.","title":"Namespace Overview"},{"location":"ref/Microsoft.Coyote.RandomNamespace/#microsoftcoyoterandom-namespace","text":"public type description class Generator Represents a pseudo-random value generator, which is an algorithm that produces a sequence of values that meet certain statistical requirements for randomness. During systematic testing, the generation of random values is controlled, which allows the runtime to explore combinations of choices to find bugs.","title":"Microsoft.Coyote.Random namespace"},{"location":"ref/Microsoft.Coyote.RewritingNamespace/","text":"Microsoft.Coyote.Rewriting namespace public type description class IsAssemblyRewrittenAttribute Attribute for checking if an assembly has been rewritten by Coyote. If this attribute is applied to an assembly, it denotes that the assembly has been rewritten. class RewritingEngine Engine that can rewrite a set of assemblies for systematic testing. class RewritingOptions Options for rewriting binaries.","title":"Namespace Overview"},{"location":"ref/Microsoft.Coyote.RewritingNamespace/#microsoftcoyoterewriting-namespace","text":"public type description class IsAssemblyRewrittenAttribute Attribute for checking if an assembly has been rewritten by Coyote. If this attribute is applied to an assembly, it denotes that the assembly has been rewritten. class RewritingEngine Engine that can rewrite a set of assemblies for systematic testing. class RewritingOptions Options for rewriting binaries.","title":"Microsoft.Coyote.Rewriting namespace"},{"location":"ref/Microsoft.Coyote.RuntimeNamespace/","text":"Microsoft.Coyote.Runtime namespace public type description class AssertionFailureException The exception that is thrown by the Coyote runtime upon assertion failure. class ExecutionCanceledException Exception that is thrown upon cancellation of testing execution by the runtime. interface ICoyoteRuntime Interface that exposes base runtime methods for Coyote. delegate OnFailureHandler Handles the OnFailure event. class RuntimeException An exception that is thrown by the Coyote runtime. static class RuntimeFactory Provides methods for creating a ICoyoteRuntime runtime. static class SchedulingPoint Provides a set of static methods for declaring points in the execution where interleavings between operations should be explored during testing.","title":"Namespace Overview"},{"location":"ref/Microsoft.Coyote.RuntimeNamespace/#microsoftcoyoteruntime-namespace","text":"public type description class AssertionFailureException The exception that is thrown by the Coyote runtime upon assertion failure. class ExecutionCanceledException Exception that is thrown upon cancellation of testing execution by the runtime. interface ICoyoteRuntime Interface that exposes base runtime methods for Coyote. delegate OnFailureHandler Handles the OnFailure event. class RuntimeException An exception that is thrown by the Coyote runtime. static class RuntimeFactory Provides methods for creating a ICoyoteRuntime runtime. static class SchedulingPoint Provides a set of static methods for declaring points in the execution where interleavings between operations should be explored during testing.","title":"Microsoft.Coyote.Runtime namespace"},{"location":"ref/Microsoft.Coyote.SpecificationsNamespace/","text":"Microsoft.Coyote.Specifications namespace public type description abstract class Monitor Abstract class representing a specification monitor. static class Specification Provides static methods that are useful for writing specifications and interacting with the systematic testing engine.","title":"Namespace Overview"},{"location":"ref/Microsoft.Coyote.SpecificationsNamespace/#microsoftcoyotespecifications-namespace","text":"public type description abstract class Monitor Abstract class representing a specification monitor. static class Specification Provides static methods that are useful for writing specifications and interacting with the systematic testing engine.","title":"Microsoft.Coyote.Specifications namespace"},{"location":"ref/Microsoft.Coyote.SystematicTestingNamespace/","text":"Microsoft.Coyote.SystematicTesting namespace public type description class TestAttribute Attribute for declaring the entry point to a Coyote test. class TestDisposeAttribute Attribute for declaring a cleanup method to be called when all test iterations terminate. class TestingEngine Testing engine that can run a controlled concurrency test using a specified configuration. class TestInitAttribute Attribute for declaring the initialization method to be called before testing starts. class TestIterationDisposeAttribute Attribute for declaring a cleanup method to be called when each test iteration terminates. class TestReport Class implementing the Coyote test report.","title":"Namespace Overview"},{"location":"ref/Microsoft.Coyote.SystematicTestingNamespace/#microsoftcoyotesystematictesting-namespace","text":"public type description class TestAttribute Attribute for declaring the entry point to a Coyote test. class TestDisposeAttribute Attribute for declaring a cleanup method to be called when all test iterations terminate. class TestingEngine Testing engine that can run a controlled concurrency test using a specified configuration. class TestInitAttribute Attribute for declaring the initialization method to be called before testing starts. class TestIterationDisposeAttribute Attribute for declaring a cleanup method to be called when each test iteration terminates. class TestReport Class implementing the Coyote test report.","title":"Microsoft.Coyote.SystematicTesting namespace"},{"location":"ref/Microsoft.Coyote.TasksNamespace/","text":"Microsoft.Coyote.Tasks namespace public type description class AsyncLock A non-reentrant mutual exclusion lock that can be acquired asynchronously in a first-in first-out order. During testing, the lock is automatically replaced with a controlled mocked version. class Semaphore A semaphore that limits the number of tasks that can access a resource. During testing, the semaphore is automatically replaced with a controlled mocked version. class SynchronizedBlock Provides a mechanism that synchronizes access to objects. It is implemented as a thin wrapper on Monitor. During testing, the implementation is automatically replaced with a controlled mocked version. It can be used as a replacement of the lock keyword to allow systematic testing. class Task<TResult> Represents an asynchronous operation that can return a value. Each Task is a thin wrapper over Task and each call simply invokes the wrapped task. During testing, a Task is controlled by the runtime and systematically interleaved with other asynchronous operations to find bugs. class Task Represents an asynchronous operation. Each Task is a thin wrapper over Task and each call simply invokes the wrapped task. During testing, a Task is controlled by the runtime and systematically interleaved with other asynchronous operations to find bugs. class TaskCompletionSource<TResult> Represents the producer side of a task unbound to a delegate, providing access to the consumer side through the Task property. static class TaskCompletionSource Represents the producer side of a task unbound to a delegate, providing access to the consumer side through the Task property. static class TaskExtensions Extension methods for Task and Task objects.","title":"Namespace Overview"},{"location":"ref/Microsoft.Coyote.TasksNamespace/#microsoftcoyotetasks-namespace","text":"public type description class AsyncLock A non-reentrant mutual exclusion lock that can be acquired asynchronously in a first-in first-out order. During testing, the lock is automatically replaced with a controlled mocked version. class Semaphore A semaphore that limits the number of tasks that can access a resource. During testing, the semaphore is automatically replaced with a controlled mocked version. class SynchronizedBlock Provides a mechanism that synchronizes access to objects. It is implemented as a thin wrapper on Monitor. During testing, the implementation is automatically replaced with a controlled mocked version. It can be used as a replacement of the lock keyword to allow systematic testing. class Task<TResult> Represents an asynchronous operation that can return a value. Each Task is a thin wrapper over Task and each call simply invokes the wrapped task. During testing, a Task is controlled by the runtime and systematically interleaved with other asynchronous operations to find bugs. class Task Represents an asynchronous operation. Each Task is a thin wrapper over Task and each call simply invokes the wrapped task. During testing, a Task is controlled by the runtime and systematically interleaved with other asynchronous operations to find bugs. class TaskCompletionSource<TResult> Represents the producer side of a task unbound to a delegate, providing access to the consumer side through the Task property. static class TaskCompletionSource Represents the producer side of a task unbound to a delegate, providing access to the consumer side through the Task property. static class TaskExtensions Extension methods for Task and Task objects.","title":"Microsoft.Coyote.Tasks namespace"},{"location":"ref/Microsoft.Coyote.Test/","text":"Microsoft.Coyote.Test assembly Microsoft.Coyote.Rewriting namespace public type description class IsAssemblyRewrittenAttribute Attribute for checking if an assembly has been rewritten by Coyote. If this attribute is applied to an assembly, it denotes that the assembly has been rewritten. class RewritingEngine Engine that can rewrite a set of assemblies for systematic testing. class RewritingOptions Options for rewriting binaries. Microsoft.Coyote.SystematicTesting namespace public type description class TestAttribute Attribute for declaring the entry point to a Coyote test. class TestDisposeAttribute Attribute for declaring a cleanup method to be called when all test iterations terminate. class TestingEngine Testing engine that can run a controlled concurrency test using a specified configuration. class TestInitAttribute Attribute for declaring the initialization method to be called before testing starts. class TestIterationDisposeAttribute Attribute for declaring a cleanup method to be called when each test iteration terminates. class TestReport Class implementing the Coyote test report.","title":"Overview"},{"location":"ref/Microsoft.Coyote.Test/#microsoftcoyotetest-assembly","text":"","title":"Microsoft.Coyote.Test assembly"},{"location":"ref/Microsoft.Coyote.Test/#microsoftcoyoterewriting-namespace","text":"public type description class IsAssemblyRewrittenAttribute Attribute for checking if an assembly has been rewritten by Coyote. If this attribute is applied to an assembly, it denotes that the assembly has been rewritten. class RewritingEngine Engine that can rewrite a set of assemblies for systematic testing. class RewritingOptions Options for rewriting binaries.","title":"Microsoft.Coyote.Rewriting namespace"},{"location":"ref/Microsoft.Coyote.Test/#microsoftcoyotesystematictesting-namespace","text":"public type description class TestAttribute Attribute for declaring the entry point to a Coyote test. class TestDisposeAttribute Attribute for declaring a cleanup method to be called when all test iterations terminate. class TestingEngine Testing engine that can run a controlled concurrency test using a specified configuration. class TestInitAttribute Attribute for declaring the initialization method to be called before testing starts. class TestIterationDisposeAttribute Attribute for declaring a cleanup method to be called when each test iteration terminates. class TestReport Class implementing the Coyote test report.","title":"Microsoft.Coyote.SystematicTesting namespace"},{"location":"ref/Microsoft.Coyote/","text":"Microsoft.Coyote assembly Microsoft.Coyote namespace public type description class Configuration The Coyote project configurations. abstract class Event Abstract class representing an event. Microsoft.Coyote.Actors namespace public type description abstract class Actor Type that implements an actor. Inherit from this class to declare a custom actor. class ActorId Unique actor id. class ActorRuntimeLogTextFormatter This class implements IActorRuntimeLog and generates output in a a human readable text format. class AwaitableEventGroup<T> An object representing an awaitable long running context involving one or more actors. An AwaitableEventGroup can be provided as an optional argument in CreateActor and SendEvent. If a null AwaitableEventGroup is passed then the EventGroup is inherited from the sender or target actors (based on which ever one has a CurrentEventGroup ). In this way an AwaitableEventGroup is automatically communicated to all actors involved in completing some larger operation. Each actor involved can find the AwaitableEventGroup using their CurrentEventGroup property. class DefaultEvent A default event that is generated by the runtime when no user-defined event is dequeued or received. enum DequeueStatus The status returned as the result of an Actor dequeue operation. class EventGroup An object representing a long running context involving one or more actors. An EventGroup can be provided as an optional argument in CreateActor and SendEvent. If a null EventGroup is passed then the EventGroup is inherited from the sender or target actors (based on which ever one has a CurrentEventGroup ). In this way an EventGroup is automatically communicated to all actors involved in completing some larger operation. Each actor involved can find the EventGroup using their CurrentEventGroup property. class HaltEvent The halt event. interface IActorRuntime Interface that exposes runtime methods for creating and executing actors. interface IActorRuntimeLog Interface that allows an external module to track what is happening in the IActorRuntime . delegate OnEventDroppedHandler Handles the OnEventDropped event. enum OnExceptionOutcome The outcome when an Actor throws an exception. static class RuntimeFactory Provides methods for creating a IActorRuntime runtime. class SendOptions Represents a send event configuration that is used during testing. abstract class StateMachine Type that implements a state machine actor. Inherit from this class to declare a custom actor with states, state transitions and event handlers. class UnhandledEventException Signals that an Actor received an unhandled event. class WildCardEvent The wild card event. Microsoft.Coyote.Actors.Coverage namespace public type description class ActorRuntimeLogGraphBuilder Implements the IActorRuntimeLog and builds a directed graph from the recorded events and state transitions. class CoverageInfo Class for storing actor coverage-specific data across multiple testing iterations. class EventCoverage This class maintains information about events received and sent from each state of each actor. class Graph A directed graph made up of Nodes and Links. class GraphLink A Link represents a directed graph connection between two Nodes. class GraphNode A Node of a Graph. class GraphObject A Node of a Graph. Microsoft.Coyote.Actors.SharedObjects namespace public type description class SharedCounter A thread-safe counter that can be shared in-memory by actors. class SharedDictionary<TKey,TValue> A thread-safe dictionary that can be shared in-memory by actors. static class SharedDictionary A thread-safe dictionary that can be shared in-memory by actors. class SharedRegister<T> A thread-safe register that can be shared in-memory by actors. static class SharedRegister A thread-safe register that can be shared in-memory by actors. Microsoft.Coyote.Actors.Timers namespace public type description class TimerElapsedEvent Defines a timer elapsed event that is sent from a timer to the actor that owns the timer. class TimerInfo Stores information about a timer that can send timeout events to its owner actor. Microsoft.Coyote.IO namespace public type description class ConsoleLogger Logger that writes text to the console. interface ILogger A logger is used to capture messages, warnings and errors. class InMemoryLogger Thread safe logger that writes text to an in-memory buffer. The buffered text can be extracted using the ToString() method. enum LogSeverity Flag indicating the type of logging information being provided to the ILogger . class TextWriterLogger Bridges custom user provided TextWriter logger so it can be passed into Coyote via the ILogger interface. Microsoft.Coyote.Random namespace public type description class Generator Represents a pseudo-random value generator, which is an algorithm that produces a sequence of values that meet certain statistical requirements for randomness. During systematic testing, the generation of random values is controlled, which allows the runtime to explore combinations of choices to find bugs. Microsoft.Coyote.Runtime namespace public type description class AssertionFailureException The exception that is thrown by the Coyote runtime upon assertion failure. class ExecutionCanceledException Exception that is thrown upon cancellation of testing execution by the runtime. interface ICoyoteRuntime Interface that exposes base runtime methods for Coyote. delegate OnFailureHandler Handles the OnFailure event. class RuntimeException An exception that is thrown by the Coyote runtime. static class RuntimeFactory Provides methods for creating a ICoyoteRuntime runtime. static class SchedulingPoint Provides a set of static methods for declaring points in the execution where interleavings between operations should be explored during testing. Microsoft.Coyote.Specifications namespace public type description abstract class Monitor Abstract class representing a specification monitor. static class Specification Provides static methods that are useful for writing specifications and interacting with the systematic testing engine. Microsoft.Coyote.Tasks namespace public type description class AsyncLock A non-reentrant mutual exclusion lock that can be acquired asynchronously in a first-in first-out order. During testing, the lock is automatically replaced with a controlled mocked version. class Semaphore A semaphore that limits the number of tasks that can access a resource. During testing, the semaphore is automatically replaced with a controlled mocked version. class SynchronizedBlock Provides a mechanism that synchronizes access to objects. It is implemented as a thin wrapper on Monitor. During testing, the implementation is automatically replaced with a controlled mocked version. It can be used as a replacement of the lock keyword to allow systematic testing. class Task<TResult> Represents an asynchronous operation that can return a value. Each Task is a thin wrapper over Task and each call simply invokes the wrapped task. During testing, a Task is controlled by the runtime and systematically interleaved with other asynchronous operations to find bugs. class Task Represents an asynchronous operation. Each Task is a thin wrapper over Task and each call simply invokes the wrapped task. During testing, a Task is controlled by the runtime and systematically interleaved with other asynchronous operations to find bugs. class TaskCompletionSource<TResult> Represents the producer side of a task unbound to a delegate, providing access to the consumer side through the Task property. static class TaskCompletionSource Represents the producer side of a task unbound to a delegate, providing access to the consumer side through the Task property. static class TaskExtensions Extension methods for Task and Task objects.","title":"Overview"},{"location":"ref/Microsoft.Coyote/#microsoftcoyote-assembly","text":"","title":"Microsoft.Coyote assembly"},{"location":"ref/Microsoft.Coyote/#microsoftcoyote-namespace","text":"public type description class Configuration The Coyote project configurations. abstract class Event Abstract class representing an event.","title":"Microsoft.Coyote namespace"},{"location":"ref/Microsoft.Coyote/#microsoftcoyoteactors-namespace","text":"public type description abstract class Actor Type that implements an actor. Inherit from this class to declare a custom actor. class ActorId Unique actor id. class ActorRuntimeLogTextFormatter This class implements IActorRuntimeLog and generates output in a a human readable text format. class AwaitableEventGroup<T> An object representing an awaitable long running context involving one or more actors. An AwaitableEventGroup can be provided as an optional argument in CreateActor and SendEvent. If a null AwaitableEventGroup is passed then the EventGroup is inherited from the sender or target actors (based on which ever one has a CurrentEventGroup ). In this way an AwaitableEventGroup is automatically communicated to all actors involved in completing some larger operation. Each actor involved can find the AwaitableEventGroup using their CurrentEventGroup property. class DefaultEvent A default event that is generated by the runtime when no user-defined event is dequeued or received. enum DequeueStatus The status returned as the result of an Actor dequeue operation. class EventGroup An object representing a long running context involving one or more actors. An EventGroup can be provided as an optional argument in CreateActor and SendEvent. If a null EventGroup is passed then the EventGroup is inherited from the sender or target actors (based on which ever one has a CurrentEventGroup ). In this way an EventGroup is automatically communicated to all actors involved in completing some larger operation. Each actor involved can find the EventGroup using their CurrentEventGroup property. class HaltEvent The halt event. interface IActorRuntime Interface that exposes runtime methods for creating and executing actors. interface IActorRuntimeLog Interface that allows an external module to track what is happening in the IActorRuntime . delegate OnEventDroppedHandler Handles the OnEventDropped event. enum OnExceptionOutcome The outcome when an Actor throws an exception. static class RuntimeFactory Provides methods for creating a IActorRuntime runtime. class SendOptions Represents a send event configuration that is used during testing. abstract class StateMachine Type that implements a state machine actor. Inherit from this class to declare a custom actor with states, state transitions and event handlers. class UnhandledEventException Signals that an Actor received an unhandled event. class WildCardEvent The wild card event.","title":"Microsoft.Coyote.Actors namespace"},{"location":"ref/Microsoft.Coyote/#microsoftcoyoteactorscoverage-namespace","text":"public type description class ActorRuntimeLogGraphBuilder Implements the IActorRuntimeLog and builds a directed graph from the recorded events and state transitions. class CoverageInfo Class for storing actor coverage-specific data across multiple testing iterations. class EventCoverage This class maintains information about events received and sent from each state of each actor. class Graph A directed graph made up of Nodes and Links. class GraphLink A Link represents a directed graph connection between two Nodes. class GraphNode A Node of a Graph. class GraphObject A Node of a Graph.","title":"Microsoft.Coyote.Actors.Coverage namespace"},{"location":"ref/Microsoft.Coyote/#microsoftcoyoteactorssharedobjects-namespace","text":"public type description class SharedCounter A thread-safe counter that can be shared in-memory by actors. class SharedDictionary<TKey,TValue> A thread-safe dictionary that can be shared in-memory by actors. static class SharedDictionary A thread-safe dictionary that can be shared in-memory by actors. class SharedRegister<T> A thread-safe register that can be shared in-memory by actors. static class SharedRegister A thread-safe register that can be shared in-memory by actors.","title":"Microsoft.Coyote.Actors.SharedObjects namespace"},{"location":"ref/Microsoft.Coyote/#microsoftcoyoteactorstimers-namespace","text":"public type description class TimerElapsedEvent Defines a timer elapsed event that is sent from a timer to the actor that owns the timer. class TimerInfo Stores information about a timer that can send timeout events to its owner actor.","title":"Microsoft.Coyote.Actors.Timers namespace"},{"location":"ref/Microsoft.Coyote/#microsoftcoyoteio-namespace","text":"public type description class ConsoleLogger Logger that writes text to the console. interface ILogger A logger is used to capture messages, warnings and errors. class InMemoryLogger Thread safe logger that writes text to an in-memory buffer. The buffered text can be extracted using the ToString() method. enum LogSeverity Flag indicating the type of logging information being provided to the ILogger . class TextWriterLogger Bridges custom user provided TextWriter logger so it can be passed into Coyote via the ILogger interface.","title":"Microsoft.Coyote.IO namespace"},{"location":"ref/Microsoft.Coyote/#microsoftcoyoterandom-namespace","text":"public type description class Generator Represents a pseudo-random value generator, which is an algorithm that produces a sequence of values that meet certain statistical requirements for randomness. During systematic testing, the generation of random values is controlled, which allows the runtime to explore combinations of choices to find bugs.","title":"Microsoft.Coyote.Random namespace"},{"location":"ref/Microsoft.Coyote/#microsoftcoyoteruntime-namespace","text":"public type description class AssertionFailureException The exception that is thrown by the Coyote runtime upon assertion failure. class ExecutionCanceledException Exception that is thrown upon cancellation of testing execution by the runtime. interface ICoyoteRuntime Interface that exposes base runtime methods for Coyote. delegate OnFailureHandler Handles the OnFailure event. class RuntimeException An exception that is thrown by the Coyote runtime. static class RuntimeFactory Provides methods for creating a ICoyoteRuntime runtime. static class SchedulingPoint Provides a set of static methods for declaring points in the execution where interleavings between operations should be explored during testing.","title":"Microsoft.Coyote.Runtime namespace"},{"location":"ref/Microsoft.Coyote/#microsoftcoyotespecifications-namespace","text":"public type description abstract class Monitor Abstract class representing a specification monitor. static class Specification Provides static methods that are useful for writing specifications and interacting with the systematic testing engine.","title":"Microsoft.Coyote.Specifications namespace"},{"location":"ref/Microsoft.Coyote/#microsoftcoyotetasks-namespace","text":"public type description class AsyncLock A non-reentrant mutual exclusion lock that can be acquired asynchronously in a first-in first-out order. During testing, the lock is automatically replaced with a controlled mocked version. class Semaphore A semaphore that limits the number of tasks that can access a resource. During testing, the semaphore is automatically replaced with a controlled mocked version. class SynchronizedBlock Provides a mechanism that synchronizes access to objects. It is implemented as a thin wrapper on Monitor. During testing, the implementation is automatically replaced with a controlled mocked version. It can be used as a replacement of the lock keyword to allow systematic testing. class Task<TResult> Represents an asynchronous operation that can return a value. Each Task is a thin wrapper over Task and each call simply invokes the wrapped task. During testing, a Task is controlled by the runtime and systematically interleaved with other asynchronous operations to find bugs. class Task Represents an asynchronous operation. Each Task is a thin wrapper over Task and each call simply invokes the wrapped task. During testing, a Task is controlled by the runtime and systematically interleaved with other asynchronous operations to find bugs. class TaskCompletionSource<TResult> Represents the producer side of a task unbound to a delegate, providing access to the consumer side through the Task property. static class TaskCompletionSource Represents the producer side of a task unbound to a delegate, providing access to the consumer side through the Task property. static class TaskExtensions Extension methods for Task and Task objects.","title":"Microsoft.Coyote.Tasks namespace"},{"location":"ref/Microsoft.CoyoteNamespace/","text":"Microsoft.Coyote namespace public type description class Configuration The Coyote project configurations. abstract class Event Abstract class representing an event.","title":"Namespace Overview"},{"location":"ref/Microsoft.CoyoteNamespace/#microsoftcoyote-namespace","text":"public type description class Configuration The Coyote project configurations. abstract class Event Abstract class representing an event.","title":"Microsoft.Coyote namespace"},{"location":"ref/Microsoft.Coyote/Configuration/","text":"Configuration class The Coyote project configurations. public class Configuration Public Members name description static Create () Creates a new configuration with default values. IsDgmlGraphEnabled { get; } If specified, requests a DGML graph of the iteration that contains a bug, if a bug is found. This is different from a coverage activity graph, as it will also show actor instances. IsVerbose { get; } If true, then messages are logged. IsXmlLogEnabled { get; } Produce an XML formatted runtime log file. LivenessTemperatureThreshold { get; } The liveness temperature threshold. If it is 0 then it is disabled. By default this value is assigned to MaxFairSchedulingSteps / 2. LogLevel { get; } The level of detail to provide in verbose logging. MaxFairSchedulingSteps { get; } The maximum scheduling steps to explore for fair schedulers. By default this is set to 100,000 steps. MaxUnfairSchedulingSteps { get; } The maximum scheduling steps to explore for unfair schedulers. By default this is set to 10,000 steps. RandomGeneratorSeed { get; } Custom seed to be used by the random value generator. By default, this value is null indicating that no seed has been set. ReportActivityCoverage { get; } Enables activity coverage reporting of a Coyote program. SchedulingStrategy { get; } The systematic testing strategy to use. StrategyBound { get; } A strategy-specific bound. TestingIterations { get; } Number of testing iterations. TimeoutDelay { get; } Value that controls the probability of triggering a timeout each time Int32) or a built-in timer is scheduled during systematic testing. Decrease the value to increase the frequency of timeouts (e.g. a value of 1 corresponds to a 50% probability), or increase the value to decrease the frequency (e.g. a value of 10 corresponds to a 10% probability). By default this value is 10. WithActivityCoverageEnabled (\u2026) Updates the configuration with activity coverage enabled or disabled. WithConcurrencyFuzzingEnabled (\u2026) Updates the configuration with concurrency fuzzing enabled or disabled. WithDeadlockTimeout (\u2026) Updates the DeadlockTimeout value that controls how much time the deadlock monitor should wait during concurrency fuzzing before reporting a potential deadlock. WithDgmlGraphEnabled (\u2026) Updates the configuration with DGML graph generation enabled or disabled. WithLivenessTemperatureThreshold (\u2026) Updates the configuration with the specified liveness temperature threshold during systematic testing. If this value is 0 it disables liveness checking. It is not recommended to explicitly set this value, instead use the default value which is assigned to MaxFairSchedulingSteps / 2. WithMaxSchedulingSteps (\u2026) Updates the configuration with the specified number of maximum scheduling steps to explore per iteration during systematic testing. The MaxUnfairSchedulingSteps is assigned the maxSteps value, whereas the MaxFairSchedulingSteps is assigned a value using the default heuristic, which is 10 * maxSteps . (2 methods) WithNoBugTraceRepro (\u2026) Updates the configuration with the ability to reproduce bug traces enabled or disabled. Disabling reproducibility allows skipping errors due to uncontrolled concurrency, for example when the program is only partially rewritten, or there is external concurrency that is not mocked, or when the program uses an API that is not yet supported. WithPCTStrategy (\u2026) Updates the configuration to use the PCT scheduling strategy during systematic testing. You can specify the number of priority switch points, which by default are 10. WithProbabilisticStrategy (\u2026) Updates the configuration to use the probabilistic scheduling strategy during systematic testing. You can specify a value controlling the probability of each scheduling decision. This value is specified as the integer N in the equation 0.5 to the power of N. So for N=1, the probability is 0.5, for N=2 the probability is 0.25, N=3 you get 0.125, etc. By default, this value is 3. WithRandomGeneratorSeed (\u2026) Updates the seed used by the random value generator during systematic testing. WithRandomStrategy () Updates the configuration to use the random scheduling strategy during systematic testing. WithRelaxedControlledTestingEnabled (\u2026) Updates the configuration with relaxed controlled testing enabled or disabled. If this option is enabled, systematic testing supports partially controlled executions. WithReplayStrategy (\u2026) Updates the configuration to use the replay scheduling strategy during systematic testing. This strategy replays the specified schedule trace to reproduce the same execution. WithRLStrategy () Updates the configuration to use the reinforcement learning (RL) scheduling strategy during systematic testing. WithTelemetryEnabled (\u2026) Updates the configuration with telemetry enabled or disabled. WithTestingIterations (\u2026) Updates the configuration with the specified number of iterations to run during systematic testing. WithTestingTimeout (\u2026) Updates the configuration with the specified systematic testing timeout in seconds. WithTimeoutDelay (\u2026) Updates the TimeoutDelay value that controls the probability of triggering a timeout each time Int32) or a built-in timer is scheduled during systematic testing. WithVerbosityEnabled (\u2026) Updates the configuration with verbose output enabled or disabled. WithXmlLogEnabled (\u2026) Updates the configuration with XML log generation enabled or disabled. Protected Members name description Configuration () Initializes a new instance of the Configuration class. See Also namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote/Configuration/#configuration-class","text":"The Coyote project configurations. public class Configuration","title":"Configuration class"},{"location":"ref/Microsoft.Coyote/Configuration/#public-members","text":"name description static Create () Creates a new configuration with default values. IsDgmlGraphEnabled { get; } If specified, requests a DGML graph of the iteration that contains a bug, if a bug is found. This is different from a coverage activity graph, as it will also show actor instances. IsVerbose { get; } If true, then messages are logged. IsXmlLogEnabled { get; } Produce an XML formatted runtime log file. LivenessTemperatureThreshold { get; } The liveness temperature threshold. If it is 0 then it is disabled. By default this value is assigned to MaxFairSchedulingSteps / 2. LogLevel { get; } The level of detail to provide in verbose logging. MaxFairSchedulingSteps { get; } The maximum scheduling steps to explore for fair schedulers. By default this is set to 100,000 steps. MaxUnfairSchedulingSteps { get; } The maximum scheduling steps to explore for unfair schedulers. By default this is set to 10,000 steps. RandomGeneratorSeed { get; } Custom seed to be used by the random value generator. By default, this value is null indicating that no seed has been set. ReportActivityCoverage { get; } Enables activity coverage reporting of a Coyote program. SchedulingStrategy { get; } The systematic testing strategy to use. StrategyBound { get; } A strategy-specific bound. TestingIterations { get; } Number of testing iterations. TimeoutDelay { get; } Value that controls the probability of triggering a timeout each time Int32) or a built-in timer is scheduled during systematic testing. Decrease the value to increase the frequency of timeouts (e.g. a value of 1 corresponds to a 50% probability), or increase the value to decrease the frequency (e.g. a value of 10 corresponds to a 10% probability). By default this value is 10. WithActivityCoverageEnabled (\u2026) Updates the configuration with activity coverage enabled or disabled. WithConcurrencyFuzzingEnabled (\u2026) Updates the configuration with concurrency fuzzing enabled or disabled. WithDeadlockTimeout (\u2026) Updates the DeadlockTimeout value that controls how much time the deadlock monitor should wait during concurrency fuzzing before reporting a potential deadlock. WithDgmlGraphEnabled (\u2026) Updates the configuration with DGML graph generation enabled or disabled. WithLivenessTemperatureThreshold (\u2026) Updates the configuration with the specified liveness temperature threshold during systematic testing. If this value is 0 it disables liveness checking. It is not recommended to explicitly set this value, instead use the default value which is assigned to MaxFairSchedulingSteps / 2. WithMaxSchedulingSteps (\u2026) Updates the configuration with the specified number of maximum scheduling steps to explore per iteration during systematic testing. The MaxUnfairSchedulingSteps is assigned the maxSteps value, whereas the MaxFairSchedulingSteps is assigned a value using the default heuristic, which is 10 * maxSteps . (2 methods) WithNoBugTraceRepro (\u2026) Updates the configuration with the ability to reproduce bug traces enabled or disabled. Disabling reproducibility allows skipping errors due to uncontrolled concurrency, for example when the program is only partially rewritten, or there is external concurrency that is not mocked, or when the program uses an API that is not yet supported. WithPCTStrategy (\u2026) Updates the configuration to use the PCT scheduling strategy during systematic testing. You can specify the number of priority switch points, which by default are 10. WithProbabilisticStrategy (\u2026) Updates the configuration to use the probabilistic scheduling strategy during systematic testing. You can specify a value controlling the probability of each scheduling decision. This value is specified as the integer N in the equation 0.5 to the power of N. So for N=1, the probability is 0.5, for N=2 the probability is 0.25, N=3 you get 0.125, etc. By default, this value is 3. WithRandomGeneratorSeed (\u2026) Updates the seed used by the random value generator during systematic testing. WithRandomStrategy () Updates the configuration to use the random scheduling strategy during systematic testing. WithRelaxedControlledTestingEnabled (\u2026) Updates the configuration with relaxed controlled testing enabled or disabled. If this option is enabled, systematic testing supports partially controlled executions. WithReplayStrategy (\u2026) Updates the configuration to use the replay scheduling strategy during systematic testing. This strategy replays the specified schedule trace to reproduce the same execution. WithRLStrategy () Updates the configuration to use the reinforcement learning (RL) scheduling strategy during systematic testing. WithTelemetryEnabled (\u2026) Updates the configuration with telemetry enabled or disabled. WithTestingIterations (\u2026) Updates the configuration with the specified number of iterations to run during systematic testing. WithTestingTimeout (\u2026) Updates the configuration with the specified systematic testing timeout in seconds. WithTimeoutDelay (\u2026) Updates the TimeoutDelay value that controls the probability of triggering a timeout each time Int32) or a built-in timer is scheduled during systematic testing. WithVerbosityEnabled (\u2026) Updates the configuration with verbose output enabled or disabled. WithXmlLogEnabled (\u2026) Updates the configuration with XML log generation enabled or disabled.","title":"Public Members"},{"location":"ref/Microsoft.Coyote/Configuration/#protected-members","text":"name description Configuration () Initializes a new instance of the Configuration class.","title":"Protected Members"},{"location":"ref/Microsoft.Coyote/Configuration/#see-also","text":"namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Event/","text":"Event class Abstract class representing an event. public abstract class Event Protected Members name description Event () The default constructor. Remarks See Programming model: asynchronous actors for more information. See Also namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote/Event/#event-class","text":"Abstract class representing an event. public abstract class Event","title":"Event class"},{"location":"ref/Microsoft.Coyote/Event/#protected-members","text":"name description Event () The default constructor.","title":"Protected Members"},{"location":"ref/Microsoft.Coyote/Event/#remarks","text":"See Programming model: asynchronous actors for more information.","title":"Remarks"},{"location":"ref/Microsoft.Coyote/Event/#see-also","text":"namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Configuration/Configuration/","text":"Configuration constructor Initializes a new instance of the Configuration class. protected Configuration() See Also class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"Configuration"},{"location":"ref/Microsoft.Coyote/Configuration/Configuration/#configuration-constructor","text":"Initializes a new instance of the Configuration class. protected Configuration()","title":"Configuration constructor"},{"location":"ref/Microsoft.Coyote/Configuration/Configuration/#see-also","text":"class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Configuration/Create/","text":"Configuration.Create method Creates a new configuration with default values. public static Configuration Create() See Also class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"Create"},{"location":"ref/Microsoft.Coyote/Configuration/Create/#configurationcreate-method","text":"Creates a new configuration with default values. public static Configuration Create()","title":"Configuration.Create method"},{"location":"ref/Microsoft.Coyote/Configuration/Create/#see-also","text":"class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Configuration/IsDgmlGraphEnabled/","text":"Configuration.IsDgmlGraphEnabled property If specified, requests a DGML graph of the iteration that contains a bug, if a bug is found. This is different from a coverage activity graph, as it will also show actor instances. public bool IsDgmlGraphEnabled { get; } See Also class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"IsDgmlGraphEnabled"},{"location":"ref/Microsoft.Coyote/Configuration/IsDgmlGraphEnabled/#configurationisdgmlgraphenabled-property","text":"If specified, requests a DGML graph of the iteration that contains a bug, if a bug is found. This is different from a coverage activity graph, as it will also show actor instances. public bool IsDgmlGraphEnabled { get; }","title":"Configuration.IsDgmlGraphEnabled property"},{"location":"ref/Microsoft.Coyote/Configuration/IsDgmlGraphEnabled/#see-also","text":"class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Configuration/IsVerbose/","text":"Configuration.IsVerbose property If true, then messages are logged. public bool IsVerbose { get; } See Also class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"IsVerbose"},{"location":"ref/Microsoft.Coyote/Configuration/IsVerbose/#configurationisverbose-property","text":"If true, then messages are logged. public bool IsVerbose { get; }","title":"Configuration.IsVerbose property"},{"location":"ref/Microsoft.Coyote/Configuration/IsVerbose/#see-also","text":"class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Configuration/IsXmlLogEnabled/","text":"Configuration.IsXmlLogEnabled property Produce an XML formatted runtime log file. public bool IsXmlLogEnabled { get; } See Also class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"IsXmlLogEnabled"},{"location":"ref/Microsoft.Coyote/Configuration/IsXmlLogEnabled/#configurationisxmllogenabled-property","text":"Produce an XML formatted runtime log file. public bool IsXmlLogEnabled { get; }","title":"Configuration.IsXmlLogEnabled property"},{"location":"ref/Microsoft.Coyote/Configuration/IsXmlLogEnabled/#see-also","text":"class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Configuration/LivenessTemperatureThreshold/","text":"Configuration.LivenessTemperatureThreshold property The liveness temperature threshold. If it is 0 then it is disabled. By default this value is assigned to MaxFairSchedulingSteps / 2. public int LivenessTemperatureThreshold { get; } See Also class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"LivenessTemperatureThreshold"},{"location":"ref/Microsoft.Coyote/Configuration/LivenessTemperatureThreshold/#configurationlivenesstemperaturethreshold-property","text":"The liveness temperature threshold. If it is 0 then it is disabled. By default this value is assigned to MaxFairSchedulingSteps / 2. public int LivenessTemperatureThreshold { get; }","title":"Configuration.LivenessTemperatureThreshold property"},{"location":"ref/Microsoft.Coyote/Configuration/LivenessTemperatureThreshold/#see-also","text":"class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Configuration/LogLevel/","text":"Configuration.LogLevel property The level of detail to provide in verbose logging. public LogSeverity LogLevel { get; } See Also enum LogSeverity class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"LogLevel"},{"location":"ref/Microsoft.Coyote/Configuration/LogLevel/#configurationloglevel-property","text":"The level of detail to provide in verbose logging. public LogSeverity LogLevel { get; }","title":"Configuration.LogLevel property"},{"location":"ref/Microsoft.Coyote/Configuration/LogLevel/#see-also","text":"enum LogSeverity class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Configuration/MaxFairSchedulingSteps/","text":"Configuration.MaxFairSchedulingSteps property The maximum scheduling steps to explore for fair schedulers. By default this is set to 100,000 steps. public int MaxFairSchedulingSteps { get; } See Also class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"MaxFairSchedulingSteps"},{"location":"ref/Microsoft.Coyote/Configuration/MaxFairSchedulingSteps/#configurationmaxfairschedulingsteps-property","text":"The maximum scheduling steps to explore for fair schedulers. By default this is set to 100,000 steps. public int MaxFairSchedulingSteps { get; }","title":"Configuration.MaxFairSchedulingSteps property"},{"location":"ref/Microsoft.Coyote/Configuration/MaxFairSchedulingSteps/#see-also","text":"class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Configuration/MaxUnfairSchedulingSteps/","text":"Configuration.MaxUnfairSchedulingSteps property The maximum scheduling steps to explore for unfair schedulers. By default this is set to 10,000 steps. public int MaxUnfairSchedulingSteps { get; } See Also class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"MaxUnfairSchedulingSteps"},{"location":"ref/Microsoft.Coyote/Configuration/MaxUnfairSchedulingSteps/#configurationmaxunfairschedulingsteps-property","text":"The maximum scheduling steps to explore for unfair schedulers. By default this is set to 10,000 steps. public int MaxUnfairSchedulingSteps { get; }","title":"Configuration.MaxUnfairSchedulingSteps property"},{"location":"ref/Microsoft.Coyote/Configuration/MaxUnfairSchedulingSteps/#see-also","text":"class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Configuration/RandomGeneratorSeed/","text":"Configuration.RandomGeneratorSeed property Custom seed to be used by the random value generator. By default, this value is null indicating that no seed has been set. public uint? RandomGeneratorSeed { get; } See Also class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"RandomGeneratorSeed"},{"location":"ref/Microsoft.Coyote/Configuration/RandomGeneratorSeed/#configurationrandomgeneratorseed-property","text":"Custom seed to be used by the random value generator. By default, this value is null indicating that no seed has been set. public uint? RandomGeneratorSeed { get; }","title":"Configuration.RandomGeneratorSeed property"},{"location":"ref/Microsoft.Coyote/Configuration/RandomGeneratorSeed/#see-also","text":"class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Configuration/ReportActivityCoverage/","text":"Configuration.ReportActivityCoverage property Enables activity coverage reporting of a Coyote program. public bool ReportActivityCoverage { get; } See Also class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"ReportActivityCoverage"},{"location":"ref/Microsoft.Coyote/Configuration/ReportActivityCoverage/#configurationreportactivitycoverage-property","text":"Enables activity coverage reporting of a Coyote program. public bool ReportActivityCoverage { get; }","title":"Configuration.ReportActivityCoverage property"},{"location":"ref/Microsoft.Coyote/Configuration/ReportActivityCoverage/#see-also","text":"class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Configuration/SchedulingStrategy/","text":"Configuration.SchedulingStrategy property The systematic testing strategy to use. public string SchedulingStrategy { get; } See Also class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"SchedulingStrategy"},{"location":"ref/Microsoft.Coyote/Configuration/SchedulingStrategy/#configurationschedulingstrategy-property","text":"The systematic testing strategy to use. public string SchedulingStrategy { get; }","title":"Configuration.SchedulingStrategy property"},{"location":"ref/Microsoft.Coyote/Configuration/SchedulingStrategy/#see-also","text":"class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Configuration/StrategyBound/","text":"Configuration.StrategyBound property A strategy-specific bound. public int StrategyBound { get; } See Also class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"StrategyBound"},{"location":"ref/Microsoft.Coyote/Configuration/StrategyBound/#configurationstrategybound-property","text":"A strategy-specific bound. public int StrategyBound { get; }","title":"Configuration.StrategyBound property"},{"location":"ref/Microsoft.Coyote/Configuration/StrategyBound/#see-also","text":"class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Configuration/TestingIterations/","text":"Configuration.TestingIterations property Number of testing iterations. public uint TestingIterations { get; } See Also class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"TestingIterations"},{"location":"ref/Microsoft.Coyote/Configuration/TestingIterations/#configurationtestingiterations-property","text":"Number of testing iterations. public uint TestingIterations { get; }","title":"Configuration.TestingIterations property"},{"location":"ref/Microsoft.Coyote/Configuration/TestingIterations/#see-also","text":"class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Configuration/TimeoutDelay/","text":"Configuration.TimeoutDelay property Value that controls the probability of triggering a timeout each time Int32) or a built-in timer is scheduled during systematic testing. Decrease the value to increase the frequency of timeouts (e.g. a value of 1 corresponds to a 50% probability), or increase the value to decrease the frequency (e.g. a value of 10 corresponds to a 10% probability). By default this value is 10. public uint TimeoutDelay { get; } See Also class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"TimeoutDelay"},{"location":"ref/Microsoft.Coyote/Configuration/TimeoutDelay/#configurationtimeoutdelay-property","text":"Value that controls the probability of triggering a timeout each time Int32) or a built-in timer is scheduled during systematic testing. Decrease the value to increase the frequency of timeouts (e.g. a value of 1 corresponds to a 50% probability), or increase the value to decrease the frequency (e.g. a value of 10 corresponds to a 10% probability). By default this value is 10. public uint TimeoutDelay { get; }","title":"Configuration.TimeoutDelay property"},{"location":"ref/Microsoft.Coyote/Configuration/TimeoutDelay/#see-also","text":"class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Configuration/WithActivityCoverageEnabled/","text":"Configuration.WithActivityCoverageEnabled method Updates the configuration with activity coverage enabled or disabled. public Configuration WithActivityCoverageEnabled(bool isEnabled = true) parameter description isEnabled If true, then enables activity coverage. See Also class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"WithActivityCoverageEnabled"},{"location":"ref/Microsoft.Coyote/Configuration/WithActivityCoverageEnabled/#configurationwithactivitycoverageenabled-method","text":"Updates the configuration with activity coverage enabled or disabled. public Configuration WithActivityCoverageEnabled(bool isEnabled = true) parameter description isEnabled If true, then enables activity coverage.","title":"Configuration.WithActivityCoverageEnabled method"},{"location":"ref/Microsoft.Coyote/Configuration/WithActivityCoverageEnabled/#see-also","text":"class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Configuration/WithConcurrencyFuzzingEnabled/","text":"Configuration.WithConcurrencyFuzzingEnabled method Updates the configuration with concurrency fuzzing enabled or disabled. public Configuration WithConcurrencyFuzzingEnabled(bool isEnabled = true) parameter description isEnabled If true, then concurrency fuzzing is enabled. Remarks This is an experimental feature. See Also class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"WithConcurrencyFuzzingEnabled"},{"location":"ref/Microsoft.Coyote/Configuration/WithConcurrencyFuzzingEnabled/#configurationwithconcurrencyfuzzingenabled-method","text":"Updates the configuration with concurrency fuzzing enabled or disabled. public Configuration WithConcurrencyFuzzingEnabled(bool isEnabled = true) parameter description isEnabled If true, then concurrency fuzzing is enabled.","title":"Configuration.WithConcurrencyFuzzingEnabled method"},{"location":"ref/Microsoft.Coyote/Configuration/WithConcurrencyFuzzingEnabled/#remarks","text":"This is an experimental feature.","title":"Remarks"},{"location":"ref/Microsoft.Coyote/Configuration/WithConcurrencyFuzzingEnabled/#see-also","text":"class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Configuration/WithDeadlockTimeout/","text":"Configuration.WithDeadlockTimeout method Updates the DeadlockTimeout value that controls how much time the deadlock monitor should wait during concurrency fuzzing before reporting a potential deadlock. public Configuration WithDeadlockTimeout(uint timeout) parameter description timeout The deadlock timeout value in milliseconds. Remarks Increase the value to give more time to the test to resolve a potential deadlock. See Also class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"WithDeadlockTimeout"},{"location":"ref/Microsoft.Coyote/Configuration/WithDeadlockTimeout/#configurationwithdeadlocktimeout-method","text":"Updates the DeadlockTimeout value that controls how much time the deadlock monitor should wait during concurrency fuzzing before reporting a potential deadlock. public Configuration WithDeadlockTimeout(uint timeout) parameter description timeout The deadlock timeout value in milliseconds.","title":"Configuration.WithDeadlockTimeout method"},{"location":"ref/Microsoft.Coyote/Configuration/WithDeadlockTimeout/#remarks","text":"Increase the value to give more time to the test to resolve a potential deadlock.","title":"Remarks"},{"location":"ref/Microsoft.Coyote/Configuration/WithDeadlockTimeout/#see-also","text":"class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Configuration/WithDgmlGraphEnabled/","text":"Configuration.WithDgmlGraphEnabled method Updates the configuration with DGML graph generation enabled or disabled. public Configuration WithDgmlGraphEnabled(bool isEnabled = true) parameter description isEnabled If true, then enables DGML graph generation. See Also class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"WithDgmlGraphEnabled"},{"location":"ref/Microsoft.Coyote/Configuration/WithDgmlGraphEnabled/#configurationwithdgmlgraphenabled-method","text":"Updates the configuration with DGML graph generation enabled or disabled. public Configuration WithDgmlGraphEnabled(bool isEnabled = true) parameter description isEnabled If true, then enables DGML graph generation.","title":"Configuration.WithDgmlGraphEnabled method"},{"location":"ref/Microsoft.Coyote/Configuration/WithDgmlGraphEnabled/#see-also","text":"class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Configuration/WithLivenessTemperatureThreshold/","text":"Configuration.WithLivenessTemperatureThreshold method Updates the configuration with the specified liveness temperature threshold during systematic testing. If this value is 0 it disables liveness checking. It is not recommended to explicitly set this value, instead use the default value which is assigned to MaxFairSchedulingSteps / 2. public Configuration WithLivenessTemperatureThreshold(uint threshold) parameter description threshold The liveness temperature threshold. See Also class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"WithLivenessTemperatureThreshold"},{"location":"ref/Microsoft.Coyote/Configuration/WithLivenessTemperatureThreshold/#configurationwithlivenesstemperaturethreshold-method","text":"Updates the configuration with the specified liveness temperature threshold during systematic testing. If this value is 0 it disables liveness checking. It is not recommended to explicitly set this value, instead use the default value which is assigned to MaxFairSchedulingSteps / 2. public Configuration WithLivenessTemperatureThreshold(uint threshold) parameter description threshold The liveness temperature threshold.","title":"Configuration.WithLivenessTemperatureThreshold method"},{"location":"ref/Microsoft.Coyote/Configuration/WithLivenessTemperatureThreshold/#see-also","text":"class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Configuration/WithMaxSchedulingSteps/","text":"Configuration.WithMaxSchedulingSteps method (1 of 2) Updates the configuration with the specified number of maximum scheduling steps to explore per iteration during systematic testing. The MaxUnfairSchedulingSteps is assigned the maxSteps value, whereas the MaxFairSchedulingSteps is assigned a value using the default heuristic, which is 10 * maxSteps . public Configuration WithMaxSchedulingSteps(uint maxSteps) parameter description maxSteps The maximum scheduling steps to explore per iteration. See Also class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote Configuration.WithMaxSchedulingSteps method (2 of 2) Updates the configuration with the specified number of maximum unfair and fair scheduling steps to explore per iteration during systematic testing. It is recommended to use WithMaxSchedulingSteps instead of this overloaded method. public Configuration WithMaxSchedulingSteps(uint maxUnfairSteps, uint maxFairSteps) parameter description maxUnfairSteps The unfair scheduling steps to explore per iteration. maxFairSteps The fair scheduling steps to explore per iteration. See Also class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"WithMaxSchedulingSteps"},{"location":"ref/Microsoft.Coyote/Configuration/WithMaxSchedulingSteps/#configurationwithmaxschedulingsteps-method-1-of-2","text":"Updates the configuration with the specified number of maximum scheduling steps to explore per iteration during systematic testing. The MaxUnfairSchedulingSteps is assigned the maxSteps value, whereas the MaxFairSchedulingSteps is assigned a value using the default heuristic, which is 10 * maxSteps . public Configuration WithMaxSchedulingSteps(uint maxSteps) parameter description maxSteps The maximum scheduling steps to explore per iteration.","title":"Configuration.WithMaxSchedulingSteps method (1 of 2)"},{"location":"ref/Microsoft.Coyote/Configuration/WithMaxSchedulingSteps/#see-also","text":"class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Configuration/WithMaxSchedulingSteps/#configurationwithmaxschedulingsteps-method-2-of-2","text":"Updates the configuration with the specified number of maximum unfair and fair scheduling steps to explore per iteration during systematic testing. It is recommended to use WithMaxSchedulingSteps instead of this overloaded method. public Configuration WithMaxSchedulingSteps(uint maxUnfairSteps, uint maxFairSteps) parameter description maxUnfairSteps The unfair scheduling steps to explore per iteration. maxFairSteps The fair scheduling steps to explore per iteration.","title":"Configuration.WithMaxSchedulingSteps method (2 of 2)"},{"location":"ref/Microsoft.Coyote/Configuration/WithMaxSchedulingSteps/#see-also_1","text":"class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Configuration/WithNoBugTraceRepro/","text":"Configuration.WithNoBugTraceRepro method Updates the configuration with the ability to reproduce bug traces enabled or disabled. Disabling reproducibility allows skipping errors due to uncontrolled concurrency, for example when the program is only partially rewritten, or there is external concurrency that is not mocked, or when the program uses an API that is not yet supported. public Configuration WithNoBugTraceRepro(bool isDisabled = true) parameter description isDisabled If true, then reproducing bug traces is disabled. See Also class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"WithNoBugTraceRepro"},{"location":"ref/Microsoft.Coyote/Configuration/WithNoBugTraceRepro/#configurationwithnobugtracerepro-method","text":"Updates the configuration with the ability to reproduce bug traces enabled or disabled. Disabling reproducibility allows skipping errors due to uncontrolled concurrency, for example when the program is only partially rewritten, or there is external concurrency that is not mocked, or when the program uses an API that is not yet supported. public Configuration WithNoBugTraceRepro(bool isDisabled = true) parameter description isDisabled If true, then reproducing bug traces is disabled.","title":"Configuration.WithNoBugTraceRepro method"},{"location":"ref/Microsoft.Coyote/Configuration/WithNoBugTraceRepro/#see-also","text":"class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Configuration/WithPCTStrategy/","text":"Configuration.WithPCTStrategy method Updates the configuration to use the PCT scheduling strategy during systematic testing. You can specify the number of priority switch points, which by default are 10. public Configuration WithPCTStrategy(bool isFair, uint numPrioritySwitchPoints = 10) parameter description isFair If true, use the fair version of PCT. numPrioritySwitchPoints The nunmber of priority switch points. See Also class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"WithPCTStrategy"},{"location":"ref/Microsoft.Coyote/Configuration/WithPCTStrategy/#configurationwithpctstrategy-method","text":"Updates the configuration to use the PCT scheduling strategy during systematic testing. You can specify the number of priority switch points, which by default are 10. public Configuration WithPCTStrategy(bool isFair, uint numPrioritySwitchPoints = 10) parameter description isFair If true, use the fair version of PCT. numPrioritySwitchPoints The nunmber of priority switch points.","title":"Configuration.WithPCTStrategy method"},{"location":"ref/Microsoft.Coyote/Configuration/WithPCTStrategy/#see-also","text":"class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Configuration/WithProbabilisticStrategy/","text":"Configuration.WithProbabilisticStrategy method Updates the configuration to use the probabilistic scheduling strategy during systematic testing. You can specify a value controlling the probability of each scheduling decision. This value is specified as the integer N in the equation 0.5 to the power of N. So for N=1, the probability is 0.5, for N=2 the probability is 0.25, N=3 you get 0.125, etc. By default, this value is 3. public Configuration WithProbabilisticStrategy(uint probabilityLevel = 3) parameter description probabilityLevel The probability level. See Also class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"WithProbabilisticStrategy"},{"location":"ref/Microsoft.Coyote/Configuration/WithProbabilisticStrategy/#configurationwithprobabilisticstrategy-method","text":"Updates the configuration to use the probabilistic scheduling strategy during systematic testing. You can specify a value controlling the probability of each scheduling decision. This value is specified as the integer N in the equation 0.5 to the power of N. So for N=1, the probability is 0.5, for N=2 the probability is 0.25, N=3 you get 0.125, etc. By default, this value is 3. public Configuration WithProbabilisticStrategy(uint probabilityLevel = 3) parameter description probabilityLevel The probability level.","title":"Configuration.WithProbabilisticStrategy method"},{"location":"ref/Microsoft.Coyote/Configuration/WithProbabilisticStrategy/#see-also","text":"class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Configuration/WithRLStrategy/","text":"Configuration.WithRLStrategy method Updates the configuration to use the reinforcement learning (RL) scheduling strategy during systematic testing. public Configuration WithRLStrategy() See Also class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"WithRLStrategy"},{"location":"ref/Microsoft.Coyote/Configuration/WithRLStrategy/#configurationwithrlstrategy-method","text":"Updates the configuration to use the reinforcement learning (RL) scheduling strategy during systematic testing. public Configuration WithRLStrategy()","title":"Configuration.WithRLStrategy method"},{"location":"ref/Microsoft.Coyote/Configuration/WithRLStrategy/#see-also","text":"class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Configuration/WithRandomGeneratorSeed/","text":"Configuration.WithRandomGeneratorSeed method Updates the seed used by the random value generator during systematic testing. public Configuration WithRandomGeneratorSeed(uint seed) parameter description seed The seed used by the random value generator. See Also class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"WithRandomGeneratorSeed"},{"location":"ref/Microsoft.Coyote/Configuration/WithRandomGeneratorSeed/#configurationwithrandomgeneratorseed-method","text":"Updates the seed used by the random value generator during systematic testing. public Configuration WithRandomGeneratorSeed(uint seed) parameter description seed The seed used by the random value generator.","title":"Configuration.WithRandomGeneratorSeed method"},{"location":"ref/Microsoft.Coyote/Configuration/WithRandomGeneratorSeed/#see-also","text":"class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Configuration/WithRandomStrategy/","text":"Configuration.WithRandomStrategy method Updates the configuration to use the random scheduling strategy during systematic testing. public Configuration WithRandomStrategy() See Also class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"WithRandomStrategy"},{"location":"ref/Microsoft.Coyote/Configuration/WithRandomStrategy/#configurationwithrandomstrategy-method","text":"Updates the configuration to use the random scheduling strategy during systematic testing. public Configuration WithRandomStrategy()","title":"Configuration.WithRandomStrategy method"},{"location":"ref/Microsoft.Coyote/Configuration/WithRandomStrategy/#see-also","text":"class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Configuration/WithRelaxedControlledTestingEnabled/","text":"Configuration.WithRelaxedControlledTestingEnabled method Updates the configuration with relaxed controlled testing enabled or disabled. If this option is enabled, systematic testing supports partially controlled executions. public Configuration WithRelaxedControlledTestingEnabled(bool isEnabled = true) parameter description isEnabled If true, then relaxed controlled testing is enabled. Remarks This is an experimental feature. See Also class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"WithRelaxedControlledTestingEnabled"},{"location":"ref/Microsoft.Coyote/Configuration/WithRelaxedControlledTestingEnabled/#configurationwithrelaxedcontrolledtestingenabled-method","text":"Updates the configuration with relaxed controlled testing enabled or disabled. If this option is enabled, systematic testing supports partially controlled executions. public Configuration WithRelaxedControlledTestingEnabled(bool isEnabled = true) parameter description isEnabled If true, then relaxed controlled testing is enabled.","title":"Configuration.WithRelaxedControlledTestingEnabled method"},{"location":"ref/Microsoft.Coyote/Configuration/WithRelaxedControlledTestingEnabled/#remarks","text":"This is an experimental feature.","title":"Remarks"},{"location":"ref/Microsoft.Coyote/Configuration/WithRelaxedControlledTestingEnabled/#see-also","text":"class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Configuration/WithReplayStrategy/","text":"Configuration.WithReplayStrategy method Updates the configuration to use the replay scheduling strategy during systematic testing. This strategy replays the specified schedule trace to reproduce the same execution. public Configuration WithReplayStrategy(string scheduleTrace) parameter description scheduleTrace The schedule trace to be replayed. See Also class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"WithReplayStrategy"},{"location":"ref/Microsoft.Coyote/Configuration/WithReplayStrategy/#configurationwithreplaystrategy-method","text":"Updates the configuration to use the replay scheduling strategy during systematic testing. This strategy replays the specified schedule trace to reproduce the same execution. public Configuration WithReplayStrategy(string scheduleTrace) parameter description scheduleTrace The schedule trace to be replayed.","title":"Configuration.WithReplayStrategy method"},{"location":"ref/Microsoft.Coyote/Configuration/WithReplayStrategy/#see-also","text":"class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Configuration/WithTelemetryEnabled/","text":"Configuration.WithTelemetryEnabled method Updates the configuration with telemetry enabled or disabled. public Configuration WithTelemetryEnabled(bool isEnabled = true) See Also class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"WithTelemetryEnabled"},{"location":"ref/Microsoft.Coyote/Configuration/WithTelemetryEnabled/#configurationwithtelemetryenabled-method","text":"Updates the configuration with telemetry enabled or disabled. public Configuration WithTelemetryEnabled(bool isEnabled = true)","title":"Configuration.WithTelemetryEnabled method"},{"location":"ref/Microsoft.Coyote/Configuration/WithTelemetryEnabled/#see-also","text":"class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Configuration/WithTestingIterations/","text":"Configuration.WithTestingIterations method Updates the configuration with the specified number of iterations to run during systematic testing. public Configuration WithTestingIterations(uint iterations) parameter description iterations The number of iterations to run. See Also class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"WithTestingIterations"},{"location":"ref/Microsoft.Coyote/Configuration/WithTestingIterations/#configurationwithtestingiterations-method","text":"Updates the configuration with the specified number of iterations to run during systematic testing. public Configuration WithTestingIterations(uint iterations) parameter description iterations The number of iterations to run.","title":"Configuration.WithTestingIterations method"},{"location":"ref/Microsoft.Coyote/Configuration/WithTestingIterations/#see-also","text":"class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Configuration/WithTestingTimeout/","text":"Configuration.WithTestingTimeout method Updates the configuration with the specified systematic testing timeout in seconds. public Configuration WithTestingTimeout(int timeout) parameter description timeout The timeout value in seconds. Remarks Setting this value overrides the TestingIterations value. See Also class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"WithTestingTimeout"},{"location":"ref/Microsoft.Coyote/Configuration/WithTestingTimeout/#configurationwithtestingtimeout-method","text":"Updates the configuration with the specified systematic testing timeout in seconds. public Configuration WithTestingTimeout(int timeout) parameter description timeout The timeout value in seconds.","title":"Configuration.WithTestingTimeout method"},{"location":"ref/Microsoft.Coyote/Configuration/WithTestingTimeout/#remarks","text":"Setting this value overrides the TestingIterations value.","title":"Remarks"},{"location":"ref/Microsoft.Coyote/Configuration/WithTestingTimeout/#see-also","text":"class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Configuration/WithTimeoutDelay/","text":"Configuration.WithTimeoutDelay method Updates the TimeoutDelay value that controls the probability of triggering a timeout each time Int32) or a built-in timer is scheduled during systematic testing. public Configuration WithTimeoutDelay(uint delay) parameter description delay The timeout delay during testing. Remarks Increase the value to decrease the probability. This value is not a unit of time. See Also class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"WithTimeoutDelay"},{"location":"ref/Microsoft.Coyote/Configuration/WithTimeoutDelay/#configurationwithtimeoutdelay-method","text":"Updates the TimeoutDelay value that controls the probability of triggering a timeout each time Int32) or a built-in timer is scheduled during systematic testing. public Configuration WithTimeoutDelay(uint delay) parameter description delay The timeout delay during testing.","title":"Configuration.WithTimeoutDelay method"},{"location":"ref/Microsoft.Coyote/Configuration/WithTimeoutDelay/#remarks","text":"Increase the value to decrease the probability. This value is not a unit of time.","title":"Remarks"},{"location":"ref/Microsoft.Coyote/Configuration/WithTimeoutDelay/#see-also","text":"class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Configuration/WithVerbosityEnabled/","text":"Configuration.WithVerbosityEnabled method Updates the configuration with verbose output enabled or disabled. public Configuration WithVerbosityEnabled(bool isVerbose = true, LogSeverity logLevel = LogSeverity.Informational) parameter description isVerbose If true, then messages are logged. logLevel The level of detail to provide in verbose logging. See Also enum LogSeverity class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"WithVerbosityEnabled"},{"location":"ref/Microsoft.Coyote/Configuration/WithVerbosityEnabled/#configurationwithverbosityenabled-method","text":"Updates the configuration with verbose output enabled or disabled. public Configuration WithVerbosityEnabled(bool isVerbose = true, LogSeverity logLevel = LogSeverity.Informational) parameter description isVerbose If true, then messages are logged. logLevel The level of detail to provide in verbose logging.","title":"Configuration.WithVerbosityEnabled method"},{"location":"ref/Microsoft.Coyote/Configuration/WithVerbosityEnabled/#see-also","text":"enum LogSeverity class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Configuration/WithXmlLogEnabled/","text":"Configuration.WithXmlLogEnabled method Updates the configuration with XML log generation enabled or disabled. public Configuration WithXmlLogEnabled(bool isEnabled = true) parameter description isEnabled If true, then enables XML log generation. See Also class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"WithXmlLogEnabled"},{"location":"ref/Microsoft.Coyote/Configuration/WithXmlLogEnabled/#configurationwithxmllogenabled-method","text":"Updates the configuration with XML log generation enabled or disabled. public Configuration WithXmlLogEnabled(bool isEnabled = true) parameter description isEnabled If true, then enables XML log generation.","title":"Configuration.WithXmlLogEnabled method"},{"location":"ref/Microsoft.Coyote/Configuration/WithXmlLogEnabled/#see-also","text":"class Configuration namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote/Event/Event/","text":"Event constructor The default constructor. protected Event() See Also class Event namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"Event"},{"location":"ref/Microsoft.Coyote/Event/Event/#event-constructor","text":"The default constructor. protected Event()","title":"Event constructor"},{"location":"ref/Microsoft.Coyote/Event/Event/#see-also","text":"class Event namespace Microsoft.Coyote assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor.OnEventDoActionAttribute/","text":"Actor.OnEventDoActionAttribute class Attribute for declaring which action should be invoked to handle a dequeued event of the specified type. [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] protected sealed class OnEventDoActionAttribute : Attribute Public Members name description OnEventDoActionAttribute (\u2026) Initializes a new instance of the OnEventDoActionAttribute class. See Also class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Actors/Actor.OnEventDoActionAttribute/#actoroneventdoactionattribute-class","text":"Attribute for declaring which action should be invoked to handle a dequeued event of the specified type. [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] protected sealed class OnEventDoActionAttribute : Attribute","title":"Actor.OnEventDoActionAttribute class"},{"location":"ref/Microsoft.Coyote.Actors/Actor.OnEventDoActionAttribute/#public-members","text":"name description OnEventDoActionAttribute (\u2026) Initializes a new instance of the OnEventDoActionAttribute class.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Actors/Actor.OnEventDoActionAttribute/#see-also","text":"class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/","text":"Actor class Type that implements an actor. Inherit from this class to declare a custom actor. public abstract class Actor Public Members name description CurrentEventGroup { get; set; } An optional EventGroup associated with the current event being handled. override Equals (\u2026) Determines whether the specified object is equal to the current object. override GetHashCode () Returns the hash code for this instance. override ToString () Returns a string that represents the current actor. Protected Members name description Actor () Initializes a new instance of the Actor class. virtual HashedState { get; } User-defined hashed state of the actor. Override to improve the accuracy of stateful techniques during testing. Id { get; } Unique id that identifies this actor. Logger { get; } The logger installed to the runtime. Assert (\u2026) Checks if the assertion holds, and if not, throws an AssertionFailureException exception. (5 methods) CreateActor (\u2026) Creates a new actor of the specified type and with the specified optional Event . This Event can only be used to access its payload, and cannot be handled. (3 methods) Monitor (\u2026) Invokes the specified monitor with the specified event. Monitor<T> (\u2026) Invokes the specified monitor with the specified Event . virtual OnEventDeferred (\u2026) Callback that is invoked when the actor defers dequeing an event from its inbox. virtual OnEventDequeuedAsync (\u2026) Asynchronous callback that is invoked when the actor successfully dequeues an event from its inbox. This method is not called when the dequeue happens via a receive statement. virtual OnEventHandledAsync (\u2026) Asynchronous callback that is invoked when the actor finishes handling a dequeued event, unless the handler of the dequeued event caused the actor to halt (either normally or due to an exception). The actor will either become idle or dequeue the next event from its inbox. virtual OnEventIgnored (\u2026) Callback that is invoked when the actor ignores an event and removes it from its inbox. virtual OnEventUnhandledAsync (\u2026) Asynchronous callback that is invoked when the actor receives an event that it is not prepared to handle. The callback is invoked first, after which the actor will necessarily throw an UnhandledEventException . virtual OnException (\u2026) Callback that is invoked when the actor throws an exception. By default, the actor throws the exception causing the runtime to fail. virtual OnExceptionHandledAsync (\u2026) Asynchronous callback that is invoked when the actor handles an exception. virtual OnHaltAsync (\u2026) Asynchronous callback that is invoked when the actor halts. virtual OnInitializeAsync (\u2026) Asynchronous callback that is invoked when the actor is initialized with an optional event. RaiseHaltEvent () Raises a HaltEvent to halt the actor at the end of the current action. RandomBoolean () Returns a nondeterministic boolean choice, that can be controlled during analysis or testing. RandomBoolean (\u2026) Returns a nondeterministic boolean choice, that can be controlled during analysis or testing. The value is used to generate a number in the range [0..maxValue), where 0 triggers true. RandomInteger (\u2026) Returns a nondeterministic integer, that can be controlled during analysis or testing. The value is used to generate an integer in the range [0..maxValue). ReceiveEventAsync (\u2026) Waits to receive an Event of the specified type that satisfies an optional predicate. (3 methods) SendEvent (\u2026) Sends an asynchronous Event to a target. StartPeriodicTimer (\u2026) Starts a periodic timer that sends a TimerElapsedEvent to this actor after the specified due time, and then repeats after each specified period. The timer accepts an optional payload to be used during timeout. The timer can be stopped by invoking the StopTimer method. StartTimer (\u2026) Starts a timer that sends a TimerElapsedEvent to this actor after the specified due time. The timer accepts an optional payload to be used during timeout. The timer is automatically disposed after it timeouts. To manually stop and dispose the timer, invoke the StopTimer method. StopTimer (\u2026) Stops and disposes the specified timer. class OnEventDoActionAttribute Attribute for declaring which action should be invoked to handle a dequeued event of the specified type. Remarks See Programming model: asynchronous actors for more information. See Also namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Actors/Actor/#actor-class","text":"Type that implements an actor. Inherit from this class to declare a custom actor. public abstract class Actor","title":"Actor class"},{"location":"ref/Microsoft.Coyote.Actors/Actor/#public-members","text":"name description CurrentEventGroup { get; set; } An optional EventGroup associated with the current event being handled. override Equals (\u2026) Determines whether the specified object is equal to the current object. override GetHashCode () Returns the hash code for this instance. override ToString () Returns a string that represents the current actor.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Actors/Actor/#protected-members","text":"name description Actor () Initializes a new instance of the Actor class. virtual HashedState { get; } User-defined hashed state of the actor. Override to improve the accuracy of stateful techniques during testing. Id { get; } Unique id that identifies this actor. Logger { get; } The logger installed to the runtime. Assert (\u2026) Checks if the assertion holds, and if not, throws an AssertionFailureException exception. (5 methods) CreateActor (\u2026) Creates a new actor of the specified type and with the specified optional Event . This Event can only be used to access its payload, and cannot be handled. (3 methods) Monitor (\u2026) Invokes the specified monitor with the specified event. Monitor<T> (\u2026) Invokes the specified monitor with the specified Event . virtual OnEventDeferred (\u2026) Callback that is invoked when the actor defers dequeing an event from its inbox. virtual OnEventDequeuedAsync (\u2026) Asynchronous callback that is invoked when the actor successfully dequeues an event from its inbox. This method is not called when the dequeue happens via a receive statement. virtual OnEventHandledAsync (\u2026) Asynchronous callback that is invoked when the actor finishes handling a dequeued event, unless the handler of the dequeued event caused the actor to halt (either normally or due to an exception). The actor will either become idle or dequeue the next event from its inbox. virtual OnEventIgnored (\u2026) Callback that is invoked when the actor ignores an event and removes it from its inbox. virtual OnEventUnhandledAsync (\u2026) Asynchronous callback that is invoked when the actor receives an event that it is not prepared to handle. The callback is invoked first, after which the actor will necessarily throw an UnhandledEventException . virtual OnException (\u2026) Callback that is invoked when the actor throws an exception. By default, the actor throws the exception causing the runtime to fail. virtual OnExceptionHandledAsync (\u2026) Asynchronous callback that is invoked when the actor handles an exception. virtual OnHaltAsync (\u2026) Asynchronous callback that is invoked when the actor halts. virtual OnInitializeAsync (\u2026) Asynchronous callback that is invoked when the actor is initialized with an optional event. RaiseHaltEvent () Raises a HaltEvent to halt the actor at the end of the current action. RandomBoolean () Returns a nondeterministic boolean choice, that can be controlled during analysis or testing. RandomBoolean (\u2026) Returns a nondeterministic boolean choice, that can be controlled during analysis or testing. The value is used to generate a number in the range [0..maxValue), where 0 triggers true. RandomInteger (\u2026) Returns a nondeterministic integer, that can be controlled during analysis or testing. The value is used to generate an integer in the range [0..maxValue). ReceiveEventAsync (\u2026) Waits to receive an Event of the specified type that satisfies an optional predicate. (3 methods) SendEvent (\u2026) Sends an asynchronous Event to a target. StartPeriodicTimer (\u2026) Starts a periodic timer that sends a TimerElapsedEvent to this actor after the specified due time, and then repeats after each specified period. The timer accepts an optional payload to be used during timeout. The timer can be stopped by invoking the StopTimer method. StartTimer (\u2026) Starts a timer that sends a TimerElapsedEvent to this actor after the specified due time. The timer accepts an optional payload to be used during timeout. The timer is automatically disposed after it timeouts. To manually stop and dispose the timer, invoke the StopTimer method. StopTimer (\u2026) Stops and disposes the specified timer. class OnEventDoActionAttribute Attribute for declaring which action should be invoked to handle a dequeued event of the specified type.","title":"Protected Members"},{"location":"ref/Microsoft.Coyote.Actors/Actor/#remarks","text":"See Programming model: asynchronous actors for more information.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Actors/Actor/#see-also","text":"namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorId/","text":"ActorId class Unique actor id. public sealed class ActorId : IComparable<ActorId>, IEquatable<ActorId> Public Members name description IsNameUsedForHashing { get; } True if NameValue is used as the unique id, else false. Runtime { get; } The runtime that executes the actor with this id. readonly Name Name used for logging. readonly NameValue Unique id, when non-empty. readonly Type The type of the actor associated with this id. readonly Value Unique id, when NameValue is empty. CompareTo (\u2026) Compares the specified ActorId with the current ActorId for ordering or sorting purposes. Equals (\u2026) Indicates whether the specified ActorId is equal to the current ActorId . override Equals (\u2026) Determines whether the specified object is equal to the current object. override GetHashCode () Returns the hash code for this instance. override ToString () Returns a string that represents the current actor id. See Also namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Actors/ActorId/#actorid-class","text":"Unique actor id. public sealed class ActorId : IComparable<ActorId>, IEquatable<ActorId>","title":"ActorId class"},{"location":"ref/Microsoft.Coyote.Actors/ActorId/#public-members","text":"name description IsNameUsedForHashing { get; } True if NameValue is used as the unique id, else false. Runtime { get; } The runtime that executes the actor with this id. readonly Name Name used for logging. readonly NameValue Unique id, when non-empty. readonly Type The type of the actor associated with this id. readonly Value Unique id, when NameValue is empty. CompareTo (\u2026) Compares the specified ActorId with the current ActorId for ordering or sorting purposes. Equals (\u2026) Indicates whether the specified ActorId is equal to the current ActorId . override Equals (\u2026) Determines whether the specified object is equal to the current object. override GetHashCode () Returns the hash code for this instance. override ToString () Returns a string that represents the current actor id.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Actors/ActorId/#see-also","text":"namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/","text":"ActorRuntimeLogTextFormatter class This class implements IActorRuntimeLog and generates output in a a human readable text format. public class ActorRuntimeLogTextFormatter : IActorRuntimeLog Public Members name description ActorRuntimeLogTextFormatter () Initializes a new instance of the ActorRuntimeLogTextFormatter class. Logger { get; set; } Get or set the ILogger interface to the logger. virtual OnAssertionFailure (\u2026) Invoked when the specified assertion failure has occurred. virtual OnCompleted () Invoked when a log is complete (and is about to be closed). virtual OnCreateActor (\u2026) Invoked when the specified actor has been created. virtual OnCreateMonitor (\u2026) Invoked when the specified monitor has been created. OnCreateStateMachine (\u2026) Invoked when the specified state machine has been created. virtual OnCreateTimer (\u2026) Invoked when the specified actor timer has been created. virtual OnDefaultEventHandler (\u2026) Invoked when the specified actor is idle (there is nothing to dequeue) and the default event handler is about to be executed. virtual OnDequeueEvent (\u2026) Invoked when the specified event is dequeued by an actor. virtual OnEnqueueEvent (\u2026) Invoked when the specified event is about to be enqueued to an actor. OnEventHandlerTerminated (\u2026) Invoked when the event handler of the specified actor terminated. virtual OnExceptionHandled (\u2026) Invoked when the specified OnException method is used to handle a thrown exception. virtual OnExceptionThrown (\u2026) Invoked when the specified actor throws an exception. virtual OnExecuteAction (\u2026) Invoked when the specified actor executes an action. virtual OnGotoState (\u2026) Invoked when the specified state machine performs a goto transition to the specified state. virtual OnHalt (\u2026) Invoked when the specified actor has been halted. virtual OnHandleRaisedEvent (\u2026) Invoked when the specified actor handled a raised event. virtual OnMonitorError (\u2026) Invoked when the specified monitor finds an error. virtual OnMonitorExecuteAction (\u2026) Invoked when the specified monitor executes an action. virtual OnMonitorProcessEvent (\u2026) Invoked when the specified monitor is about to process an event. virtual OnMonitorRaiseEvent (\u2026) Invoked when the specified monitor raised an event. virtual OnMonitorStateTransition (\u2026) Invoked when the specified monitor enters or exits a state. virtual OnPopState (\u2026) Invoked when the specified state machine has popped its current state. virtual OnPopStateUnhandledEvent (\u2026) Invoked when the specified event cannot be handled in the current state, its exit handler is executed and then the state is popped and any previous \u201ccurrent state\u201d is reentered. This handler is called when that pop has been done. virtual OnPushState (\u2026) Invoked when the specified state machine is being pushed to a state. virtual OnRaiseEvent (\u2026) Invoked when the specified state machine raises an event. virtual OnRandom (\u2026) Invoked when the specified controlled nondeterministic result has been obtained. virtual OnReceiveEvent (\u2026) Invoked when the specified event is received by an actor. virtual OnSendEvent (\u2026) Invoked when the specified event is sent to a target actor. virtual OnStateTransition (\u2026) Invoked when the specified state machine enters or exits a state. virtual OnStopTimer (\u2026) Invoked when the specified actor timer has been stopped. virtual OnStrategyDescription (\u2026) Invoked to describe the specified scheduling strategy. virtual OnWaitEvent (\u2026) Invoked when the specified actor waits to receive an event of a specified type. (2 methods) Remarks See Logging for more information. See Also interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/#actorruntimelogtextformatter-class","text":"This class implements IActorRuntimeLog and generates output in a a human readable text format. public class ActorRuntimeLogTextFormatter : IActorRuntimeLog","title":"ActorRuntimeLogTextFormatter class"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/#public-members","text":"name description ActorRuntimeLogTextFormatter () Initializes a new instance of the ActorRuntimeLogTextFormatter class. Logger { get; set; } Get or set the ILogger interface to the logger. virtual OnAssertionFailure (\u2026) Invoked when the specified assertion failure has occurred. virtual OnCompleted () Invoked when a log is complete (and is about to be closed). virtual OnCreateActor (\u2026) Invoked when the specified actor has been created. virtual OnCreateMonitor (\u2026) Invoked when the specified monitor has been created. OnCreateStateMachine (\u2026) Invoked when the specified state machine has been created. virtual OnCreateTimer (\u2026) Invoked when the specified actor timer has been created. virtual OnDefaultEventHandler (\u2026) Invoked when the specified actor is idle (there is nothing to dequeue) and the default event handler is about to be executed. virtual OnDequeueEvent (\u2026) Invoked when the specified event is dequeued by an actor. virtual OnEnqueueEvent (\u2026) Invoked when the specified event is about to be enqueued to an actor. OnEventHandlerTerminated (\u2026) Invoked when the event handler of the specified actor terminated. virtual OnExceptionHandled (\u2026) Invoked when the specified OnException method is used to handle a thrown exception. virtual OnExceptionThrown (\u2026) Invoked when the specified actor throws an exception. virtual OnExecuteAction (\u2026) Invoked when the specified actor executes an action. virtual OnGotoState (\u2026) Invoked when the specified state machine performs a goto transition to the specified state. virtual OnHalt (\u2026) Invoked when the specified actor has been halted. virtual OnHandleRaisedEvent (\u2026) Invoked when the specified actor handled a raised event. virtual OnMonitorError (\u2026) Invoked when the specified monitor finds an error. virtual OnMonitorExecuteAction (\u2026) Invoked when the specified monitor executes an action. virtual OnMonitorProcessEvent (\u2026) Invoked when the specified monitor is about to process an event. virtual OnMonitorRaiseEvent (\u2026) Invoked when the specified monitor raised an event. virtual OnMonitorStateTransition (\u2026) Invoked when the specified monitor enters or exits a state. virtual OnPopState (\u2026) Invoked when the specified state machine has popped its current state. virtual OnPopStateUnhandledEvent (\u2026) Invoked when the specified event cannot be handled in the current state, its exit handler is executed and then the state is popped and any previous \u201ccurrent state\u201d is reentered. This handler is called when that pop has been done. virtual OnPushState (\u2026) Invoked when the specified state machine is being pushed to a state. virtual OnRaiseEvent (\u2026) Invoked when the specified state machine raises an event. virtual OnRandom (\u2026) Invoked when the specified controlled nondeterministic result has been obtained. virtual OnReceiveEvent (\u2026) Invoked when the specified event is received by an actor. virtual OnSendEvent (\u2026) Invoked when the specified event is sent to a target actor. virtual OnStateTransition (\u2026) Invoked when the specified state machine enters or exits a state. virtual OnStopTimer (\u2026) Invoked when the specified actor timer has been stopped. virtual OnStrategyDescription (\u2026) Invoked to describe the specified scheduling strategy. virtual OnWaitEvent (\u2026) Invoked when the specified actor waits to receive an event of a specified type. (2 methods)","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/#remarks","text":"See Logging for more information.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/#see-also","text":"interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/","text":"AwaitableEventGroup<T> class An object representing an awaitable long running context involving one or more actors. An AwaitableEventGroup can be provided as an optional argument in CreateActor and SendEvent. If a null AwaitableEventGroup is passed then the EventGroup is inherited from the sender or target actors (based on which ever one has a CurrentEventGroup ). In this way an AwaitableEventGroup is automatically communicated to all actors involved in completing some larger operation. Each actor involved can find the AwaitableEventGroup using their CurrentEventGroup property. public class AwaitableEventGroup<T> : EventGroup parameter description T The result returned when the operation is completed. Public Members name description AwaitableEventGroup (\u2026) Initializes a new instance of the AwaitableEventGroup class. IsCanceled { get; } Value that indicates whether the task completed execution due to being canceled. IsCompleted { get; } Indicates the AwaitableEventGroup has been completed. IsFaulted { get; } Value that indicates whether the task completed due to an unhandled exception. Task { get; } Gets the task created by this AwaitableEventGroup . GetAwaiter () Gets an awaiter for this awaitable. virtual SetCancelled () Transitions the underlying task into the Canceled state. virtual SetException (\u2026) Transitions the underlying task into the Faulted state and binds it to the specified exception. virtual SetResult (\u2026) Transitions the underlying task into the RanToCompletion state. virtual TrySetCanceled () Attempts to transition the underlying task into the Canceled state. virtual TrySetException (\u2026) Attempts to transition the underlying task into the Faulted state and binds it to the specified exception. virtual TrySetResult (\u2026) Attempts to transition the underlying task into the RanToCompletion state. See Also class EventGroup namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/#awaitableeventgroupt-class","text":"An object representing an awaitable long running context involving one or more actors. An AwaitableEventGroup can be provided as an optional argument in CreateActor and SendEvent. If a null AwaitableEventGroup is passed then the EventGroup is inherited from the sender or target actors (based on which ever one has a CurrentEventGroup ). In this way an AwaitableEventGroup is automatically communicated to all actors involved in completing some larger operation. Each actor involved can find the AwaitableEventGroup using their CurrentEventGroup property. public class AwaitableEventGroup<T> : EventGroup parameter description T The result returned when the operation is completed.","title":"AwaitableEventGroup&lt;T&gt; class"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/#public-members","text":"name description AwaitableEventGroup (\u2026) Initializes a new instance of the AwaitableEventGroup class. IsCanceled { get; } Value that indicates whether the task completed execution due to being canceled. IsCompleted { get; } Indicates the AwaitableEventGroup has been completed. IsFaulted { get; } Value that indicates whether the task completed due to an unhandled exception. Task { get; } Gets the task created by this AwaitableEventGroup . GetAwaiter () Gets an awaiter for this awaitable. virtual SetCancelled () Transitions the underlying task into the Canceled state. virtual SetException (\u2026) Transitions the underlying task into the Faulted state and binds it to the specified exception. virtual SetResult (\u2026) Transitions the underlying task into the RanToCompletion state. virtual TrySetCanceled () Attempts to transition the underlying task into the Canceled state. virtual TrySetException (\u2026) Attempts to transition the underlying task into the Faulted state and binds it to the specified exception. virtual TrySetResult (\u2026) Attempts to transition the underlying task into the RanToCompletion state.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/#see-also","text":"class EventGroup namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/DefaultEvent/","text":"DefaultEvent class A default event that is generated by the runtime when no user-defined event is dequeued or received. public sealed class DefaultEvent : Event Public Members name description static Instance { get; } Gets a DefaultEvent instance. See Also class Event namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Actors/DefaultEvent/#defaultevent-class","text":"A default event that is generated by the runtime when no user-defined event is dequeued or received. public sealed class DefaultEvent : Event","title":"DefaultEvent class"},{"location":"ref/Microsoft.Coyote.Actors/DefaultEvent/#public-members","text":"name description static Instance { get; } Gets a DefaultEvent instance.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Actors/DefaultEvent/#see-also","text":"class Event namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/DequeueStatus/","text":"DequeueStatus enumeration The status returned as the result of an Actor dequeue operation. public enum DequeueStatus Values name value description Success 0 An event was successfully dequeued. Raised 1 The raised event was dequeued. Default 2 The default event was dequeued. NoDequeue 3 No dequeue has happened. Unavailable 4 No event available to dequeue. See Also namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"DequeueStatus"},{"location":"ref/Microsoft.Coyote.Actors/DequeueStatus/#dequeuestatus-enumeration","text":"The status returned as the result of an Actor dequeue operation. public enum DequeueStatus","title":"DequeueStatus enumeration"},{"location":"ref/Microsoft.Coyote.Actors/DequeueStatus/#values","text":"name value description Success 0 An event was successfully dequeued. Raised 1 The raised event was dequeued. Default 2 The default event was dequeued. NoDequeue 3 No dequeue has happened. Unavailable 4 No event available to dequeue.","title":"Values"},{"location":"ref/Microsoft.Coyote.Actors/DequeueStatus/#see-also","text":"namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/EventGroup/","text":"EventGroup class An object representing a long running context involving one or more actors. An EventGroup can be provided as an optional argument in CreateActor and SendEvent. If a null EventGroup is passed then the EventGroup is inherited from the sender or target actors (based on which ever one has a CurrentEventGroup ). In this way an EventGroup is automatically communicated to all actors involved in completing some larger operation. Each actor involved can find the EventGroup using their CurrentEventGroup property. public class EventGroup Public Members name description EventGroup (\u2026) Initializes a new instance of the EventGroup class. static Null A special null event group that can be used to stop the CurrentEventGroup from being passed along when CreateActor or SendEvent is invoked. Id { get; } The unique id of this EventGroup , initialized with Guid.Empty. Name { get; } An optional friendly name for this EventGroup . See Also namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Actors/EventGroup/#eventgroup-class","text":"An object representing a long running context involving one or more actors. An EventGroup can be provided as an optional argument in CreateActor and SendEvent. If a null EventGroup is passed then the EventGroup is inherited from the sender or target actors (based on which ever one has a CurrentEventGroup ). In this way an EventGroup is automatically communicated to all actors involved in completing some larger operation. Each actor involved can find the EventGroup using their CurrentEventGroup property. public class EventGroup","title":"EventGroup class"},{"location":"ref/Microsoft.Coyote.Actors/EventGroup/#public-members","text":"name description EventGroup (\u2026) Initializes a new instance of the EventGroup class. static Null A special null event group that can be used to stop the CurrentEventGroup from being passed along when CreateActor or SendEvent is invoked. Id { get; } The unique id of this EventGroup , initialized with Guid.Empty. Name { get; } An optional friendly name for this EventGroup .","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Actors/EventGroup/#see-also","text":"namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/HaltEvent/","text":"HaltEvent class The halt event. public sealed class HaltEvent : Event Public Members name description static Instance { get; } Gets a HaltEvent instance. See Also class Event namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Actors/HaltEvent/#haltevent-class","text":"The halt event. public sealed class HaltEvent : Event","title":"HaltEvent class"},{"location":"ref/Microsoft.Coyote.Actors/HaltEvent/#public-members","text":"name description static Instance { get; } Gets a HaltEvent instance.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Actors/HaltEvent/#see-also","text":"class Event namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/","text":"IActorRuntime interface Interface that exposes runtime methods for creating and executing actors. public interface IActorRuntime : ICoyoteRuntime Members name description event OnEventDropped Callback that is fired when an event is dropped. CreateActor (\u2026) Creates a new actor of the specified Type and with the specified optional Event . This event is given to the Event) method on the new actor. (3 methods) CreateActorId (\u2026) Creates a fresh actor id that has not yet been bound to any actor. CreateActorIdFromName (\u2026) Creates a actor id that is uniquely tied to the specified unique name. The returned actor id can either be a fresh id (not yet bound to any actor), or it can be bound to a previously created actor. In the second case, this actor id can be directly used to communicate with the corresponding actor. GetCurrentEventGroup (\u2026) Returns the current EventGroup of the actor with the specified id. Returns null if the id is not set, or if the ActorId is not associated with this runtime. During testing, the runtime asserts that the specified actor is currently executing. RegisterLog (\u2026) Use this method to register an IActorRuntimeLog . RemoveLog (\u2026) Use this method to unregister a previously registered IActorRuntimeLog . SendEvent (\u2026) Sends an asynchronous Event to an actor. Remarks See Programming model: asynchronous actors for more information. See Also interface ICoyoteRuntime namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/#iactorruntime-interface","text":"Interface that exposes runtime methods for creating and executing actors. public interface IActorRuntime : ICoyoteRuntime","title":"IActorRuntime interface"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/#members","text":"name description event OnEventDropped Callback that is fired when an event is dropped. CreateActor (\u2026) Creates a new actor of the specified Type and with the specified optional Event . This event is given to the Event) method on the new actor. (3 methods) CreateActorId (\u2026) Creates a fresh actor id that has not yet been bound to any actor. CreateActorIdFromName (\u2026) Creates a actor id that is uniquely tied to the specified unique name. The returned actor id can either be a fresh id (not yet bound to any actor), or it can be bound to a previously created actor. In the second case, this actor id can be directly used to communicate with the corresponding actor. GetCurrentEventGroup (\u2026) Returns the current EventGroup of the actor with the specified id. Returns null if the id is not set, or if the ActorId is not associated with this runtime. During testing, the runtime asserts that the specified actor is currently executing. RegisterLog (\u2026) Use this method to register an IActorRuntimeLog . RemoveLog (\u2026) Use this method to unregister a previously registered IActorRuntimeLog . SendEvent (\u2026) Sends an asynchronous Event to an actor.","title":"Members"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/#remarks","text":"See Programming model: asynchronous actors for more information.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/#see-also","text":"interface ICoyoteRuntime namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/","text":"IActorRuntimeLog interface Interface that allows an external module to track what is happening in the IActorRuntime . public interface IActorRuntimeLog Members name description OnAssertionFailure (\u2026) Invoked when the specified assertion failure has occurred. OnCompleted () Invoked when a log is complete (and is about to be closed). OnCreateActor (\u2026) Invoked when the specified actor has been created. OnCreateMonitor (\u2026) Invoked when the specified monitor has been created. OnCreateStateMachine (\u2026) Invoked when the specified state machine has been created. OnCreateTimer (\u2026) Invoked when the specified actor timer has been created. OnDefaultEventHandler (\u2026) Invoked when the specified actor is idle (there is nothing to dequeue) and the default event handler is about to be executed. OnDequeueEvent (\u2026) Invoked when the specified event is dequeued by an actor. OnEnqueueEvent (\u2026) Invoked when the specified event is about to be enqueued to an actor. OnEventHandlerTerminated (\u2026) Invoked when the event handler of the specified actor terminated. OnExceptionHandled (\u2026) Invoked when the specified OnException method is used to handle a thrown exception. OnExceptionThrown (\u2026) Invoked when the specified actor throws an exception. OnExecuteAction (\u2026) Invoked when the specified actor executes an action. OnGotoState (\u2026) Invoked when the specified state machine performs a goto transition to the specified state. OnHalt (\u2026) Invoked when the specified actor has been halted. OnHandleRaisedEvent (\u2026) Invoked when the specified actor handled a raised event. OnMonitorError (\u2026) Invoked when the specified monitor finds an error. OnMonitorExecuteAction (\u2026) Invoked when the specified monitor executes an action. OnMonitorProcessEvent (\u2026) Invoked when the specified monitor is about to process an event. OnMonitorRaiseEvent (\u2026) Invoked when the specified monitor raised an event. OnMonitorStateTransition (\u2026) Invoked when the specified monitor enters or exits a state. OnPopState (\u2026) Invoked when the specified state machine has popped its current state. OnPopStateUnhandledEvent (\u2026) Invoked when the specified event cannot be handled in the current state, its exit handler is executed and then the state is popped and any previous \u201ccurrent state\u201d is reentered. This handler is called when that pop has been done. OnPushState (\u2026) Invoked when the specified state machine is being pushed to a state. OnRaiseEvent (\u2026) Invoked when the specified state machine raises an event. OnRandom (\u2026) Invoked when the specified controlled nondeterministic result has been obtained. OnReceiveEvent (\u2026) Invoked when the specified event is received by an actor. OnSendEvent (\u2026) Invoked when the specified event is sent to a target actor. OnStateTransition (\u2026) Invoked when the specified state machine enters or exits a state. OnStopTimer (\u2026) Invoked when the specified actor timer has been stopped. OnStrategyDescription (\u2026) Invoked to describe the specified scheduling strategy. OnWaitEvent (\u2026) Invoked when the specified actor waits to receive an event of a specified type. (2 methods) Remarks See Logging for more information. See Also namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/#iactorruntimelog-interface","text":"Interface that allows an external module to track what is happening in the IActorRuntime . public interface IActorRuntimeLog","title":"IActorRuntimeLog interface"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/#members","text":"name description OnAssertionFailure (\u2026) Invoked when the specified assertion failure has occurred. OnCompleted () Invoked when a log is complete (and is about to be closed). OnCreateActor (\u2026) Invoked when the specified actor has been created. OnCreateMonitor (\u2026) Invoked when the specified monitor has been created. OnCreateStateMachine (\u2026) Invoked when the specified state machine has been created. OnCreateTimer (\u2026) Invoked when the specified actor timer has been created. OnDefaultEventHandler (\u2026) Invoked when the specified actor is idle (there is nothing to dequeue) and the default event handler is about to be executed. OnDequeueEvent (\u2026) Invoked when the specified event is dequeued by an actor. OnEnqueueEvent (\u2026) Invoked when the specified event is about to be enqueued to an actor. OnEventHandlerTerminated (\u2026) Invoked when the event handler of the specified actor terminated. OnExceptionHandled (\u2026) Invoked when the specified OnException method is used to handle a thrown exception. OnExceptionThrown (\u2026) Invoked when the specified actor throws an exception. OnExecuteAction (\u2026) Invoked when the specified actor executes an action. OnGotoState (\u2026) Invoked when the specified state machine performs a goto transition to the specified state. OnHalt (\u2026) Invoked when the specified actor has been halted. OnHandleRaisedEvent (\u2026) Invoked when the specified actor handled a raised event. OnMonitorError (\u2026) Invoked when the specified monitor finds an error. OnMonitorExecuteAction (\u2026) Invoked when the specified monitor executes an action. OnMonitorProcessEvent (\u2026) Invoked when the specified monitor is about to process an event. OnMonitorRaiseEvent (\u2026) Invoked when the specified monitor raised an event. OnMonitorStateTransition (\u2026) Invoked when the specified monitor enters or exits a state. OnPopState (\u2026) Invoked when the specified state machine has popped its current state. OnPopStateUnhandledEvent (\u2026) Invoked when the specified event cannot be handled in the current state, its exit handler is executed and then the state is popped and any previous \u201ccurrent state\u201d is reentered. This handler is called when that pop has been done. OnPushState (\u2026) Invoked when the specified state machine is being pushed to a state. OnRaiseEvent (\u2026) Invoked when the specified state machine raises an event. OnRandom (\u2026) Invoked when the specified controlled nondeterministic result has been obtained. OnReceiveEvent (\u2026) Invoked when the specified event is received by an actor. OnSendEvent (\u2026) Invoked when the specified event is sent to a target actor. OnStateTransition (\u2026) Invoked when the specified state machine enters or exits a state. OnStopTimer (\u2026) Invoked when the specified actor timer has been stopped. OnStrategyDescription (\u2026) Invoked to describe the specified scheduling strategy. OnWaitEvent (\u2026) Invoked when the specified actor waits to receive an event of a specified type. (2 methods)","title":"Members"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/#remarks","text":"See Logging for more information.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/#see-also","text":"namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/OnEventDroppedHandler/","text":"OnEventDroppedHandler delegate Handles the OnEventDropped event. public delegate void OnEventDroppedHandler(Event e, ActorId target); See Also class Event class ActorId namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnEventDroppedHandler"},{"location":"ref/Microsoft.Coyote.Actors/OnEventDroppedHandler/#oneventdroppedhandler-delegate","text":"Handles the OnEventDropped event. public delegate void OnEventDroppedHandler(Event e, ActorId target);","title":"OnEventDroppedHandler delegate"},{"location":"ref/Microsoft.Coyote.Actors/OnEventDroppedHandler/#see-also","text":"class Event class ActorId namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/OnExceptionOutcome/","text":"OnExceptionOutcome enumeration The outcome when an Actor throws an exception. public enum OnExceptionOutcome Values name value description ThrowException 0 The actor throws the exception causing the runtime to fail. HandledException 1 The actor handles the exception and resumes execution. Halt 2 The actor handles the exception and halts. See Also namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnExceptionOutcome"},{"location":"ref/Microsoft.Coyote.Actors/OnExceptionOutcome/#onexceptionoutcome-enumeration","text":"The outcome when an Actor throws an exception. public enum OnExceptionOutcome","title":"OnExceptionOutcome enumeration"},{"location":"ref/Microsoft.Coyote.Actors/OnExceptionOutcome/#values","text":"name value description ThrowException 0 The actor throws the exception causing the runtime to fail. HandledException 1 The actor handles the exception and resumes execution. Halt 2 The actor handles the exception and halts.","title":"Values"},{"location":"ref/Microsoft.Coyote.Actors/OnExceptionOutcome/#see-also","text":"namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/RuntimeFactory/","text":"RuntimeFactory class Provides methods for creating a IActorRuntime runtime. public static class RuntimeFactory Public Members name description static Create () Creates a new actor runtime. static Create (\u2026) Creates a new actor runtime with the specified Configuration . See Also namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Actors/RuntimeFactory/#runtimefactory-class","text":"Provides methods for creating a IActorRuntime runtime. public static class RuntimeFactory","title":"RuntimeFactory class"},{"location":"ref/Microsoft.Coyote.Actors/RuntimeFactory/#public-members","text":"name description static Create () Creates a new actor runtime. static Create (\u2026) Creates a new actor runtime with the specified Configuration .","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Actors/RuntimeFactory/#see-also","text":"namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/SendOptions/","text":"SendOptions class Represents a send event configuration that is used during testing. public class SendOptions Public Members name description SendOptions (\u2026) Initializes a new instance of the SendOptions class. static Default { get; } The default send options. Assert { get; } Asserts that there must not be more than N instances of the event in the inbox queue of the receiver. HashedState { get; } User-defined hash of the event. The default value is 0. Override to improve the accuracy of stateful techniques during testing. MustHandle { get; } True if this event must always be handled, else false. override ToString () A string that represents the current options. See Also namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Actors/SendOptions/#sendoptions-class","text":"Represents a send event configuration that is used during testing. public class SendOptions","title":"SendOptions class"},{"location":"ref/Microsoft.Coyote.Actors/SendOptions/#public-members","text":"name description SendOptions (\u2026) Initializes a new instance of the SendOptions class. static Default { get; } The default send options. Assert { get; } Asserts that there must not be more than N instances of the event in the inbox queue of the receiver. HashedState { get; } User-defined hash of the event. The default value is 0. Override to improve the accuracy of stateful techniques during testing. MustHandle { get; } True if this event must always be handled, else false. override ToString () A string that represents the current options.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Actors/SendOptions/#see-also","text":"namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.DeferEventsAttribute/","text":"StateMachine.State.DeferEventsAttribute class Attribute for declaring what events should be deferred in a state. [AttributeUsage(AttributeTargets.Class)] protected sealed class DeferEventsAttribute : Attribute Public Members name description DeferEventsAttribute (\u2026) Initializes a new instance of the DeferEventsAttribute class. See Also class State namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.DeferEventsAttribute/#statemachinestatedefereventsattribute-class","text":"Attribute for declaring what events should be deferred in a state. [AttributeUsage(AttributeTargets.Class)] protected sealed class DeferEventsAttribute : Attribute","title":"StateMachine.State.DeferEventsAttribute class"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.DeferEventsAttribute/#public-members","text":"name description DeferEventsAttribute (\u2026) Initializes a new instance of the DeferEventsAttribute class.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.DeferEventsAttribute/#see-also","text":"class State namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.IgnoreEventsAttribute/","text":"StateMachine.State.IgnoreEventsAttribute class Attribute for declaring what events should be ignored in a state. [AttributeUsage(AttributeTargets.Class)] protected sealed class IgnoreEventsAttribute : Attribute Public Members name description IgnoreEventsAttribute (\u2026) Initializes a new instance of the IgnoreEventsAttribute class. See Also class State namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.IgnoreEventsAttribute/#statemachinestateignoreeventsattribute-class","text":"Attribute for declaring what events should be ignored in a state. [AttributeUsage(AttributeTargets.Class)] protected sealed class IgnoreEventsAttribute : Attribute","title":"StateMachine.State.IgnoreEventsAttribute class"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.IgnoreEventsAttribute/#public-members","text":"name description IgnoreEventsAttribute (\u2026) Initializes a new instance of the IgnoreEventsAttribute class.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.IgnoreEventsAttribute/#see-also","text":"class State namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnEntryAttribute/","text":"StateMachine.State.OnEntryAttribute class Attribute for declaring what action to perform when entering a state. [AttributeUsage(AttributeTargets.Class)] protected sealed class OnEntryAttribute : Attribute Public Members name description OnEntryAttribute (\u2026) Initializes a new instance of the OnEntryAttribute class. See Also class State namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnEntryAttribute/#statemachinestateonentryattribute-class","text":"Attribute for declaring what action to perform when entering a state. [AttributeUsage(AttributeTargets.Class)] protected sealed class OnEntryAttribute : Attribute","title":"StateMachine.State.OnEntryAttribute class"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnEntryAttribute/#public-members","text":"name description OnEntryAttribute (\u2026) Initializes a new instance of the OnEntryAttribute class.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnEntryAttribute/#see-also","text":"class State namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnEventDoActionAttribute/","text":"StateMachine.State.OnEventDoActionAttribute class Attribute for declaring which action should be invoked when the state machine is in the specified state to handle a dequeued event of the specified type. [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] protected sealed class OnEventDoActionAttribute : Attribute Public Members name description OnEventDoActionAttribute (\u2026) Initializes a new instance of the OnEventDoActionAttribute class. See Also class State namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnEventDoActionAttribute/#statemachinestateoneventdoactionattribute-class","text":"Attribute for declaring which action should be invoked when the state machine is in the specified state to handle a dequeued event of the specified type. [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] protected sealed class OnEventDoActionAttribute : Attribute","title":"StateMachine.State.OnEventDoActionAttribute class"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnEventDoActionAttribute/#public-members","text":"name description OnEventDoActionAttribute (\u2026) Initializes a new instance of the OnEventDoActionAttribute class.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnEventDoActionAttribute/#see-also","text":"class State namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnEventGotoStateAttribute/","text":"StateMachine.State.OnEventGotoStateAttribute class Attribute for declaring a goto state transition when the state machine is in the specified state and dequeues an event of the specified type. [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] protected sealed class OnEventGotoStateAttribute : Attribute Public Members name description OnEventGotoStateAttribute (\u2026) Initializes a new instance of the OnEventGotoStateAttribute class. (2 constructors) See Also class State namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnEventGotoStateAttribute/#statemachinestateoneventgotostateattribute-class","text":"Attribute for declaring a goto state transition when the state machine is in the specified state and dequeues an event of the specified type. [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] protected sealed class OnEventGotoStateAttribute : Attribute","title":"StateMachine.State.OnEventGotoStateAttribute class"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnEventGotoStateAttribute/#public-members","text":"name description OnEventGotoStateAttribute (\u2026) Initializes a new instance of the OnEventGotoStateAttribute class. (2 constructors)","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnEventGotoStateAttribute/#see-also","text":"class State namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnEventPushStateAttribute/","text":"StateMachine.State.OnEventPushStateAttribute class Attribute for declaring a push state transition when the state machine is in the specified state and dequeues an event of the specified type. [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] protected sealed class OnEventPushStateAttribute : Attribute Public Members name description OnEventPushStateAttribute (\u2026) Initializes a new instance of the OnEventPushStateAttribute class. See Also class State namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnEventPushStateAttribute/#statemachinestateoneventpushstateattribute-class","text":"Attribute for declaring a push state transition when the state machine is in the specified state and dequeues an event of the specified type. [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] protected sealed class OnEventPushStateAttribute : Attribute","title":"StateMachine.State.OnEventPushStateAttribute class"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnEventPushStateAttribute/#public-members","text":"name description OnEventPushStateAttribute (\u2026) Initializes a new instance of the OnEventPushStateAttribute class.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnEventPushStateAttribute/#see-also","text":"class State namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnExitAttribute/","text":"StateMachine.State.OnExitAttribute class Attribute for declaring what action to perform when exiting a state. [AttributeUsage(AttributeTargets.Class)] protected sealed class OnExitAttribute : Attribute Public Members name description OnExitAttribute (\u2026) Initializes a new instance of the OnExitAttribute class. See Also class State namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnExitAttribute/#statemachinestateonexitattribute-class","text":"Attribute for declaring what action to perform when exiting a state. [AttributeUsage(AttributeTargets.Class)] protected sealed class OnExitAttribute : Attribute","title":"StateMachine.State.OnExitAttribute class"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnExitAttribute/#public-members","text":"name description OnExitAttribute (\u2026) Initializes a new instance of the OnExitAttribute class.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnExitAttribute/#see-also","text":"class State namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.StartAttribute/","text":"StateMachine.State.StartAttribute class Attribute for declaring the state that a state machine transitions upon creation. [AttributeUsage(AttributeTargets.Class)] protected sealed class StartAttribute : Attribute Public Members name description StartAttribute () The default constructor. See Also class State namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.StartAttribute/#statemachinestatestartattribute-class","text":"Attribute for declaring the state that a state machine transitions upon creation. [AttributeUsage(AttributeTargets.Class)] protected sealed class StartAttribute : Attribute","title":"StateMachine.State.StartAttribute class"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.StartAttribute/#public-members","text":"name description StartAttribute () The default constructor.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.StartAttribute/#see-also","text":"class State namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State/","text":"StateMachine.State class Abstract class representing a state. public abstract class State Protected Members name description State () Initializes a new instance of the State class. class DeferEventsAttribute Attribute for declaring what events should be deferred in a state. class IgnoreEventsAttribute Attribute for declaring what events should be ignored in a state. class OnEntryAttribute Attribute for declaring what action to perform when entering a state. class OnEventDoActionAttribute Attribute for declaring which action should be invoked when the state machine is in the specified state to handle a dequeued event of the specified type. class OnEventGotoStateAttribute Attribute for declaring a goto state transition when the state machine is in the specified state and dequeues an event of the specified type. class OnEventPushStateAttribute Attribute for declaring a push state transition when the state machine is in the specified state and dequeues an event of the specified type. class OnExitAttribute Attribute for declaring what action to perform when exiting a state. class StartAttribute Attribute for declaring the state that a state machine transitions upon creation. Remarks See State machines for more information. See Also class StateMachine namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State/#statemachinestate-class","text":"Abstract class representing a state. public abstract class State","title":"StateMachine.State class"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State/#protected-members","text":"name description State () Initializes a new instance of the State class. class DeferEventsAttribute Attribute for declaring what events should be deferred in a state. class IgnoreEventsAttribute Attribute for declaring what events should be ignored in a state. class OnEntryAttribute Attribute for declaring what action to perform when entering a state. class OnEventDoActionAttribute Attribute for declaring which action should be invoked when the state machine is in the specified state to handle a dequeued event of the specified type. class OnEventGotoStateAttribute Attribute for declaring a goto state transition when the state machine is in the specified state and dequeues an event of the specified type. class OnEventPushStateAttribute Attribute for declaring a push state transition when the state machine is in the specified state and dequeues an event of the specified type. class OnExitAttribute Attribute for declaring what action to perform when exiting a state. class StartAttribute Attribute for declaring the state that a state machine transitions upon creation.","title":"Protected Members"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State/#remarks","text":"See State machines for more information.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State/#see-also","text":"class StateMachine namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.StateGroup/","text":"StateMachine.StateGroup class Abstract class used for representing a group of related states. public abstract class StateGroup Protected Members name description StateGroup () The default constructor. See Also class StateMachine namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.StateGroup/#statemachinestategroup-class","text":"Abstract class used for representing a group of related states. public abstract class StateGroup","title":"StateMachine.StateGroup class"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.StateGroup/#protected-members","text":"name description StateGroup () The default constructor.","title":"Protected Members"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.StateGroup/#see-also","text":"class StateMachine namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/","text":"StateMachine class Type that implements a state machine actor. Inherit from this class to declare a custom actor with states, state transitions and event handlers. public abstract class StateMachine : Actor Public Members name description abstract class State Abstract class representing a state. abstract class StateGroup Abstract class used for representing a group of related states. Protected Members name description StateMachine () Initializes a new instance of the StateMachine class. CurrentState { get; } Gets the Type of the current state. override OnEventHandledAsync (\u2026) Asynchronous callback that is invoked when the actor finishes handling a dequeued event, unless the handler of the dequeued event raised an event or caused the actor to halt (either normally or due to an exception). Unless this callback raises an event, the actor will either become idle or dequeue the next event from its inbox. RaiseEvent (\u2026) Raises the specified Event at the end of the current action. RaiseGotoStateEvent (\u2026) Raise a special event that performs a goto state operation at the end of the current action. RaiseGotoStateEvent<TState> () Raise a special event that performs a goto state operation at the end of the current action. RaiseHaltEvent () Raises a HaltEvent to halt the actor at the end of the current action. RaisePopStateEvent () Raise a special event that performs a pop state operation at the end of the current action. RaisePushStateEvent (\u2026) Raise a special event that performs a push state operation at the end of the current action. RaisePushStateEvent<TState> () Raise a special event that performs a push state operation at the end of the current action. Remarks See State machines for more information. See Also class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/#statemachine-class","text":"Type that implements a state machine actor. Inherit from this class to declare a custom actor with states, state transitions and event handlers. public abstract class StateMachine : Actor","title":"StateMachine class"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/#public-members","text":"name description abstract class State Abstract class representing a state. abstract class StateGroup Abstract class used for representing a group of related states.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/#protected-members","text":"name description StateMachine () Initializes a new instance of the StateMachine class. CurrentState { get; } Gets the Type of the current state. override OnEventHandledAsync (\u2026) Asynchronous callback that is invoked when the actor finishes handling a dequeued event, unless the handler of the dequeued event raised an event or caused the actor to halt (either normally or due to an exception). Unless this callback raises an event, the actor will either become idle or dequeue the next event from its inbox. RaiseEvent (\u2026) Raises the specified Event at the end of the current action. RaiseGotoStateEvent (\u2026) Raise a special event that performs a goto state operation at the end of the current action. RaiseGotoStateEvent<TState> () Raise a special event that performs a goto state operation at the end of the current action. RaiseHaltEvent () Raises a HaltEvent to halt the actor at the end of the current action. RaisePopStateEvent () Raise a special event that performs a pop state operation at the end of the current action. RaisePushStateEvent (\u2026) Raise a special event that performs a push state operation at the end of the current action. RaisePushStateEvent<TState> () Raise a special event that performs a push state operation at the end of the current action.","title":"Protected Members"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/#remarks","text":"See State machines for more information.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/#see-also","text":"class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/UnhandledEventException/","text":"UnhandledEventException class Signals that an Actor received an unhandled event. public sealed class UnhandledEventException : RuntimeException Public Members name description CurrentStateName The name of the current state, if the actor that threw the exception is a StateMachine and a state exists, else null. UnhandledEvent The unhandled event. See Also class RuntimeException namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Actors/UnhandledEventException/#unhandledeventexception-class","text":"Signals that an Actor received an unhandled event. public sealed class UnhandledEventException : RuntimeException","title":"UnhandledEventException class"},{"location":"ref/Microsoft.Coyote.Actors/UnhandledEventException/#public-members","text":"name description CurrentStateName The name of the current state, if the actor that threw the exception is a StateMachine and a state exists, else null. UnhandledEvent The unhandled event.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Actors/UnhandledEventException/#see-also","text":"class RuntimeException namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/WildCardEvent/","text":"WildCardEvent class The wild card event. public sealed class WildCardEvent : Event Public Members name description WildCardEvent () Initializes a new instance of the WildCardEvent class. See Also class Event namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Actors/WildCardEvent/#wildcardevent-class","text":"The wild card event. public sealed class WildCardEvent : Event","title":"WildCardEvent class"},{"location":"ref/Microsoft.Coyote.Actors/WildCardEvent/#public-members","text":"name description WildCardEvent () Initializes a new instance of the WildCardEvent class.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Actors/WildCardEvent/#see-also","text":"class Event namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/Actor/","text":"Actor constructor Initializes a new instance of the Actor class. protected Actor() See Also class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Actor"},{"location":"ref/Microsoft.Coyote.Actors/Actor/Actor/#actor-constructor","text":"Initializes a new instance of the Actor class. protected Actor()","title":"Actor constructor"},{"location":"ref/Microsoft.Coyote.Actors/Actor/Actor/#see-also","text":"class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/Assert/","text":"Actor.Assert method (1 of 5) Checks if the assertion holds, and if not, throws an AssertionFailureException exception. protected void Assert(bool predicate) See Also class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote Actor.Assert method (2 of 5) Checks if the assertion holds, and if not, throws an AssertionFailureException exception. protected void Assert(bool predicate, string s, object arg0) See Also class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote Actor.Assert method (3 of 5) Checks if the assertion holds, and if not, throws an AssertionFailureException exception. protected void Assert(bool predicate, string s, params object[] args) See Also class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote Actor.Assert method (4 of 5) Checks if the assertion holds, and if not, throws an AssertionFailureException exception. protected void Assert(bool predicate, string s, object arg0, object arg1) See Also class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote Actor.Assert method (5 of 5) Checks if the assertion holds, and if not, throws an AssertionFailureException exception. protected void Assert(bool predicate, string s, object arg0, object arg1, object arg2) See Also class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Assert"},{"location":"ref/Microsoft.Coyote.Actors/Actor/Assert/#actorassert-method-1-of-5","text":"Checks if the assertion holds, and if not, throws an AssertionFailureException exception. protected void Assert(bool predicate)","title":"Actor.Assert method (1 of 5)"},{"location":"ref/Microsoft.Coyote.Actors/Actor/Assert/#see-also","text":"class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/Assert/#actorassert-method-2-of-5","text":"Checks if the assertion holds, and if not, throws an AssertionFailureException exception. protected void Assert(bool predicate, string s, object arg0)","title":"Actor.Assert method (2 of 5)"},{"location":"ref/Microsoft.Coyote.Actors/Actor/Assert/#see-also_1","text":"class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/Assert/#actorassert-method-3-of-5","text":"Checks if the assertion holds, and if not, throws an AssertionFailureException exception. protected void Assert(bool predicate, string s, params object[] args)","title":"Actor.Assert method (3 of 5)"},{"location":"ref/Microsoft.Coyote.Actors/Actor/Assert/#see-also_2","text":"class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/Assert/#actorassert-method-4-of-5","text":"Checks if the assertion holds, and if not, throws an AssertionFailureException exception. protected void Assert(bool predicate, string s, object arg0, object arg1)","title":"Actor.Assert method (4 of 5)"},{"location":"ref/Microsoft.Coyote.Actors/Actor/Assert/#see-also_3","text":"class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/Assert/#actorassert-method-5-of-5","text":"Checks if the assertion holds, and if not, throws an AssertionFailureException exception. protected void Assert(bool predicate, string s, object arg0, object arg1, object arg2)","title":"Actor.Assert method (5 of 5)"},{"location":"ref/Microsoft.Coyote.Actors/Actor/Assert/#see-also_4","text":"class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/CreateActor/","text":"Actor.CreateActor method (1 of 3) Creates a new actor of the specified type and with the specified optional Event . This Event can only be used to access its payload, and cannot be handled. protected ActorId CreateActor(Type type, Event initialEvent = null, EventGroup eventGroup = null) parameter description type Type of the actor. initialEvent Optional initialization event. eventGroup An optional event group associated with the new Actor. Return Value The unique actor id. See Also class ActorId class Event class EventGroup class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote Actor.CreateActor method (2 of 3) Creates a new actor of the specified type and name, and with the specified optional Event . This Event can only be used to access its payload, and cannot be handled. protected ActorId CreateActor(Type type, string name, Event initialEvent = null, EventGroup eventGroup = null) parameter description type Type of the actor. name Optional name used for logging. initialEvent Optional initialization event. eventGroup An optional event group associated with the new Actor. Return Value The unique actor id. See Also class ActorId class Event class EventGroup class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote Actor.CreateActor method (3 of 3) Creates a new actor of the specified Type and name, using the specified unbound actor id, and passes the specified optional Event . This event can only be used to access its payload, and cannot be handled. protected void CreateActor(ActorId id, Type type, string name, Event initialEvent = null, EventGroup eventGroup = null) parameter description id Unbound actor id. type Type of the actor. name Optional name used for logging. initialEvent Optional initialization event. eventGroup An optional event group associated with the new Actor. See Also class ActorId class Event class EventGroup class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"CreateActor"},{"location":"ref/Microsoft.Coyote.Actors/Actor/CreateActor/#actorcreateactor-method-1-of-3","text":"Creates a new actor of the specified type and with the specified optional Event . This Event can only be used to access its payload, and cannot be handled. protected ActorId CreateActor(Type type, Event initialEvent = null, EventGroup eventGroup = null) parameter description type Type of the actor. initialEvent Optional initialization event. eventGroup An optional event group associated with the new Actor.","title":"Actor.CreateActor method (1 of 3)"},{"location":"ref/Microsoft.Coyote.Actors/Actor/CreateActor/#return-value","text":"The unique actor id.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Actors/Actor/CreateActor/#see-also","text":"class ActorId class Event class EventGroup class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/CreateActor/#actorcreateactor-method-2-of-3","text":"Creates a new actor of the specified type and name, and with the specified optional Event . This Event can only be used to access its payload, and cannot be handled. protected ActorId CreateActor(Type type, string name, Event initialEvent = null, EventGroup eventGroup = null) parameter description type Type of the actor. name Optional name used for logging. initialEvent Optional initialization event. eventGroup An optional event group associated with the new Actor.","title":"Actor.CreateActor method (2 of 3)"},{"location":"ref/Microsoft.Coyote.Actors/Actor/CreateActor/#return-value_1","text":"The unique actor id.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Actors/Actor/CreateActor/#see-also_1","text":"class ActorId class Event class EventGroup class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/CreateActor/#actorcreateactor-method-3-of-3","text":"Creates a new actor of the specified Type and name, using the specified unbound actor id, and passes the specified optional Event . This event can only be used to access its payload, and cannot be handled. protected void CreateActor(ActorId id, Type type, string name, Event initialEvent = null, EventGroup eventGroup = null) parameter description id Unbound actor id. type Type of the actor. name Optional name used for logging. initialEvent Optional initialization event. eventGroup An optional event group associated with the new Actor.","title":"Actor.CreateActor method (3 of 3)"},{"location":"ref/Microsoft.Coyote.Actors/Actor/CreateActor/#see-also_2","text":"class ActorId class Event class EventGroup class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/CurrentEventGroup/","text":"Actor.CurrentEventGroup property An optional EventGroup associated with the current event being handled. public EventGroup CurrentEventGroup { get; set; } Remarks This is an optional argument provided to CreateActor or SendEvent . See Also class EventGroup class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"CurrentEventGroup"},{"location":"ref/Microsoft.Coyote.Actors/Actor/CurrentEventGroup/#actorcurrenteventgroup-property","text":"An optional EventGroup associated with the current event being handled. public EventGroup CurrentEventGroup { get; set; }","title":"Actor.CurrentEventGroup property"},{"location":"ref/Microsoft.Coyote.Actors/Actor/CurrentEventGroup/#remarks","text":"This is an optional argument provided to CreateActor or SendEvent .","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Actors/Actor/CurrentEventGroup/#see-also","text":"class EventGroup class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/Equals/","text":"Actor.Equals method Determines whether the specified object is equal to the current object. public override bool Equals(object obj) See Also class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Equals"},{"location":"ref/Microsoft.Coyote.Actors/Actor/Equals/#actorequals-method","text":"Determines whether the specified object is equal to the current object. public override bool Equals(object obj)","title":"Actor.Equals method"},{"location":"ref/Microsoft.Coyote.Actors/Actor/Equals/#see-also","text":"class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/GetHashCode/","text":"Actor.GetHashCode method Returns the hash code for this instance. public override int GetHashCode() See Also class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"GetHashCode"},{"location":"ref/Microsoft.Coyote.Actors/Actor/GetHashCode/#actorgethashcode-method","text":"Returns the hash code for this instance. public override int GetHashCode()","title":"Actor.GetHashCode method"},{"location":"ref/Microsoft.Coyote.Actors/Actor/GetHashCode/#see-also","text":"class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/HashedState/","text":"Actor.HashedState property User-defined hashed state of the actor. Override to improve the accuracy of stateful techniques during testing. protected virtual int HashedState { get; } See Also class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"HashedState"},{"location":"ref/Microsoft.Coyote.Actors/Actor/HashedState/#actorhashedstate-property","text":"User-defined hashed state of the actor. Override to improve the accuracy of stateful techniques during testing. protected virtual int HashedState { get; }","title":"Actor.HashedState property"},{"location":"ref/Microsoft.Coyote.Actors/Actor/HashedState/#see-also","text":"class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/Id/","text":"Actor.Id property Unique id that identifies this actor. protected internal ActorId Id { get; } See Also class ActorId class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Id"},{"location":"ref/Microsoft.Coyote.Actors/Actor/Id/#actorid-property","text":"Unique id that identifies this actor. protected internal ActorId Id { get; }","title":"Actor.Id property"},{"location":"ref/Microsoft.Coyote.Actors/Actor/Id/#see-also","text":"class ActorId class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/Logger/","text":"Actor.Logger property The logger installed to the runtime. protected ILogger Logger { get; } Remarks See Logging for more information. See Also interface ILogger class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Logger"},{"location":"ref/Microsoft.Coyote.Actors/Actor/Logger/#actorlogger-property","text":"The logger installed to the runtime. protected ILogger Logger { get; }","title":"Actor.Logger property"},{"location":"ref/Microsoft.Coyote.Actors/Actor/Logger/#remarks","text":"See Logging for more information.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Actors/Actor/Logger/#see-also","text":"interface ILogger class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/Monitor/","text":"Actor.Monitor method (1 of 2) Invokes the specified monitor with the specified event. protected void Monitor(Type type, Event e) parameter description type Type of the monitor. e The event to send. See Also class Event class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote Actor.Monitor<T> method (2 of 2) Invokes the specified monitor with the specified Event . protected void Monitor<T>(Event e) parameter description T Type of the monitor. e Event to send to the monitor. See Also class Event class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Monitor"},{"location":"ref/Microsoft.Coyote.Actors/Actor/Monitor/#actormonitor-method-1-of-2","text":"Invokes the specified monitor with the specified event. protected void Monitor(Type type, Event e) parameter description type Type of the monitor. e The event to send.","title":"Actor.Monitor method (1 of 2)"},{"location":"ref/Microsoft.Coyote.Actors/Actor/Monitor/#see-also","text":"class Event class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/Monitor/#actormonitort-method-2-of-2","text":"Invokes the specified monitor with the specified Event . protected void Monitor<T>(Event e) parameter description T Type of the monitor. e Event to send to the monitor.","title":"Actor.Monitor&lt;T&gt; method (2 of 2)"},{"location":"ref/Microsoft.Coyote.Actors/Actor/Monitor/#see-also_1","text":"class Event class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/OnEventDeferred/","text":"Actor.OnEventDeferred method Callback that is invoked when the actor defers dequeing an event from its inbox. protected virtual void OnEventDeferred(Event e) parameter description e The event that was deferred. See Also class Event class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnEventDeferred"},{"location":"ref/Microsoft.Coyote.Actors/Actor/OnEventDeferred/#actoroneventdeferred-method","text":"Callback that is invoked when the actor defers dequeing an event from its inbox. protected virtual void OnEventDeferred(Event e) parameter description e The event that was deferred.","title":"Actor.OnEventDeferred method"},{"location":"ref/Microsoft.Coyote.Actors/Actor/OnEventDeferred/#see-also","text":"class Event class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/OnEventDequeuedAsync/","text":"Actor.OnEventDequeuedAsync method Asynchronous callback that is invoked when the actor successfully dequeues an event from its inbox. This method is not called when the dequeue happens via a receive statement. protected virtual Task OnEventDequeuedAsync(Event e) parameter description e The event that was dequeued. See Also class Event class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnEventDequeuedAsync"},{"location":"ref/Microsoft.Coyote.Actors/Actor/OnEventDequeuedAsync/#actoroneventdequeuedasync-method","text":"Asynchronous callback that is invoked when the actor successfully dequeues an event from its inbox. This method is not called when the dequeue happens via a receive statement. protected virtual Task OnEventDequeuedAsync(Event e) parameter description e The event that was dequeued.","title":"Actor.OnEventDequeuedAsync method"},{"location":"ref/Microsoft.Coyote.Actors/Actor/OnEventDequeuedAsync/#see-also","text":"class Event class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/OnEventHandledAsync/","text":"Actor.OnEventHandledAsync method Asynchronous callback that is invoked when the actor finishes handling a dequeued event, unless the handler of the dequeued event caused the actor to halt (either normally or due to an exception). The actor will either become idle or dequeue the next event from its inbox. protected virtual Task OnEventHandledAsync(Event e) parameter description e The event that was handled. See Also class Event class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnEventHandledAsync"},{"location":"ref/Microsoft.Coyote.Actors/Actor/OnEventHandledAsync/#actoroneventhandledasync-method","text":"Asynchronous callback that is invoked when the actor finishes handling a dequeued event, unless the handler of the dequeued event caused the actor to halt (either normally or due to an exception). The actor will either become idle or dequeue the next event from its inbox. protected virtual Task OnEventHandledAsync(Event e) parameter description e The event that was handled.","title":"Actor.OnEventHandledAsync method"},{"location":"ref/Microsoft.Coyote.Actors/Actor/OnEventHandledAsync/#see-also","text":"class Event class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/OnEventIgnored/","text":"Actor.OnEventIgnored method Callback that is invoked when the actor ignores an event and removes it from its inbox. protected virtual void OnEventIgnored(Event e) parameter description e The event that was ignored. See Also class Event class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnEventIgnored"},{"location":"ref/Microsoft.Coyote.Actors/Actor/OnEventIgnored/#actoroneventignored-method","text":"Callback that is invoked when the actor ignores an event and removes it from its inbox. protected virtual void OnEventIgnored(Event e) parameter description e The event that was ignored.","title":"Actor.OnEventIgnored method"},{"location":"ref/Microsoft.Coyote.Actors/Actor/OnEventIgnored/#see-also","text":"class Event class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/OnEventUnhandledAsync/","text":"Actor.OnEventUnhandledAsync method Asynchronous callback that is invoked when the actor receives an event that it is not prepared to handle. The callback is invoked first, after which the actor will necessarily throw an UnhandledEventException . protected virtual Task OnEventUnhandledAsync(Event e, string state) parameter description e The event that was unhandled. state The state when the event was dequeued. See Also class Event class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnEventUnhandledAsync"},{"location":"ref/Microsoft.Coyote.Actors/Actor/OnEventUnhandledAsync/#actoroneventunhandledasync-method","text":"Asynchronous callback that is invoked when the actor receives an event that it is not prepared to handle. The callback is invoked first, after which the actor will necessarily throw an UnhandledEventException . protected virtual Task OnEventUnhandledAsync(Event e, string state) parameter description e The event that was unhandled. state The state when the event was dequeued.","title":"Actor.OnEventUnhandledAsync method"},{"location":"ref/Microsoft.Coyote.Actors/Actor/OnEventUnhandledAsync/#see-also","text":"class Event class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/OnException/","text":"Actor.OnException method Callback that is invoked when the actor throws an exception. By default, the actor throws the exception causing the runtime to fail. protected virtual OnExceptionOutcome OnException(Exception ex, string methodName, Event e) parameter description ex The exception thrown by the actor. methodName The handler (outermost) that threw the exception. e The event being handled when the exception was thrown. Return Value The action that the runtime should take. See Also enum OnExceptionOutcome class Event class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnException"},{"location":"ref/Microsoft.Coyote.Actors/Actor/OnException/#actoronexception-method","text":"Callback that is invoked when the actor throws an exception. By default, the actor throws the exception causing the runtime to fail. protected virtual OnExceptionOutcome OnException(Exception ex, string methodName, Event e) parameter description ex The exception thrown by the actor. methodName The handler (outermost) that threw the exception. e The event being handled when the exception was thrown.","title":"Actor.OnException method"},{"location":"ref/Microsoft.Coyote.Actors/Actor/OnException/#return-value","text":"The action that the runtime should take.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Actors/Actor/OnException/#see-also","text":"enum OnExceptionOutcome class Event class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/OnExceptionHandledAsync/","text":"Actor.OnExceptionHandledAsync method Asynchronous callback that is invoked when the actor handles an exception. protected virtual Task OnExceptionHandledAsync(Exception ex, Event e) parameter description ex The exception thrown by the actor. e The event being handled when the exception was thrown. Return Value The action that the runtime should take. See Also class Event class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnExceptionHandledAsync"},{"location":"ref/Microsoft.Coyote.Actors/Actor/OnExceptionHandledAsync/#actoronexceptionhandledasync-method","text":"Asynchronous callback that is invoked when the actor handles an exception. protected virtual Task OnExceptionHandledAsync(Exception ex, Event e) parameter description ex The exception thrown by the actor. e The event being handled when the exception was thrown.","title":"Actor.OnExceptionHandledAsync method"},{"location":"ref/Microsoft.Coyote.Actors/Actor/OnExceptionHandledAsync/#return-value","text":"The action that the runtime should take.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Actors/Actor/OnExceptionHandledAsync/#see-also","text":"class Event class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/OnHaltAsync/","text":"Actor.OnHaltAsync method Asynchronous callback that is invoked when the actor halts. protected virtual Task OnHaltAsync(Event e) parameter description e The event being handled when the actor halted. Return Value Task that represents the asynchronous operation. See Also class Event class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnHaltAsync"},{"location":"ref/Microsoft.Coyote.Actors/Actor/OnHaltAsync/#actoronhaltasync-method","text":"Asynchronous callback that is invoked when the actor halts. protected virtual Task OnHaltAsync(Event e) parameter description e The event being handled when the actor halted.","title":"Actor.OnHaltAsync method"},{"location":"ref/Microsoft.Coyote.Actors/Actor/OnHaltAsync/#return-value","text":"Task that represents the asynchronous operation.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Actors/Actor/OnHaltAsync/#see-also","text":"class Event class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/OnInitializeAsync/","text":"Actor.OnInitializeAsync method Asynchronous callback that is invoked when the actor is initialized with an optional event. protected virtual Task OnInitializeAsync(Event initialEvent) parameter description initialEvent Optional event used for initialization. Return Value Task that represents the asynchronous operation. See Also class Event class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnInitializeAsync"},{"location":"ref/Microsoft.Coyote.Actors/Actor/OnInitializeAsync/#actoroninitializeasync-method","text":"Asynchronous callback that is invoked when the actor is initialized with an optional event. protected virtual Task OnInitializeAsync(Event initialEvent) parameter description initialEvent Optional event used for initialization.","title":"Actor.OnInitializeAsync method"},{"location":"ref/Microsoft.Coyote.Actors/Actor/OnInitializeAsync/#return-value","text":"Task that represents the asynchronous operation.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Actors/Actor/OnInitializeAsync/#see-also","text":"class Event class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/RaiseHaltEvent/","text":"Actor.RaiseHaltEvent method Raises a HaltEvent to halt the actor at the end of the current action. protected void RaiseHaltEvent() See Also class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"RaiseHaltEvent"},{"location":"ref/Microsoft.Coyote.Actors/Actor/RaiseHaltEvent/#actorraisehaltevent-method","text":"Raises a HaltEvent to halt the actor at the end of the current action. protected void RaiseHaltEvent()","title":"Actor.RaiseHaltEvent method"},{"location":"ref/Microsoft.Coyote.Actors/Actor/RaiseHaltEvent/#see-also","text":"class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/RandomBoolean/","text":"Actor.RandomBoolean method (1 of 2) Returns a nondeterministic boolean choice, that can be controlled during analysis or testing. protected bool RandomBoolean() Return Value The controlled nondeterministic choice. See Also class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote Actor.RandomBoolean method (2 of 2) Returns a nondeterministic boolean choice, that can be controlled during analysis or testing. The value is used to generate a number in the range [0..maxValue), where 0 triggers true. protected bool RandomBoolean(int maxValue) parameter description maxValue The max value. Return Value The controlled nondeterministic choice. See Also class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"RandomBoolean"},{"location":"ref/Microsoft.Coyote.Actors/Actor/RandomBoolean/#actorrandomboolean-method-1-of-2","text":"Returns a nondeterministic boolean choice, that can be controlled during analysis or testing. protected bool RandomBoolean()","title":"Actor.RandomBoolean method (1 of 2)"},{"location":"ref/Microsoft.Coyote.Actors/Actor/RandomBoolean/#return-value","text":"The controlled nondeterministic choice.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Actors/Actor/RandomBoolean/#see-also","text":"class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/RandomBoolean/#actorrandomboolean-method-2-of-2","text":"Returns a nondeterministic boolean choice, that can be controlled during analysis or testing. The value is used to generate a number in the range [0..maxValue), where 0 triggers true. protected bool RandomBoolean(int maxValue) parameter description maxValue The max value.","title":"Actor.RandomBoolean method (2 of 2)"},{"location":"ref/Microsoft.Coyote.Actors/Actor/RandomBoolean/#return-value_1","text":"The controlled nondeterministic choice.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Actors/Actor/RandomBoolean/#see-also_1","text":"class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/RandomInteger/","text":"Actor.RandomInteger method Returns a nondeterministic integer, that can be controlled during analysis or testing. The value is used to generate an integer in the range [0..maxValue). protected int RandomInteger(int maxValue) parameter description maxValue The max value. Return Value The controlled nondeterministic integer. See Also class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"RandomInteger"},{"location":"ref/Microsoft.Coyote.Actors/Actor/RandomInteger/#actorrandominteger-method","text":"Returns a nondeterministic integer, that can be controlled during analysis or testing. The value is used to generate an integer in the range [0..maxValue). protected int RandomInteger(int maxValue) parameter description maxValue The max value.","title":"Actor.RandomInteger method"},{"location":"ref/Microsoft.Coyote.Actors/Actor/RandomInteger/#return-value","text":"The controlled nondeterministic integer.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Actors/Actor/RandomInteger/#see-also","text":"class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/ReceiveEventAsync/","text":"Actor.ReceiveEventAsync method (1 of 3) Waits to receive an Event of the specified types that satisfy the specified predicates. protected internal Task<Event> ReceiveEventAsync(params Tuple<Type, Func<Event, bool>>[] events) parameter description events Event types and predicates. Return Value The received event. See Also class Event class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote Actor.ReceiveEventAsync method (2 of 3) Waits to receive an Event of the specified types. protected internal Task<Event> ReceiveEventAsync(params Type[] eventTypes) parameter description eventTypes The event types to wait for. Return Value The received event. See Also class Event class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote Actor.ReceiveEventAsync method (3 of 3) Waits to receive an Event of the specified type that satisfies an optional predicate. protected internal Task<Event> ReceiveEventAsync(Type eventType, Func<Event, bool> predicate = null) parameter description eventType The event type. predicate The optional predicate. Return Value The received event. See Also class Event class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"ReceiveEventAsync"},{"location":"ref/Microsoft.Coyote.Actors/Actor/ReceiveEventAsync/#actorreceiveeventasync-method-1-of-3","text":"Waits to receive an Event of the specified types that satisfy the specified predicates. protected internal Task<Event> ReceiveEventAsync(params Tuple<Type, Func<Event, bool>>[] events) parameter description events Event types and predicates.","title":"Actor.ReceiveEventAsync method (1 of 3)"},{"location":"ref/Microsoft.Coyote.Actors/Actor/ReceiveEventAsync/#return-value","text":"The received event.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Actors/Actor/ReceiveEventAsync/#see-also","text":"class Event class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/ReceiveEventAsync/#actorreceiveeventasync-method-2-of-3","text":"Waits to receive an Event of the specified types. protected internal Task<Event> ReceiveEventAsync(params Type[] eventTypes) parameter description eventTypes The event types to wait for.","title":"Actor.ReceiveEventAsync method (2 of 3)"},{"location":"ref/Microsoft.Coyote.Actors/Actor/ReceiveEventAsync/#return-value_1","text":"The received event.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Actors/Actor/ReceiveEventAsync/#see-also_1","text":"class Event class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/ReceiveEventAsync/#actorreceiveeventasync-method-3-of-3","text":"Waits to receive an Event of the specified type that satisfies an optional predicate. protected internal Task<Event> ReceiveEventAsync(Type eventType, Func<Event, bool> predicate = null) parameter description eventType The event type. predicate The optional predicate.","title":"Actor.ReceiveEventAsync method (3 of 3)"},{"location":"ref/Microsoft.Coyote.Actors/Actor/ReceiveEventAsync/#return-value_2","text":"The received event.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Actors/Actor/ReceiveEventAsync/#see-also_2","text":"class Event class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/SendEvent/","text":"Actor.SendEvent method Sends an asynchronous Event to a target. protected void SendEvent(ActorId id, Event e, EventGroup eventGroup = null, SendOptions options = null) parameter description id The id of the target. e The event to send. eventGroup An optional event group associated with this Actor. options Optional configuration of a send operation. See Also class ActorId class Event class EventGroup class SendOptions class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"SendEvent"},{"location":"ref/Microsoft.Coyote.Actors/Actor/SendEvent/#actorsendevent-method","text":"Sends an asynchronous Event to a target. protected void SendEvent(ActorId id, Event e, EventGroup eventGroup = null, SendOptions options = null) parameter description id The id of the target. e The event to send. eventGroup An optional event group associated with this Actor. options Optional configuration of a send operation.","title":"Actor.SendEvent method"},{"location":"ref/Microsoft.Coyote.Actors/Actor/SendEvent/#see-also","text":"class ActorId class Event class EventGroup class SendOptions class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/StartPeriodicTimer/","text":"Actor.StartPeriodicTimer method Starts a periodic timer that sends a TimerElapsedEvent to this actor after the specified due time, and then repeats after each specified period. The timer accepts an optional payload to be used during timeout. The timer can be stopped by invoking the StopTimer method. protected TimerInfo StartPeriodicTimer(TimeSpan startDelay, TimeSpan period, TimerElapsedEvent customEvent = null) parameter description startDelay The amount of time to wait before sending the first timeout event. period The time interval between timeout events. customEvent Optional custom event to raise instead of the default TimerElapsedEvent. Return Value Handle that contains information about the timer. Remarks See Using timers in actors for more information. See Also class TimerInfo class TimerElapsedEvent class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"StartPeriodicTimer"},{"location":"ref/Microsoft.Coyote.Actors/Actor/StartPeriodicTimer/#actorstartperiodictimer-method","text":"Starts a periodic timer that sends a TimerElapsedEvent to this actor after the specified due time, and then repeats after each specified period. The timer accepts an optional payload to be used during timeout. The timer can be stopped by invoking the StopTimer method. protected TimerInfo StartPeriodicTimer(TimeSpan startDelay, TimeSpan period, TimerElapsedEvent customEvent = null) parameter description startDelay The amount of time to wait before sending the first timeout event. period The time interval between timeout events. customEvent Optional custom event to raise instead of the default TimerElapsedEvent.","title":"Actor.StartPeriodicTimer method"},{"location":"ref/Microsoft.Coyote.Actors/Actor/StartPeriodicTimer/#return-value","text":"Handle that contains information about the timer.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Actors/Actor/StartPeriodicTimer/#remarks","text":"See Using timers in actors for more information.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Actors/Actor/StartPeriodicTimer/#see-also","text":"class TimerInfo class TimerElapsedEvent class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/StartTimer/","text":"Actor.StartTimer method Starts a timer that sends a TimerElapsedEvent to this actor after the specified due time. The timer accepts an optional payload to be used during timeout. The timer is automatically disposed after it timeouts. To manually stop and dispose the timer, invoke the StopTimer method. protected TimerInfo StartTimer(TimeSpan startDelay, TimerElapsedEvent customEvent = null) parameter description startDelay The amount of time to wait before sending the timeout event. customEvent Optional custom event to raise instead of the default TimerElapsedEvent. Return Value Handle that contains information about the timer. Remarks See Using timers in actors for more information. See Also class TimerInfo class TimerElapsedEvent class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"StartTimer"},{"location":"ref/Microsoft.Coyote.Actors/Actor/StartTimer/#actorstarttimer-method","text":"Starts a timer that sends a TimerElapsedEvent to this actor after the specified due time. The timer accepts an optional payload to be used during timeout. The timer is automatically disposed after it timeouts. To manually stop and dispose the timer, invoke the StopTimer method. protected TimerInfo StartTimer(TimeSpan startDelay, TimerElapsedEvent customEvent = null) parameter description startDelay The amount of time to wait before sending the timeout event. customEvent Optional custom event to raise instead of the default TimerElapsedEvent.","title":"Actor.StartTimer method"},{"location":"ref/Microsoft.Coyote.Actors/Actor/StartTimer/#return-value","text":"Handle that contains information about the timer.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Actors/Actor/StartTimer/#remarks","text":"See Using timers in actors for more information.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Actors/Actor/StartTimer/#see-also","text":"class TimerInfo class TimerElapsedEvent class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/StopTimer/","text":"Actor.StopTimer method Stops and disposes the specified timer. protected void StopTimer(TimerInfo info) parameter description info Handle that contains information about the timer. Remarks See Using timers in actors for more information. See Also class TimerInfo class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"StopTimer"},{"location":"ref/Microsoft.Coyote.Actors/Actor/StopTimer/#actorstoptimer-method","text":"Stops and disposes the specified timer. protected void StopTimer(TimerInfo info) parameter description info Handle that contains information about the timer.","title":"Actor.StopTimer method"},{"location":"ref/Microsoft.Coyote.Actors/Actor/StopTimer/#remarks","text":"See Using timers in actors for more information.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Actors/Actor/StopTimer/#see-also","text":"class TimerInfo class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor/ToString/","text":"Actor.ToString method Returns a string that represents the current actor. public override string ToString() See Also class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"ToString"},{"location":"ref/Microsoft.Coyote.Actors/Actor/ToString/#actortostring-method","text":"Returns a string that represents the current actor. public override string ToString()","title":"Actor.ToString method"},{"location":"ref/Microsoft.Coyote.Actors/Actor/ToString/#see-also","text":"class Actor namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/Actor.OnEventDoActionAttribute/OnEventDoActionAttribute/","text":"Actor.OnEventDoActionAttribute constructor Initializes a new instance of the OnEventDoActionAttribute class. public OnEventDoActionAttribute(Type eventType, string actionName) parameter description eventType The type of the dequeued event. actionName The name of the action to invoke. See Also class OnEventDoActionAttribute namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnEventDoActionAttribute"},{"location":"ref/Microsoft.Coyote.Actors/Actor.OnEventDoActionAttribute/OnEventDoActionAttribute/#actoroneventdoactionattribute-constructor","text":"Initializes a new instance of the OnEventDoActionAttribute class. public OnEventDoActionAttribute(Type eventType, string actionName) parameter description eventType The type of the dequeued event. actionName The name of the action to invoke.","title":"Actor.OnEventDoActionAttribute constructor"},{"location":"ref/Microsoft.Coyote.Actors/Actor.OnEventDoActionAttribute/OnEventDoActionAttribute/#see-also","text":"class OnEventDoActionAttribute namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorId/CompareTo/","text":"ActorId.CompareTo method Compares the specified ActorId with the current ActorId for ordering or sorting purposes. public int CompareTo(ActorId other) See Also class ActorId namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"CompareTo"},{"location":"ref/Microsoft.Coyote.Actors/ActorId/CompareTo/#actoridcompareto-method","text":"Compares the specified ActorId with the current ActorId for ordering or sorting purposes. public int CompareTo(ActorId other)","title":"ActorId.CompareTo method"},{"location":"ref/Microsoft.Coyote.Actors/ActorId/CompareTo/#see-also","text":"class ActorId namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorId/Equals/","text":"ActorId.Equals method (1 of 2) Indicates whether the specified ActorId is equal to the current ActorId . public bool Equals(ActorId other) See Also class ActorId namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote ActorId.Equals method (2 of 2) Determines whether the specified object is equal to the current object. public override bool Equals(object obj) See Also class ActorId namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Equals"},{"location":"ref/Microsoft.Coyote.Actors/ActorId/Equals/#actoridequals-method-1-of-2","text":"Indicates whether the specified ActorId is equal to the current ActorId . public bool Equals(ActorId other)","title":"ActorId.Equals method (1 of 2)"},{"location":"ref/Microsoft.Coyote.Actors/ActorId/Equals/#see-also","text":"class ActorId namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorId/Equals/#actoridequals-method-2-of-2","text":"Determines whether the specified object is equal to the current object. public override bool Equals(object obj)","title":"ActorId.Equals method (2 of 2)"},{"location":"ref/Microsoft.Coyote.Actors/ActorId/Equals/#see-also_1","text":"class ActorId namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorId/GetHashCode/","text":"ActorId.GetHashCode method Returns the hash code for this instance. public override int GetHashCode() See Also class ActorId namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"GetHashCode"},{"location":"ref/Microsoft.Coyote.Actors/ActorId/GetHashCode/#actoridgethashcode-method","text":"Returns the hash code for this instance. public override int GetHashCode()","title":"ActorId.GetHashCode method"},{"location":"ref/Microsoft.Coyote.Actors/ActorId/GetHashCode/#see-also","text":"class ActorId namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorId/IsNameUsedForHashing/","text":"ActorId.IsNameUsedForHashing property True if NameValue is used as the unique id, else false. public bool IsNameUsedForHashing { get; } See Also class ActorId namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"IsNameUsedForHashing"},{"location":"ref/Microsoft.Coyote.Actors/ActorId/IsNameUsedForHashing/#actoridisnameusedforhashing-property","text":"True if NameValue is used as the unique id, else false. public bool IsNameUsedForHashing { get; }","title":"ActorId.IsNameUsedForHashing property"},{"location":"ref/Microsoft.Coyote.Actors/ActorId/IsNameUsedForHashing/#see-also","text":"class ActorId namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorId/Name/","text":"ActorId.Name field Name used for logging. public readonly string Name; See Also class ActorId namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Name"},{"location":"ref/Microsoft.Coyote.Actors/ActorId/Name/#actoridname-field","text":"Name used for logging. public readonly string Name;","title":"ActorId.Name field"},{"location":"ref/Microsoft.Coyote.Actors/ActorId/Name/#see-also","text":"class ActorId namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorId/NameValue/","text":"ActorId.NameValue field Unique id, when non-empty. public readonly string NameValue; See Also class ActorId namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"NameValue"},{"location":"ref/Microsoft.Coyote.Actors/ActorId/NameValue/#actoridnamevalue-field","text":"Unique id, when non-empty. public readonly string NameValue;","title":"ActorId.NameValue field"},{"location":"ref/Microsoft.Coyote.Actors/ActorId/NameValue/#see-also","text":"class ActorId namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorId/Runtime/","text":"ActorId.Runtime property The runtime that executes the actor with this id. public IActorRuntime Runtime { get; } See Also interface IActorRuntime class ActorId namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Runtime"},{"location":"ref/Microsoft.Coyote.Actors/ActorId/Runtime/#actoridruntime-property","text":"The runtime that executes the actor with this id. public IActorRuntime Runtime { get; }","title":"ActorId.Runtime property"},{"location":"ref/Microsoft.Coyote.Actors/ActorId/Runtime/#see-also","text":"interface IActorRuntime class ActorId namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorId/ToString/","text":"ActorId.ToString method Returns a string that represents the current actor id. public override string ToString() See Also class ActorId namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"ToString"},{"location":"ref/Microsoft.Coyote.Actors/ActorId/ToString/#actoridtostring-method","text":"Returns a string that represents the current actor id. public override string ToString()","title":"ActorId.ToString method"},{"location":"ref/Microsoft.Coyote.Actors/ActorId/ToString/#see-also","text":"class ActorId namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorId/Type/","text":"ActorId.Type field The type of the actor associated with this id. public readonly string Type; See Also class ActorId namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Type"},{"location":"ref/Microsoft.Coyote.Actors/ActorId/Type/#actoridtype-field","text":"The type of the actor associated with this id. public readonly string Type;","title":"ActorId.Type field"},{"location":"ref/Microsoft.Coyote.Actors/ActorId/Type/#see-also","text":"class ActorId namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorId/Value/","text":"ActorId.Value field Unique id, when NameValue is empty. public readonly ulong Value; See Also class ActorId namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Value"},{"location":"ref/Microsoft.Coyote.Actors/ActorId/Value/#actoridvalue-field","text":"Unique id, when NameValue is empty. public readonly ulong Value;","title":"ActorId.Value field"},{"location":"ref/Microsoft.Coyote.Actors/ActorId/Value/#see-also","text":"class ActorId namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/ActorRuntimeLogTextFormatter/","text":"ActorRuntimeLogTextFormatter constructor Initializes a new instance of the ActorRuntimeLogTextFormatter class. public ActorRuntimeLogTextFormatter() See Also class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"ActorRuntimeLogTextFormatter"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/ActorRuntimeLogTextFormatter/#actorruntimelogtextformatter-constructor","text":"Initializes a new instance of the ActorRuntimeLogTextFormatter class. public ActorRuntimeLogTextFormatter()","title":"ActorRuntimeLogTextFormatter constructor"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/ActorRuntimeLogTextFormatter/#see-also","text":"class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/Logger/","text":"ActorRuntimeLogTextFormatter.Logger property Get or set the ILogger interface to the logger. public ILogger Logger { get; set; } Remarks If you want Coyote to log to an existing TextWriter, then use the TextWriterLogger object but that will have a minor performance overhead, so it is better to use ILogger directly. See Also interface ILogger class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Logger"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/Logger/#actorruntimelogtextformatterlogger-property","text":"Get or set the ILogger interface to the logger. public ILogger Logger { get; set; }","title":"ActorRuntimeLogTextFormatter.Logger property"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/Logger/#remarks","text":"If you want Coyote to log to an existing TextWriter, then use the TextWriterLogger object but that will have a minor performance overhead, so it is better to use ILogger directly.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/Logger/#see-also","text":"interface ILogger class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnAssertionFailure/","text":"ActorRuntimeLogTextFormatter.OnAssertionFailure method Invoked when the specified assertion failure has occurred. public virtual void OnAssertionFailure(string error) parameter description error The text of the error. See Also class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnAssertionFailure"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnAssertionFailure/#actorruntimelogtextformatteronassertionfailure-method","text":"Invoked when the specified assertion failure has occurred. public virtual void OnAssertionFailure(string error) parameter description error The text of the error.","title":"ActorRuntimeLogTextFormatter.OnAssertionFailure method"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnAssertionFailure/#see-also","text":"class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnCompleted/","text":"ActorRuntimeLogTextFormatter.OnCompleted method Invoked when a log is complete (and is about to be closed). public virtual void OnCompleted() See Also class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnCompleted"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnCompleted/#actorruntimelogtextformatteroncompleted-method","text":"Invoked when a log is complete (and is about to be closed). public virtual void OnCompleted()","title":"ActorRuntimeLogTextFormatter.OnCompleted method"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnCompleted/#see-also","text":"class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnCreateActor/","text":"ActorRuntimeLogTextFormatter.OnCreateActor method Invoked when the specified actor has been created. public virtual void OnCreateActor(ActorId id, string creatorName, string creatorType) parameter description id The id of the actor that has been created. creatorName The name of the creator, or null. creatorType The type of the creator, or null. See Also class ActorId class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnCreateActor"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnCreateActor/#actorruntimelogtextformatteroncreateactor-method","text":"Invoked when the specified actor has been created. public virtual void OnCreateActor(ActorId id, string creatorName, string creatorType) parameter description id The id of the actor that has been created. creatorName The name of the creator, or null. creatorType The type of the creator, or null.","title":"ActorRuntimeLogTextFormatter.OnCreateActor method"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnCreateActor/#see-also","text":"class ActorId class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnCreateMonitor/","text":"ActorRuntimeLogTextFormatter.OnCreateMonitor method Invoked when the specified monitor has been created. public virtual void OnCreateMonitor(string monitorType) parameter description monitorType The name of the type of the monitor that has been created. See Also class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnCreateMonitor"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnCreateMonitor/#actorruntimelogtextformatteroncreatemonitor-method","text":"Invoked when the specified monitor has been created. public virtual void OnCreateMonitor(string monitorType) parameter description monitorType The name of the type of the monitor that has been created.","title":"ActorRuntimeLogTextFormatter.OnCreateMonitor method"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnCreateMonitor/#see-also","text":"class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnCreateStateMachine/","text":"ActorRuntimeLogTextFormatter.OnCreateStateMachine method Invoked when the specified state machine has been created. public void OnCreateStateMachine(ActorId id, string creatorName, string creatorType) parameter description id The id of the state machine that has been created. creatorName The name of the creator, or null. creatorType The type of the creator, or null. See Also class ActorId class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnCreateStateMachine"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnCreateStateMachine/#actorruntimelogtextformatteroncreatestatemachine-method","text":"Invoked when the specified state machine has been created. public void OnCreateStateMachine(ActorId id, string creatorName, string creatorType) parameter description id The id of the state machine that has been created. creatorName The name of the creator, or null. creatorType The type of the creator, or null.","title":"ActorRuntimeLogTextFormatter.OnCreateStateMachine method"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnCreateStateMachine/#see-also","text":"class ActorId class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnCreateTimer/","text":"ActorRuntimeLogTextFormatter.OnCreateTimer method Invoked when the specified actor timer has been created. public virtual void OnCreateTimer(TimerInfo info) parameter description info Handle that contains information about the timer. See Also class TimerInfo class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnCreateTimer"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnCreateTimer/#actorruntimelogtextformatteroncreatetimer-method","text":"Invoked when the specified actor timer has been created. public virtual void OnCreateTimer(TimerInfo info) parameter description info Handle that contains information about the timer.","title":"ActorRuntimeLogTextFormatter.OnCreateTimer method"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnCreateTimer/#see-also","text":"class TimerInfo class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnDefaultEventHandler/","text":"ActorRuntimeLogTextFormatter.OnDefaultEventHandler method Invoked when the specified actor is idle (there is nothing to dequeue) and the default event handler is about to be executed. public virtual void OnDefaultEventHandler(ActorId id, string stateName) parameter description id The id of the actor that the state will execute in. stateName The state name, if the actor is a state machine and a state exists, else null. See Also class ActorId class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnDefaultEventHandler"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnDefaultEventHandler/#actorruntimelogtextformatterondefaulteventhandler-method","text":"Invoked when the specified actor is idle (there is nothing to dequeue) and the default event handler is about to be executed. public virtual void OnDefaultEventHandler(ActorId id, string stateName) parameter description id The id of the actor that the state will execute in. stateName The state name, if the actor is a state machine and a state exists, else null.","title":"ActorRuntimeLogTextFormatter.OnDefaultEventHandler method"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnDefaultEventHandler/#see-also","text":"class ActorId class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnDequeueEvent/","text":"ActorRuntimeLogTextFormatter.OnDequeueEvent method Invoked when the specified event is dequeued by an actor. public virtual void OnDequeueEvent(ActorId id, string stateName, Event e) parameter description id The id of the actor that the event is being dequeued by. stateName The state name, if the actor is a state machine and a state exists, else null. e The event being dequeued. See Also class ActorId class Event class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnDequeueEvent"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnDequeueEvent/#actorruntimelogtextformatterondequeueevent-method","text":"Invoked when the specified event is dequeued by an actor. public virtual void OnDequeueEvent(ActorId id, string stateName, Event e) parameter description id The id of the actor that the event is being dequeued by. stateName The state name, if the actor is a state machine and a state exists, else null. e The event being dequeued.","title":"ActorRuntimeLogTextFormatter.OnDequeueEvent method"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnDequeueEvent/#see-also","text":"class ActorId class Event class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnEnqueueEvent/","text":"ActorRuntimeLogTextFormatter.OnEnqueueEvent method Invoked when the specified event is about to be enqueued to an actor. public virtual void OnEnqueueEvent(ActorId id, Event e) parameter description id The id of the actor that the event is being enqueued to. e The event being enqueued. See Also class ActorId class Event class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnEnqueueEvent"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnEnqueueEvent/#actorruntimelogtextformatteronenqueueevent-method","text":"Invoked when the specified event is about to be enqueued to an actor. public virtual void OnEnqueueEvent(ActorId id, Event e) parameter description id The id of the actor that the event is being enqueued to. e The event being enqueued.","title":"ActorRuntimeLogTextFormatter.OnEnqueueEvent method"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnEnqueueEvent/#see-also","text":"class ActorId class Event class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnEventHandlerTerminated/","text":"ActorRuntimeLogTextFormatter.OnEventHandlerTerminated method Invoked when the event handler of the specified actor terminated. public void OnEventHandlerTerminated(ActorId id, string stateName, DequeueStatus dequeueStatus) parameter description id The id of the actor with the handler that terminated. stateName The state name, if the actor is a state machine and a state exists, else null. dequeueStatus The status returned as the result of the last dequeue operation. See Also class ActorId enum DequeueStatus class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnEventHandlerTerminated"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnEventHandlerTerminated/#actorruntimelogtextformatteroneventhandlerterminated-method","text":"Invoked when the event handler of the specified actor terminated. public void OnEventHandlerTerminated(ActorId id, string stateName, DequeueStatus dequeueStatus) parameter description id The id of the actor with the handler that terminated. stateName The state name, if the actor is a state machine and a state exists, else null. dequeueStatus The status returned as the result of the last dequeue operation.","title":"ActorRuntimeLogTextFormatter.OnEventHandlerTerminated method"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnEventHandlerTerminated/#see-also","text":"class ActorId enum DequeueStatus class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnExceptionHandled/","text":"ActorRuntimeLogTextFormatter.OnExceptionHandled method Invoked when the specified OnException method is used to handle a thrown exception. public virtual void OnExceptionHandled(ActorId id, string stateName, string actionName, Exception ex) parameter description id The id of the actor that threw the exception. stateName The state name, if the actor is a state machine and a state exists, else null. actionName The name of the action being executed. ex The exception. See Also class ActorId class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnExceptionHandled"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnExceptionHandled/#actorruntimelogtextformatteronexceptionhandled-method","text":"Invoked when the specified OnException method is used to handle a thrown exception. public virtual void OnExceptionHandled(ActorId id, string stateName, string actionName, Exception ex) parameter description id The id of the actor that threw the exception. stateName The state name, if the actor is a state machine and a state exists, else null. actionName The name of the action being executed. ex The exception.","title":"ActorRuntimeLogTextFormatter.OnExceptionHandled method"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnExceptionHandled/#see-also","text":"class ActorId class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnExceptionThrown/","text":"ActorRuntimeLogTextFormatter.OnExceptionThrown method Invoked when the specified actor throws an exception. public virtual void OnExceptionThrown(ActorId id, string stateName, string actionName, Exception ex) parameter description id The id of the actor that threw the exception. stateName The state name, if the actor is a state machine and a state exists, else null. actionName The name of the action being executed. ex The exception. See Also class ActorId class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnExceptionThrown"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnExceptionThrown/#actorruntimelogtextformatteronexceptionthrown-method","text":"Invoked when the specified actor throws an exception. public virtual void OnExceptionThrown(ActorId id, string stateName, string actionName, Exception ex) parameter description id The id of the actor that threw the exception. stateName The state name, if the actor is a state machine and a state exists, else null. actionName The name of the action being executed. ex The exception.","title":"ActorRuntimeLogTextFormatter.OnExceptionThrown method"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnExceptionThrown/#see-also","text":"class ActorId class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnExecuteAction/","text":"ActorRuntimeLogTextFormatter.OnExecuteAction method Invoked when the specified actor executes an action. public virtual void OnExecuteAction(ActorId id, string handlingStateName, string currentStateName, string actionName) parameter description id The id of the actor executing the action. handlingStateName The state that declared this action (can be different from currentStateName in the case of pushed states. currentStateName The state name, if the actor is a state machine and a state exists, else null. actionName The name of the action being executed. See Also class ActorId class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnExecuteAction"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnExecuteAction/#actorruntimelogtextformatteronexecuteaction-method","text":"Invoked when the specified actor executes an action. public virtual void OnExecuteAction(ActorId id, string handlingStateName, string currentStateName, string actionName) parameter description id The id of the actor executing the action. handlingStateName The state that declared this action (can be different from currentStateName in the case of pushed states. currentStateName The state name, if the actor is a state machine and a state exists, else null. actionName The name of the action being executed.","title":"ActorRuntimeLogTextFormatter.OnExecuteAction method"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnExecuteAction/#see-also","text":"class ActorId class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnGotoState/","text":"ActorRuntimeLogTextFormatter.OnGotoState method Invoked when the specified state machine performs a goto transition to the specified state. public virtual void OnGotoState(ActorId id, string currentStateName, string newStateName) parameter description id The id of the actor. currentStateName The name of the current state. newStateName The target state of the transition. See Also class ActorId class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnGotoState"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnGotoState/#actorruntimelogtextformatterongotostate-method","text":"Invoked when the specified state machine performs a goto transition to the specified state. public virtual void OnGotoState(ActorId id, string currentStateName, string newStateName) parameter description id The id of the actor. currentStateName The name of the current state. newStateName The target state of the transition.","title":"ActorRuntimeLogTextFormatter.OnGotoState method"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnGotoState/#see-also","text":"class ActorId class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnHalt/","text":"ActorRuntimeLogTextFormatter.OnHalt method Invoked when the specified actor has been halted. public virtual void OnHalt(ActorId id, int inboxSize) parameter description id The id of the actor that has been halted. inboxSize Approximate size of the inbox. See Also class ActorId class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnHalt"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnHalt/#actorruntimelogtextformatteronhalt-method","text":"Invoked when the specified actor has been halted. public virtual void OnHalt(ActorId id, int inboxSize) parameter description id The id of the actor that has been halted. inboxSize Approximate size of the inbox.","title":"ActorRuntimeLogTextFormatter.OnHalt method"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnHalt/#see-also","text":"class ActorId class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnHandleRaisedEvent/","text":"ActorRuntimeLogTextFormatter.OnHandleRaisedEvent method Invoked when the specified actor handled a raised event. public virtual void OnHandleRaisedEvent(ActorId id, string stateName, Event e) parameter description id The id of the actor handling the event. stateName The state name, if the actor is a state machine and a state exists, else null. e The event being handled. See Also class ActorId class Event class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnHandleRaisedEvent"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnHandleRaisedEvent/#actorruntimelogtextformatteronhandleraisedevent-method","text":"Invoked when the specified actor handled a raised event. public virtual void OnHandleRaisedEvent(ActorId id, string stateName, Event e) parameter description id The id of the actor handling the event. stateName The state name, if the actor is a state machine and a state exists, else null. e The event being handled.","title":"ActorRuntimeLogTextFormatter.OnHandleRaisedEvent method"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnHandleRaisedEvent/#see-also","text":"class ActorId class Event class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnMonitorError/","text":"ActorRuntimeLogTextFormatter.OnMonitorError method Invoked when the specified monitor finds an error. public virtual void OnMonitorError(string monitorType, string stateName, bool? isInHotState) parameter description monitorType The name of the type of the monitor. stateName The name of the current state. isInHotState If true, the monitor is in a hot state; if false, the monitor is in a cold state; else no liveness state is available. See Also class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnMonitorError"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnMonitorError/#actorruntimelogtextformatteronmonitorerror-method","text":"Invoked when the specified monitor finds an error. public virtual void OnMonitorError(string monitorType, string stateName, bool? isInHotState) parameter description monitorType The name of the type of the monitor. stateName The name of the current state. isInHotState If true, the monitor is in a hot state; if false, the monitor is in a cold state; else no liveness state is available.","title":"ActorRuntimeLogTextFormatter.OnMonitorError method"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnMonitorError/#see-also","text":"class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnMonitorExecuteAction/","text":"ActorRuntimeLogTextFormatter.OnMonitorExecuteAction method Invoked when the specified monitor executes an action. public virtual void OnMonitorExecuteAction(string monitorType, string stateName, string actionName) parameter description monitorType Name of type of the monitor that is executing the action. stateName The name of the state in which the action is being executed. actionName The name of the action being executed. See Also class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnMonitorExecuteAction"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnMonitorExecuteAction/#actorruntimelogtextformatteronmonitorexecuteaction-method","text":"Invoked when the specified monitor executes an action. public virtual void OnMonitorExecuteAction(string monitorType, string stateName, string actionName) parameter description monitorType Name of type of the monitor that is executing the action. stateName The name of the state in which the action is being executed. actionName The name of the action being executed.","title":"ActorRuntimeLogTextFormatter.OnMonitorExecuteAction method"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnMonitorExecuteAction/#see-also","text":"class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnMonitorProcessEvent/","text":"ActorRuntimeLogTextFormatter.OnMonitorProcessEvent method Invoked when the specified monitor is about to process an event. public virtual void OnMonitorProcessEvent(string monitorType, string stateName, string senderName, string senderType, string senderStateName, Event e) parameter description monitorType Name of type of the monitor that will process the event. stateName The name of the state in which the event is being raised. senderName The name of the sender, if any. senderType The type of the sender, if any. senderStateName The name of the state the sender is in. e The event being processed. See Also class Event class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnMonitorProcessEvent"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnMonitorProcessEvent/#actorruntimelogtextformatteronmonitorprocessevent-method","text":"Invoked when the specified monitor is about to process an event. public virtual void OnMonitorProcessEvent(string monitorType, string stateName, string senderName, string senderType, string senderStateName, Event e) parameter description monitorType Name of type of the monitor that will process the event. stateName The name of the state in which the event is being raised. senderName The name of the sender, if any. senderType The type of the sender, if any. senderStateName The name of the state the sender is in. e The event being processed.","title":"ActorRuntimeLogTextFormatter.OnMonitorProcessEvent method"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnMonitorProcessEvent/#see-also","text":"class Event class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnMonitorRaiseEvent/","text":"ActorRuntimeLogTextFormatter.OnMonitorRaiseEvent method Invoked when the specified monitor raised an event. public virtual void OnMonitorRaiseEvent(string monitorType, string stateName, Event e) parameter description monitorType Name of type of the monitor raising the event. stateName The name of the state in which the event is being raised. e The event being raised. See Also class Event class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnMonitorRaiseEvent"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnMonitorRaiseEvent/#actorruntimelogtextformatteronmonitorraiseevent-method","text":"Invoked when the specified monitor raised an event. public virtual void OnMonitorRaiseEvent(string monitorType, string stateName, Event e) parameter description monitorType Name of type of the monitor raising the event. stateName The name of the state in which the event is being raised. e The event being raised.","title":"ActorRuntimeLogTextFormatter.OnMonitorRaiseEvent method"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnMonitorRaiseEvent/#see-also","text":"class Event class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnMonitorStateTransition/","text":"ActorRuntimeLogTextFormatter.OnMonitorStateTransition method Invoked when the specified monitor enters or exits a state. public virtual void OnMonitorStateTransition(string monitorType, string stateName, bool isEntry, bool? isInHotState) parameter description monitorType The name of the type of the monitor entering or exiting the state. stateName The name of the state being entered or exited; if isInHotState is not null, then the temperature is appended to the statename in brackets, e.g. \u201cstateName[hot]\u201d. isEntry If true, this is called for a state entry; otherwise, exit. isInHotState If true, the monitor is in a hot state; if false, the monitor is in a cold state; else no liveness state is available. See Also class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnMonitorStateTransition"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnMonitorStateTransition/#actorruntimelogtextformatteronmonitorstatetransition-method","text":"Invoked when the specified monitor enters or exits a state. public virtual void OnMonitorStateTransition(string monitorType, string stateName, bool isEntry, bool? isInHotState) parameter description monitorType The name of the type of the monitor entering or exiting the state. stateName The name of the state being entered or exited; if isInHotState is not null, then the temperature is appended to the statename in brackets, e.g. \u201cstateName[hot]\u201d. isEntry If true, this is called for a state entry; otherwise, exit. isInHotState If true, the monitor is in a hot state; if false, the monitor is in a cold state; else no liveness state is available.","title":"ActorRuntimeLogTextFormatter.OnMonitorStateTransition method"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnMonitorStateTransition/#see-also","text":"class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnPopState/","text":"ActorRuntimeLogTextFormatter.OnPopState method Invoked when the specified state machine has popped its current state. public virtual void OnPopState(ActorId id, string currentStateName, string restoredStateName) parameter description id The id of the actor that the pop executed in. currentStateName The name of the current state. restoredStateName The name of the state being re-entered, if any. See Also class ActorId class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnPopState"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnPopState/#actorruntimelogtextformatteronpopstate-method","text":"Invoked when the specified state machine has popped its current state. public virtual void OnPopState(ActorId id, string currentStateName, string restoredStateName) parameter description id The id of the actor that the pop executed in. currentStateName The name of the current state. restoredStateName The name of the state being re-entered, if any.","title":"ActorRuntimeLogTextFormatter.OnPopState method"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnPopState/#see-also","text":"class ActorId class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnPopStateUnhandledEvent/","text":"ActorRuntimeLogTextFormatter.OnPopStateUnhandledEvent method Invoked when the specified event cannot be handled in the current state, its exit handler is executed and then the state is popped and any previous \u201ccurrent state\u201d is reentered. This handler is called when that pop has been done. public virtual void OnPopStateUnhandledEvent(ActorId id, string stateName, Event e) parameter description id The id of the actor that the pop executed in. stateName The state name, if the actor is a state machine and a state exists, else null. e The event that cannot be handled. See Also class ActorId class Event class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnPopStateUnhandledEvent"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnPopStateUnhandledEvent/#actorruntimelogtextformatteronpopstateunhandledevent-method","text":"Invoked when the specified event cannot be handled in the current state, its exit handler is executed and then the state is popped and any previous \u201ccurrent state\u201d is reentered. This handler is called when that pop has been done. public virtual void OnPopStateUnhandledEvent(ActorId id, string stateName, Event e) parameter description id The id of the actor that the pop executed in. stateName The state name, if the actor is a state machine and a state exists, else null. e The event that cannot be handled.","title":"ActorRuntimeLogTextFormatter.OnPopStateUnhandledEvent method"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnPopStateUnhandledEvent/#see-also","text":"class ActorId class Event class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnPushState/","text":"ActorRuntimeLogTextFormatter.OnPushState method Invoked when the specified state machine is being pushed to a state. public virtual void OnPushState(ActorId id, string currentStateName, string newStateName) parameter description id The id of the actor being pushed to the state. currentStateName The name of the current state. newStateName The target state of the transition. See Also class ActorId class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnPushState"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnPushState/#actorruntimelogtextformatteronpushstate-method","text":"Invoked when the specified state machine is being pushed to a state. public virtual void OnPushState(ActorId id, string currentStateName, string newStateName) parameter description id The id of the actor being pushed to the state. currentStateName The name of the current state. newStateName The target state of the transition.","title":"ActorRuntimeLogTextFormatter.OnPushState method"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnPushState/#see-also","text":"class ActorId class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnRaiseEvent/","text":"ActorRuntimeLogTextFormatter.OnRaiseEvent method Invoked when the specified state machine raises an event. public virtual void OnRaiseEvent(ActorId id, string stateName, Event e) parameter description id The id of the actor raising the event. stateName The name of the current state. e The event being raised. See Also class ActorId class Event class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnRaiseEvent"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnRaiseEvent/#actorruntimelogtextformatteronraiseevent-method","text":"Invoked when the specified state machine raises an event. public virtual void OnRaiseEvent(ActorId id, string stateName, Event e) parameter description id The id of the actor raising the event. stateName The name of the current state. e The event being raised.","title":"ActorRuntimeLogTextFormatter.OnRaiseEvent method"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnRaiseEvent/#see-also","text":"class ActorId class Event class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnRandom/","text":"ActorRuntimeLogTextFormatter.OnRandom method Invoked when the specified controlled nondeterministic result has been obtained. public virtual void OnRandom(object result, string callerName, string callerType) parameter description result The nondeterministic result (may be bool or int). callerName The name of the caller, if any. callerType The type of the caller, if any. See Also class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnRandom"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnRandom/#actorruntimelogtextformatteronrandom-method","text":"Invoked when the specified controlled nondeterministic result has been obtained. public virtual void OnRandom(object result, string callerName, string callerType) parameter description result The nondeterministic result (may be bool or int). callerName The name of the caller, if any. callerType The type of the caller, if any.","title":"ActorRuntimeLogTextFormatter.OnRandom method"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnRandom/#see-also","text":"class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnReceiveEvent/","text":"ActorRuntimeLogTextFormatter.OnReceiveEvent method Invoked when the specified event is received by an actor. public virtual void OnReceiveEvent(ActorId id, string stateName, Event e, bool wasBlocked) parameter description id The id of the actor that received the event. stateName The state name, if the actor is a state machine and a state exists, else null. e The the event being received. wasBlocked The actor was waiting for one or more specific events, and e was one of them. See Also class ActorId class Event class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnReceiveEvent"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnReceiveEvent/#actorruntimelogtextformatteronreceiveevent-method","text":"Invoked when the specified event is received by an actor. public virtual void OnReceiveEvent(ActorId id, string stateName, Event e, bool wasBlocked) parameter description id The id of the actor that received the event. stateName The state name, if the actor is a state machine and a state exists, else null. e The the event being received. wasBlocked The actor was waiting for one or more specific events, and e was one of them.","title":"ActorRuntimeLogTextFormatter.OnReceiveEvent method"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnReceiveEvent/#see-also","text":"class ActorId class Event class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnSendEvent/","text":"ActorRuntimeLogTextFormatter.OnSendEvent method Invoked when the specified event is sent to a target actor. public virtual void OnSendEvent(ActorId targetActorId, string senderName, string senderType, string senderStateName, Event e, Guid eventGroupId, bool isTargetHalted) parameter description targetActorId The id of the target actor. senderName The name of the sender, if any. senderType The type of the sender, if any. senderStateName The state name, if the sender is a state machine, else null. e The event being sent. eventGroupId The id used to identify the send operation. isTargetHalted Is the target actor halted. See Also class ActorId class Event class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnSendEvent"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnSendEvent/#actorruntimelogtextformatteronsendevent-method","text":"Invoked when the specified event is sent to a target actor. public virtual void OnSendEvent(ActorId targetActorId, string senderName, string senderType, string senderStateName, Event e, Guid eventGroupId, bool isTargetHalted) parameter description targetActorId The id of the target actor. senderName The name of the sender, if any. senderType The type of the sender, if any. senderStateName The state name, if the sender is a state machine, else null. e The event being sent. eventGroupId The id used to identify the send operation. isTargetHalted Is the target actor halted.","title":"ActorRuntimeLogTextFormatter.OnSendEvent method"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnSendEvent/#see-also","text":"class ActorId class Event class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnStateTransition/","text":"ActorRuntimeLogTextFormatter.OnStateTransition method Invoked when the specified state machine enters or exits a state. public virtual void OnStateTransition(ActorId id, string stateName, bool isEntry) parameter description id The id of the actor entering or exiting the state. stateName The name of the state being entered or exited. isEntry If true, this is called for a state entry; otherwise, exit. See Also class ActorId class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnStateTransition"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnStateTransition/#actorruntimelogtextformatteronstatetransition-method","text":"Invoked when the specified state machine enters or exits a state. public virtual void OnStateTransition(ActorId id, string stateName, bool isEntry) parameter description id The id of the actor entering or exiting the state. stateName The name of the state being entered or exited. isEntry If true, this is called for a state entry; otherwise, exit.","title":"ActorRuntimeLogTextFormatter.OnStateTransition method"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnStateTransition/#see-also","text":"class ActorId class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnStopTimer/","text":"ActorRuntimeLogTextFormatter.OnStopTimer method Invoked when the specified actor timer has been stopped. public virtual void OnStopTimer(TimerInfo info) parameter description info Handle that contains information about the timer. See Also class TimerInfo class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnStopTimer"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnStopTimer/#actorruntimelogtextformatteronstoptimer-method","text":"Invoked when the specified actor timer has been stopped. public virtual void OnStopTimer(TimerInfo info) parameter description info Handle that contains information about the timer.","title":"ActorRuntimeLogTextFormatter.OnStopTimer method"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnStopTimer/#see-also","text":"class TimerInfo class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnStrategyDescription/","text":"ActorRuntimeLogTextFormatter.OnStrategyDescription method Invoked to describe the specified scheduling strategy. public virtual void OnStrategyDescription(string strategyName, string description) parameter description strategyName The name of the strategy that was used. description More information about the scheduling strategy. See Also class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnStrategyDescription"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnStrategyDescription/#actorruntimelogtextformatteronstrategydescription-method","text":"Invoked to describe the specified scheduling strategy. public virtual void OnStrategyDescription(string strategyName, string description) parameter description strategyName The name of the strategy that was used. description More information about the scheduling strategy.","title":"ActorRuntimeLogTextFormatter.OnStrategyDescription method"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnStrategyDescription/#see-also","text":"class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnWaitEvent/","text":"ActorRuntimeLogTextFormatter.OnWaitEvent method (1 of 2) Invoked when the specified actor waits to receive an event of a specified type. public virtual void OnWaitEvent(ActorId id, string stateName, Type eventType) parameter description id The id of the actor that is entering the wait state. stateName The state name, if the actor is a state machine and a state exists, else null. eventType The type of the event being waited for. See Also class ActorId class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote ActorRuntimeLogTextFormatter.OnWaitEvent method (2 of 2) Invoked when the specified actor waits to receive an event of one of the specified types. public virtual void OnWaitEvent(ActorId id, string stateName, params Type[] eventTypes) parameter description id The id of the actor that is entering the wait state. stateName The state name, if the actor is a state machine and a state exists, else null. eventTypes The types of the events being waited for, if any. See Also class ActorId class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnWaitEvent"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnWaitEvent/#actorruntimelogtextformatteronwaitevent-method-1-of-2","text":"Invoked when the specified actor waits to receive an event of a specified type. public virtual void OnWaitEvent(ActorId id, string stateName, Type eventType) parameter description id The id of the actor that is entering the wait state. stateName The state name, if the actor is a state machine and a state exists, else null. eventType The type of the event being waited for.","title":"ActorRuntimeLogTextFormatter.OnWaitEvent method (1 of 2)"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnWaitEvent/#see-also","text":"class ActorId class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnWaitEvent/#actorruntimelogtextformatteronwaitevent-method-2-of-2","text":"Invoked when the specified actor waits to receive an event of one of the specified types. public virtual void OnWaitEvent(ActorId id, string stateName, params Type[] eventTypes) parameter description id The id of the actor that is entering the wait state. stateName The state name, if the actor is a state machine and a state exists, else null. eventTypes The types of the events being waited for, if any.","title":"ActorRuntimeLogTextFormatter.OnWaitEvent method (2 of 2)"},{"location":"ref/Microsoft.Coyote.Actors/ActorRuntimeLogTextFormatter/OnWaitEvent/#see-also_1","text":"class ActorId class ActorRuntimeLogTextFormatter namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/AwaitableEventGroup/","text":"AwaitableEventGroup<T> constructor Initializes a new instance of the AwaitableEventGroup class. public AwaitableEventGroup(Guid id = default(Guid), string name = null) parameter description id The id for this AwaitableEventGroup (defaults to Guid.Empty). name An optional friendly name for this EventGroup . See Also class AwaitableEventGroup<T> namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"AwaitableEventGroup"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/AwaitableEventGroup/#awaitableeventgroupt-constructor","text":"Initializes a new instance of the AwaitableEventGroup class. public AwaitableEventGroup(Guid id = default(Guid), string name = null) parameter description id The id for this AwaitableEventGroup (defaults to Guid.Empty). name An optional friendly name for this EventGroup .","title":"AwaitableEventGroup&lt;T&gt; constructor"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/AwaitableEventGroup/#see-also","text":"class AwaitableEventGroup<T> namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/GetAwaiter/","text":"AwaitableEventGroup<T>.GetAwaiter method Gets an awaiter for this awaitable. public TaskAwaiter<T> GetAwaiter() See Also class AwaitableEventGroup<T> namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"GetAwaiter"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/GetAwaiter/#awaitableeventgrouptgetawaiter-method","text":"Gets an awaiter for this awaitable. public TaskAwaiter<T> GetAwaiter()","title":"AwaitableEventGroup&lt;T&gt;.GetAwaiter method"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/GetAwaiter/#see-also","text":"class AwaitableEventGroup<T> namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/IsCanceled/","text":"AwaitableEventGroup<T>.IsCanceled property Value that indicates whether the task completed execution due to being canceled. public bool IsCanceled { get; } See Also class AwaitableEventGroup<T> namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"IsCanceled"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/IsCanceled/#awaitableeventgrouptiscanceled-property","text":"Value that indicates whether the task completed execution due to being canceled. public bool IsCanceled { get; }","title":"AwaitableEventGroup&lt;T&gt;.IsCanceled property"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/IsCanceled/#see-also","text":"class AwaitableEventGroup<T> namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/IsCompleted/","text":"AwaitableEventGroup<T>.IsCompleted property Indicates the AwaitableEventGroup has been completed. public bool IsCompleted { get; } See Also class AwaitableEventGroup<T> namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"IsCompleted"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/IsCompleted/#awaitableeventgrouptiscompleted-property","text":"Indicates the AwaitableEventGroup has been completed. public bool IsCompleted { get; }","title":"AwaitableEventGroup&lt;T&gt;.IsCompleted property"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/IsCompleted/#see-also","text":"class AwaitableEventGroup<T> namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/IsFaulted/","text":"AwaitableEventGroup<T>.IsFaulted property Value that indicates whether the task completed due to an unhandled exception. public bool IsFaulted { get; } See Also class AwaitableEventGroup<T> namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"IsFaulted"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/IsFaulted/#awaitableeventgrouptisfaulted-property","text":"Value that indicates whether the task completed due to an unhandled exception. public bool IsFaulted { get; }","title":"AwaitableEventGroup&lt;T&gt;.IsFaulted property"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/IsFaulted/#see-also","text":"class AwaitableEventGroup<T> namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/SetCancelled/","text":"AwaitableEventGroup<T>.SetCancelled method Transitions the underlying task into the Canceled state. public virtual void SetCancelled() See Also class AwaitableEventGroup<T> namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"SetCancelled"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/SetCancelled/#awaitableeventgrouptsetcancelled-method","text":"Transitions the underlying task into the Canceled state. public virtual void SetCancelled()","title":"AwaitableEventGroup&lt;T&gt;.SetCancelled method"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/SetCancelled/#see-also","text":"class AwaitableEventGroup<T> namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/SetException/","text":"AwaitableEventGroup<T>.SetException method Transitions the underlying task into the Faulted state and binds it to the specified exception. public virtual void SetException(Exception exception) parameter description exception The exception to bind to this task. See Also class AwaitableEventGroup<T> namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"SetException"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/SetException/#awaitableeventgrouptsetexception-method","text":"Transitions the underlying task into the Faulted state and binds it to the specified exception. public virtual void SetException(Exception exception) parameter description exception The exception to bind to this task.","title":"AwaitableEventGroup&lt;T&gt;.SetException method"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/SetException/#see-also","text":"class AwaitableEventGroup<T> namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/SetResult/","text":"AwaitableEventGroup<T>.SetResult method Transitions the underlying task into the RanToCompletion state. public virtual void SetResult(T result) parameter description result The completed result object. See Also class AwaitableEventGroup<T> namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"SetResult"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/SetResult/#awaitableeventgrouptsetresult-method","text":"Transitions the underlying task into the RanToCompletion state. public virtual void SetResult(T result) parameter description result The completed result object.","title":"AwaitableEventGroup&lt;T&gt;.SetResult method"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/SetResult/#see-also","text":"class AwaitableEventGroup<T> namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/Task/","text":"AwaitableEventGroup<T>.Task property Gets the task created by this AwaitableEventGroup . public Task<T> Task { get; } See Also class Task<TResult> class AwaitableEventGroup<T> namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Task"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/Task/#awaitableeventgroupttask-property","text":"Gets the task created by this AwaitableEventGroup . public Task<T> Task { get; }","title":"AwaitableEventGroup&lt;T&gt;.Task property"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/Task/#see-also","text":"class Task<TResult> class AwaitableEventGroup<T> namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/TrySetCanceled/","text":"AwaitableEventGroup<T>.TrySetCanceled method Attempts to transition the underlying task into the Canceled state. public virtual bool TrySetCanceled() Return Value True if the AwaitableEventGroup was successful; otherwise, false. See Also class AwaitableEventGroup<T> namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"TrySetCanceled"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/TrySetCanceled/#awaitableeventgroupttrysetcanceled-method","text":"Attempts to transition the underlying task into the Canceled state. public virtual bool TrySetCanceled()","title":"AwaitableEventGroup&lt;T&gt;.TrySetCanceled method"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/TrySetCanceled/#return-value","text":"True if the AwaitableEventGroup was successful; otherwise, false.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/TrySetCanceled/#see-also","text":"class AwaitableEventGroup<T> namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/TrySetException/","text":"AwaitableEventGroup<T>.TrySetException method Attempts to transition the underlying task into the Faulted state and binds it to the specified exception. public virtual bool TrySetException(Exception exception) parameter description exception The exception to bind to this task. Return Value True if the AwaitableEventGroup was successful; otherwise, false. See Also class AwaitableEventGroup<T> namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"TrySetException"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/TrySetException/#awaitableeventgroupttrysetexception-method","text":"Attempts to transition the underlying task into the Faulted state and binds it to the specified exception. public virtual bool TrySetException(Exception exception) parameter description exception The exception to bind to this task.","title":"AwaitableEventGroup&lt;T&gt;.TrySetException method"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/TrySetException/#return-value","text":"True if the AwaitableEventGroup was successful; otherwise, false.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/TrySetException/#see-also","text":"class AwaitableEventGroup<T> namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/TrySetResult/","text":"AwaitableEventGroup<T>.TrySetResult method Attempts to transition the underlying task into the RanToCompletion state. public virtual void TrySetResult(T result) parameter description result The completed result object. See Also class AwaitableEventGroup<T> namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"TrySetResult"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/TrySetResult/#awaitableeventgroupttrysetresult-method","text":"Attempts to transition the underlying task into the RanToCompletion state. public virtual void TrySetResult(T result) parameter description result The completed result object.","title":"AwaitableEventGroup&lt;T&gt;.TrySetResult method"},{"location":"ref/Microsoft.Coyote.Actors/AwaitableEventGroup-1/TrySetResult/#see-also","text":"class AwaitableEventGroup<T> namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/DefaultEvent/Instance/","text":"DefaultEvent.Instance property Gets a DefaultEvent instance. public static DefaultEvent Instance { get; } See Also class DefaultEvent namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Instance"},{"location":"ref/Microsoft.Coyote.Actors/DefaultEvent/Instance/#defaulteventinstance-property","text":"Gets a DefaultEvent instance. public static DefaultEvent Instance { get; }","title":"DefaultEvent.Instance property"},{"location":"ref/Microsoft.Coyote.Actors/DefaultEvent/Instance/#see-also","text":"class DefaultEvent namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/EventGroup/EventGroup/","text":"EventGroup constructor Initializes a new instance of the EventGroup class. public EventGroup(Guid id = default(Guid), string name = null) parameter description id The id for this EventGroup (defaults to Guid.Empty). name An optional friendly name for this EventGroup . See Also class EventGroup namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"EventGroup"},{"location":"ref/Microsoft.Coyote.Actors/EventGroup/EventGroup/#eventgroup-constructor","text":"Initializes a new instance of the EventGroup class. public EventGroup(Guid id = default(Guid), string name = null) parameter description id The id for this EventGroup (defaults to Guid.Empty). name An optional friendly name for this EventGroup .","title":"EventGroup constructor"},{"location":"ref/Microsoft.Coyote.Actors/EventGroup/EventGroup/#see-also","text":"class EventGroup namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/EventGroup/Id/","text":"EventGroup.Id property The unique id of this EventGroup , initialized with Guid.Empty. public Guid Id { get; } See Also class EventGroup namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Id"},{"location":"ref/Microsoft.Coyote.Actors/EventGroup/Id/#eventgroupid-property","text":"The unique id of this EventGroup , initialized with Guid.Empty. public Guid Id { get; }","title":"EventGroup.Id property"},{"location":"ref/Microsoft.Coyote.Actors/EventGroup/Id/#see-also","text":"class EventGroup namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/EventGroup/Name/","text":"EventGroup.Name property An optional friendly name for this EventGroup . public string Name { get; } See Also class EventGroup namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Name"},{"location":"ref/Microsoft.Coyote.Actors/EventGroup/Name/#eventgroupname-property","text":"An optional friendly name for this EventGroup . public string Name { get; }","title":"EventGroup.Name property"},{"location":"ref/Microsoft.Coyote.Actors/EventGroup/Name/#see-also","text":"class EventGroup namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/EventGroup/Null/","text":"EventGroup.Null field A special null event group that can be used to stop the CurrentEventGroup from being passed along when CreateActor or SendEvent is invoked. public static EventGroup Null; See Also class EventGroup namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":""},{"location":"ref/Microsoft.Coyote.Actors/EventGroup/Null/#eventgroupnull-field","text":"A special null event group that can be used to stop the CurrentEventGroup from being passed along when CreateActor or SendEvent is invoked. public static EventGroup Null;","title":"EventGroup.Null field"},{"location":"ref/Microsoft.Coyote.Actors/EventGroup/Null/#see-also","text":"class EventGroup namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/HaltEvent/Instance/","text":"HaltEvent.Instance property Gets a HaltEvent instance. public static HaltEvent Instance { get; } See Also class HaltEvent namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Instance"},{"location":"ref/Microsoft.Coyote.Actors/HaltEvent/Instance/#halteventinstance-property","text":"Gets a HaltEvent instance. public static HaltEvent Instance { get; }","title":"HaltEvent.Instance property"},{"location":"ref/Microsoft.Coyote.Actors/HaltEvent/Instance/#see-also","text":"class HaltEvent namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/CreateActor/","text":"IActorRuntime.CreateActor method (1 of 3) Creates a new actor of the specified Type and with the specified optional Event . This event is given to the Event) method on the new actor. public ActorId CreateActor(Type type, Event initialEvent = null, EventGroup eventGroup = null) parameter description type Type of the actor. initialEvent Optional event used during initialization. eventGroup An optional event group associated with the new Actor. Return Value The result is the actor id. See Also class ActorId class Event class EventGroup interface IActorRuntime namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote IActorRuntime.CreateActor method (2 of 3) Creates a new actor of the specified type, using the specified ActorId . This method optionally passes an Event . This event is given to the InitializeAsync method on the new actor. public ActorId CreateActor(ActorId id, Type type, Event initialEvent = null, EventGroup eventGroup = null) parameter description id Unbound actor id. type Type of the actor. initialEvent Optional event used during initialization. eventGroup An optional event group associated with the new Actor. Return Value The result is the actor id. See Also class ActorId class Event class EventGroup interface IActorRuntime namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote IActorRuntime.CreateActor method (3 of 3) Creates a new actor of the specified Type and name, and with the specified optional Event . This event is given to the Event) method on the new actor. public ActorId CreateActor(Type type, string name, Event initialEvent = null, EventGroup eventGroup = null) parameter description type Type of the actor. name Optional name used for logging. initialEvent Optional event used during initialization. eventGroup An optional event group associated with the new Actor. Return Value The result is the actor id. See Also class ActorId class Event class EventGroup interface IActorRuntime namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"CreateActor"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/CreateActor/#iactorruntimecreateactor-method-1-of-3","text":"Creates a new actor of the specified Type and with the specified optional Event . This event is given to the Event) method on the new actor. public ActorId CreateActor(Type type, Event initialEvent = null, EventGroup eventGroup = null) parameter description type Type of the actor. initialEvent Optional event used during initialization. eventGroup An optional event group associated with the new Actor.","title":"IActorRuntime.CreateActor method (1 of 3)"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/CreateActor/#return-value","text":"The result is the actor id.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/CreateActor/#see-also","text":"class ActorId class Event class EventGroup interface IActorRuntime namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/CreateActor/#iactorruntimecreateactor-method-2-of-3","text":"Creates a new actor of the specified type, using the specified ActorId . This method optionally passes an Event . This event is given to the InitializeAsync method on the new actor. public ActorId CreateActor(ActorId id, Type type, Event initialEvent = null, EventGroup eventGroup = null) parameter description id Unbound actor id. type Type of the actor. initialEvent Optional event used during initialization. eventGroup An optional event group associated with the new Actor.","title":"IActorRuntime.CreateActor method (2 of 3)"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/CreateActor/#return-value_1","text":"The result is the actor id.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/CreateActor/#see-also_1","text":"class ActorId class Event class EventGroup interface IActorRuntime namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/CreateActor/#iactorruntimecreateactor-method-3-of-3","text":"Creates a new actor of the specified Type and name, and with the specified optional Event . This event is given to the Event) method on the new actor. public ActorId CreateActor(Type type, string name, Event initialEvent = null, EventGroup eventGroup = null) parameter description type Type of the actor. name Optional name used for logging. initialEvent Optional event used during initialization. eventGroup An optional event group associated with the new Actor.","title":"IActorRuntime.CreateActor method (3 of 3)"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/CreateActor/#return-value_2","text":"The result is the actor id.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/CreateActor/#see-also_2","text":"class ActorId class Event class EventGroup interface IActorRuntime namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/CreateActorId/","text":"IActorRuntime.CreateActorId method Creates a fresh actor id that has not yet been bound to any actor. public ActorId CreateActorId(Type type, string name = null) parameter description type Type of the actor. name Optional name used for logging. Return Value The result is the actor id. See Also class ActorId interface IActorRuntime namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"CreateActorId"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/CreateActorId/#iactorruntimecreateactorid-method","text":"Creates a fresh actor id that has not yet been bound to any actor. public ActorId CreateActorId(Type type, string name = null) parameter description type Type of the actor. name Optional name used for logging.","title":"IActorRuntime.CreateActorId method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/CreateActorId/#return-value","text":"The result is the actor id.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/CreateActorId/#see-also","text":"class ActorId interface IActorRuntime namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/CreateActorIdFromName/","text":"IActorRuntime.CreateActorIdFromName method Creates a actor id that is uniquely tied to the specified unique name. The returned actor id can either be a fresh id (not yet bound to any actor), or it can be bound to a previously created actor. In the second case, this actor id can be directly used to communicate with the corresponding actor. public ActorId CreateActorIdFromName(Type type, string name) parameter description type Type of the actor. name Unique name used to create or get the actor id. Return Value The result is the actor id. See Also class ActorId interface IActorRuntime namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"CreateActorIdFromName"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/CreateActorIdFromName/#iactorruntimecreateactoridfromname-method","text":"Creates a actor id that is uniquely tied to the specified unique name. The returned actor id can either be a fresh id (not yet bound to any actor), or it can be bound to a previously created actor. In the second case, this actor id can be directly used to communicate with the corresponding actor. public ActorId CreateActorIdFromName(Type type, string name) parameter description type Type of the actor. name Unique name used to create or get the actor id.","title":"IActorRuntime.CreateActorIdFromName method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/CreateActorIdFromName/#return-value","text":"The result is the actor id.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/CreateActorIdFromName/#see-also","text":"class ActorId interface IActorRuntime namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/GetCurrentEventGroup/","text":"IActorRuntime.GetCurrentEventGroup method Returns the current EventGroup of the actor with the specified id. Returns null if the id is not set, or if the ActorId is not associated with this runtime. During testing, the runtime asserts that the specified actor is currently executing. public EventGroup GetCurrentEventGroup(ActorId currentActorId) parameter description currentActorId The id of the currently executing actor. Return Value The current EventGroup or null. See Also class EventGroup class ActorId interface IActorRuntime namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"GetCurrentEventGroup"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/GetCurrentEventGroup/#iactorruntimegetcurrenteventgroup-method","text":"Returns the current EventGroup of the actor with the specified id. Returns null if the id is not set, or if the ActorId is not associated with this runtime. During testing, the runtime asserts that the specified actor is currently executing. public EventGroup GetCurrentEventGroup(ActorId currentActorId) parameter description currentActorId The id of the currently executing actor.","title":"IActorRuntime.GetCurrentEventGroup method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/GetCurrentEventGroup/#return-value","text":"The current EventGroup or null.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/GetCurrentEventGroup/#see-also","text":"class EventGroup class ActorId interface IActorRuntime namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/OnEventDropped/","text":"IActorRuntime.OnEventDropped event Callback that is fired when an event is dropped. public event OnEventDroppedHandler OnEventDropped; See Also delegate OnEventDroppedHandler interface IActorRuntime namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnEventDropped"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/OnEventDropped/#iactorruntimeoneventdropped-event","text":"Callback that is fired when an event is dropped. public event OnEventDroppedHandler OnEventDropped;","title":"IActorRuntime.OnEventDropped event"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/OnEventDropped/#see-also","text":"delegate OnEventDroppedHandler interface IActorRuntime namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/RegisterLog/","text":"IActorRuntime.RegisterLog method Use this method to register an IActorRuntimeLog . public void RegisterLog(IActorRuntimeLog log) parameter description log The log writer to register. See Also interface IActorRuntimeLog interface IActorRuntime namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"RegisterLog"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/RegisterLog/#iactorruntimeregisterlog-method","text":"Use this method to register an IActorRuntimeLog . public void RegisterLog(IActorRuntimeLog log) parameter description log The log writer to register.","title":"IActorRuntime.RegisterLog method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/RegisterLog/#see-also","text":"interface IActorRuntimeLog interface IActorRuntime namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/RemoveLog/","text":"IActorRuntime.RemoveLog method Use this method to unregister a previously registered IActorRuntimeLog . public void RemoveLog(IActorRuntimeLog log) parameter description log The previously registered log writer to unregister. See Also interface IActorRuntimeLog interface IActorRuntime namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"RemoveLog"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/RemoveLog/#iactorruntimeremovelog-method","text":"Use this method to unregister a previously registered IActorRuntimeLog . public void RemoveLog(IActorRuntimeLog log) parameter description log The previously registered log writer to unregister.","title":"IActorRuntime.RemoveLog method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/RemoveLog/#see-also","text":"interface IActorRuntimeLog interface IActorRuntime namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/SendEvent/","text":"IActorRuntime.SendEvent method Sends an asynchronous Event to an actor. public void SendEvent(ActorId targetId, Event e, EventGroup eventGroup = null, SendOptions options = null) parameter description targetId The id of the target. e The event to send. eventGroup An optional event group associated with this Actor. options Optional configuration of a send operation. See Also class ActorId class Event class EventGroup class SendOptions interface IActorRuntime namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"SendEvent"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/SendEvent/#iactorruntimesendevent-method","text":"Sends an asynchronous Event to an actor. public void SendEvent(ActorId targetId, Event e, EventGroup eventGroup = null, SendOptions options = null) parameter description targetId The id of the target. e The event to send. eventGroup An optional event group associated with this Actor. options Optional configuration of a send operation.","title":"IActorRuntime.SendEvent method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntime/SendEvent/#see-also","text":"class ActorId class Event class EventGroup class SendOptions interface IActorRuntime namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnAssertionFailure/","text":"IActorRuntimeLog.OnAssertionFailure method Invoked when the specified assertion failure has occurred. public void OnAssertionFailure(string error) parameter description error The text of the error. See Also interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnAssertionFailure"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnAssertionFailure/#iactorruntimelogonassertionfailure-method","text":"Invoked when the specified assertion failure has occurred. public void OnAssertionFailure(string error) parameter description error The text of the error.","title":"IActorRuntimeLog.OnAssertionFailure method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnAssertionFailure/#see-also","text":"interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnCompleted/","text":"IActorRuntimeLog.OnCompleted method Invoked when a log is complete (and is about to be closed). public void OnCompleted() See Also interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnCompleted"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnCompleted/#iactorruntimelogoncompleted-method","text":"Invoked when a log is complete (and is about to be closed). public void OnCompleted()","title":"IActorRuntimeLog.OnCompleted method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnCompleted/#see-also","text":"interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnCreateActor/","text":"IActorRuntimeLog.OnCreateActor method Invoked when the specified actor has been created. public void OnCreateActor(ActorId id, string creatorName, string creatorType) parameter description id The id of the actor that has been created. creatorName The name of the creator, or null. creatorType The type of the creator, or null. See Also class ActorId interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnCreateActor"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnCreateActor/#iactorruntimelogoncreateactor-method","text":"Invoked when the specified actor has been created. public void OnCreateActor(ActorId id, string creatorName, string creatorType) parameter description id The id of the actor that has been created. creatorName The name of the creator, or null. creatorType The type of the creator, or null.","title":"IActorRuntimeLog.OnCreateActor method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnCreateActor/#see-also","text":"class ActorId interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnCreateMonitor/","text":"IActorRuntimeLog.OnCreateMonitor method Invoked when the specified monitor has been created. public void OnCreateMonitor(string monitorType) parameter description monitorType The name of the type of the monitor that has been created. See Also interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnCreateMonitor"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnCreateMonitor/#iactorruntimelogoncreatemonitor-method","text":"Invoked when the specified monitor has been created. public void OnCreateMonitor(string monitorType) parameter description monitorType The name of the type of the monitor that has been created.","title":"IActorRuntimeLog.OnCreateMonitor method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnCreateMonitor/#see-also","text":"interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnCreateStateMachine/","text":"IActorRuntimeLog.OnCreateStateMachine method Invoked when the specified state machine has been created. public void OnCreateStateMachine(ActorId id, string creatorName, string creatorType) parameter description id The id of the state machine that has been created. creatorName The name of the creator, or null. creatorType The type of the creator, or null. See Also class ActorId interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnCreateStateMachine"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnCreateStateMachine/#iactorruntimelogoncreatestatemachine-method","text":"Invoked when the specified state machine has been created. public void OnCreateStateMachine(ActorId id, string creatorName, string creatorType) parameter description id The id of the state machine that has been created. creatorName The name of the creator, or null. creatorType The type of the creator, or null.","title":"IActorRuntimeLog.OnCreateStateMachine method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnCreateStateMachine/#see-also","text":"class ActorId interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnCreateTimer/","text":"IActorRuntimeLog.OnCreateTimer method Invoked when the specified actor timer has been created. public void OnCreateTimer(TimerInfo info) parameter description info Handle that contains information about the timer. See Also class TimerInfo interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnCreateTimer"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnCreateTimer/#iactorruntimelogoncreatetimer-method","text":"Invoked when the specified actor timer has been created. public void OnCreateTimer(TimerInfo info) parameter description info Handle that contains information about the timer.","title":"IActorRuntimeLog.OnCreateTimer method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnCreateTimer/#see-also","text":"class TimerInfo interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnDefaultEventHandler/","text":"IActorRuntimeLog.OnDefaultEventHandler method Invoked when the specified actor is idle (there is nothing to dequeue) and the default event handler is about to be executed. public void OnDefaultEventHandler(ActorId id, string stateName) parameter description id The id of the actor that the state will execute in. stateName The state name, if the actor is a state machine and a state exists, else null. See Also class ActorId interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnDefaultEventHandler"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnDefaultEventHandler/#iactorruntimelogondefaulteventhandler-method","text":"Invoked when the specified actor is idle (there is nothing to dequeue) and the default event handler is about to be executed. public void OnDefaultEventHandler(ActorId id, string stateName) parameter description id The id of the actor that the state will execute in. stateName The state name, if the actor is a state machine and a state exists, else null.","title":"IActorRuntimeLog.OnDefaultEventHandler method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnDefaultEventHandler/#see-also","text":"class ActorId interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnDequeueEvent/","text":"IActorRuntimeLog.OnDequeueEvent method Invoked when the specified event is dequeued by an actor. public void OnDequeueEvent(ActorId id, string stateName, Event e) parameter description id The id of the actor that the event is being dequeued by. stateName The state name, if the actor is a state machine and a state exists, else null. e The event being dequeued. See Also class ActorId class Event interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnDequeueEvent"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnDequeueEvent/#iactorruntimelogondequeueevent-method","text":"Invoked when the specified event is dequeued by an actor. public void OnDequeueEvent(ActorId id, string stateName, Event e) parameter description id The id of the actor that the event is being dequeued by. stateName The state name, if the actor is a state machine and a state exists, else null. e The event being dequeued.","title":"IActorRuntimeLog.OnDequeueEvent method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnDequeueEvent/#see-also","text":"class ActorId class Event interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnEnqueueEvent/","text":"IActorRuntimeLog.OnEnqueueEvent method Invoked when the specified event is about to be enqueued to an actor. public void OnEnqueueEvent(ActorId id, Event e) parameter description id The id of the actor that the event is being enqueued to. e The event being enqueued. See Also class ActorId class Event interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnEnqueueEvent"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnEnqueueEvent/#iactorruntimelogonenqueueevent-method","text":"Invoked when the specified event is about to be enqueued to an actor. public void OnEnqueueEvent(ActorId id, Event e) parameter description id The id of the actor that the event is being enqueued to. e The event being enqueued.","title":"IActorRuntimeLog.OnEnqueueEvent method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnEnqueueEvent/#see-also","text":"class ActorId class Event interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnEventHandlerTerminated/","text":"IActorRuntimeLog.OnEventHandlerTerminated method Invoked when the event handler of the specified actor terminated. public void OnEventHandlerTerminated(ActorId id, string stateName, DequeueStatus dequeueStatus) parameter description id The id of the actor with the handler that terminated. stateName The state name, if the actor is a state machine and a state exists, else null. dequeueStatus The status returned as the result of the last dequeue operation. See Also class ActorId enum DequeueStatus interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnEventHandlerTerminated"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnEventHandlerTerminated/#iactorruntimelogoneventhandlerterminated-method","text":"Invoked when the event handler of the specified actor terminated. public void OnEventHandlerTerminated(ActorId id, string stateName, DequeueStatus dequeueStatus) parameter description id The id of the actor with the handler that terminated. stateName The state name, if the actor is a state machine and a state exists, else null. dequeueStatus The status returned as the result of the last dequeue operation.","title":"IActorRuntimeLog.OnEventHandlerTerminated method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnEventHandlerTerminated/#see-also","text":"class ActorId enum DequeueStatus interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnExceptionHandled/","text":"IActorRuntimeLog.OnExceptionHandled method Invoked when the specified OnException method is used to handle a thrown exception. public void OnExceptionHandled(ActorId id, string stateName, string actionName, Exception ex) parameter description id The id of the actor that threw the exception. stateName The state name, if the actor is a state machine and a state exists, else null. actionName The name of the action being executed. ex The exception. See Also class ActorId interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnExceptionHandled"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnExceptionHandled/#iactorruntimelogonexceptionhandled-method","text":"Invoked when the specified OnException method is used to handle a thrown exception. public void OnExceptionHandled(ActorId id, string stateName, string actionName, Exception ex) parameter description id The id of the actor that threw the exception. stateName The state name, if the actor is a state machine and a state exists, else null. actionName The name of the action being executed. ex The exception.","title":"IActorRuntimeLog.OnExceptionHandled method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnExceptionHandled/#see-also","text":"class ActorId interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnExceptionThrown/","text":"IActorRuntimeLog.OnExceptionThrown method Invoked when the specified actor throws an exception. public void OnExceptionThrown(ActorId id, string stateName, string actionName, Exception ex) parameter description id The id of the actor that threw the exception. stateName The state name, if the actor is a state machine and a state exists, else null. actionName The name of the action being executed. ex The exception. See Also class ActorId interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnExceptionThrown"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnExceptionThrown/#iactorruntimelogonexceptionthrown-method","text":"Invoked when the specified actor throws an exception. public void OnExceptionThrown(ActorId id, string stateName, string actionName, Exception ex) parameter description id The id of the actor that threw the exception. stateName The state name, if the actor is a state machine and a state exists, else null. actionName The name of the action being executed. ex The exception.","title":"IActorRuntimeLog.OnExceptionThrown method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnExceptionThrown/#see-also","text":"class ActorId interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnExecuteAction/","text":"IActorRuntimeLog.OnExecuteAction method Invoked when the specified actor executes an action. public void OnExecuteAction(ActorId id, string handlingStateName, string currentStateName, string actionName) parameter description id The id of the actor executing the action. handlingStateName The state that declared this action (can be different from currentStateName in the case of pushed states. currentStateName The state name, if the actor is a state machine and a state exists, else null. actionName The name of the action being executed. See Also class ActorId interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnExecuteAction"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnExecuteAction/#iactorruntimelogonexecuteaction-method","text":"Invoked when the specified actor executes an action. public void OnExecuteAction(ActorId id, string handlingStateName, string currentStateName, string actionName) parameter description id The id of the actor executing the action. handlingStateName The state that declared this action (can be different from currentStateName in the case of pushed states. currentStateName The state name, if the actor is a state machine and a state exists, else null. actionName The name of the action being executed.","title":"IActorRuntimeLog.OnExecuteAction method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnExecuteAction/#see-also","text":"class ActorId interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnGotoState/","text":"IActorRuntimeLog.OnGotoState method Invoked when the specified state machine performs a goto transition to the specified state. public void OnGotoState(ActorId id, string currentStateName, string newStateName) parameter description id The id of the actor. currentStateName The name of the current state. newStateName The target state of the transition. See Also class ActorId interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnGotoState"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnGotoState/#iactorruntimelogongotostate-method","text":"Invoked when the specified state machine performs a goto transition to the specified state. public void OnGotoState(ActorId id, string currentStateName, string newStateName) parameter description id The id of the actor. currentStateName The name of the current state. newStateName The target state of the transition.","title":"IActorRuntimeLog.OnGotoState method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnGotoState/#see-also","text":"class ActorId interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnHalt/","text":"IActorRuntimeLog.OnHalt method Invoked when the specified actor has been halted. public void OnHalt(ActorId id, int inboxSize) parameter description id The id of the actor that has been halted. inboxSize Approximate size of the inbox. See Also class ActorId interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnHalt"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnHalt/#iactorruntimelogonhalt-method","text":"Invoked when the specified actor has been halted. public void OnHalt(ActorId id, int inboxSize) parameter description id The id of the actor that has been halted. inboxSize Approximate size of the inbox.","title":"IActorRuntimeLog.OnHalt method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnHalt/#see-also","text":"class ActorId interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnHandleRaisedEvent/","text":"IActorRuntimeLog.OnHandleRaisedEvent method Invoked when the specified actor handled a raised event. public void OnHandleRaisedEvent(ActorId id, string stateName, Event e) parameter description id The id of the actor handling the event. stateName The state name, if the actor is a state machine and a state exists, else null. e The event being handled. See Also class ActorId class Event interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnHandleRaisedEvent"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnHandleRaisedEvent/#iactorruntimelogonhandleraisedevent-method","text":"Invoked when the specified actor handled a raised event. public void OnHandleRaisedEvent(ActorId id, string stateName, Event e) parameter description id The id of the actor handling the event. stateName The state name, if the actor is a state machine and a state exists, else null. e The event being handled.","title":"IActorRuntimeLog.OnHandleRaisedEvent method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnHandleRaisedEvent/#see-also","text":"class ActorId class Event interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnMonitorError/","text":"IActorRuntimeLog.OnMonitorError method Invoked when the specified monitor finds an error. public void OnMonitorError(string monitorType, string stateName, bool? isInHotState) parameter description monitorType The name of the type of the monitor. stateName The name of the current state. isInHotState If true, the monitor is in a hot state; if false, the monitor is in a cold state; else no liveness state is available. See Also interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnMonitorError"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnMonitorError/#iactorruntimelogonmonitorerror-method","text":"Invoked when the specified monitor finds an error. public void OnMonitorError(string monitorType, string stateName, bool? isInHotState) parameter description monitorType The name of the type of the monitor. stateName The name of the current state. isInHotState If true, the monitor is in a hot state; if false, the monitor is in a cold state; else no liveness state is available.","title":"IActorRuntimeLog.OnMonitorError method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnMonitorError/#see-also","text":"interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnMonitorExecuteAction/","text":"IActorRuntimeLog.OnMonitorExecuteAction method Invoked when the specified monitor executes an action. public void OnMonitorExecuteAction(string monitorType, string stateName, string actionName) parameter description monitorType Name of type of the monitor that is executing the action. stateName The name of the state in which the action is being executed. actionName The name of the action being executed. See Also interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnMonitorExecuteAction"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnMonitorExecuteAction/#iactorruntimelogonmonitorexecuteaction-method","text":"Invoked when the specified monitor executes an action. public void OnMonitorExecuteAction(string monitorType, string stateName, string actionName) parameter description monitorType Name of type of the monitor that is executing the action. stateName The name of the state in which the action is being executed. actionName The name of the action being executed.","title":"IActorRuntimeLog.OnMonitorExecuteAction method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnMonitorExecuteAction/#see-also","text":"interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnMonitorProcessEvent/","text":"IActorRuntimeLog.OnMonitorProcessEvent method Invoked when the specified monitor is about to process an event. public void OnMonitorProcessEvent(string monitorType, string stateName, string senderName, string senderType, string senderStateName, Event e) parameter description monitorType Name of type of the monitor that will process the event. stateName The name of the state in which the event is being raised. senderName The name of the sender, if any. senderType The type of the sender, if any. senderStateName The name of the state the sender is in. e The event being processed. See Also class Event interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnMonitorProcessEvent"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnMonitorProcessEvent/#iactorruntimelogonmonitorprocessevent-method","text":"Invoked when the specified monitor is about to process an event. public void OnMonitorProcessEvent(string monitorType, string stateName, string senderName, string senderType, string senderStateName, Event e) parameter description monitorType Name of type of the monitor that will process the event. stateName The name of the state in which the event is being raised. senderName The name of the sender, if any. senderType The type of the sender, if any. senderStateName The name of the state the sender is in. e The event being processed.","title":"IActorRuntimeLog.OnMonitorProcessEvent method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnMonitorProcessEvent/#see-also","text":"class Event interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnMonitorRaiseEvent/","text":"IActorRuntimeLog.OnMonitorRaiseEvent method Invoked when the specified monitor raised an event. public void OnMonitorRaiseEvent(string monitorType, string stateName, Event e) parameter description monitorType Name of type of the monitor raising the event. stateName The name of the state in which the event is being raised. e The event being raised. See Also class Event interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnMonitorRaiseEvent"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnMonitorRaiseEvent/#iactorruntimelogonmonitorraiseevent-method","text":"Invoked when the specified monitor raised an event. public void OnMonitorRaiseEvent(string monitorType, string stateName, Event e) parameter description monitorType Name of type of the monitor raising the event. stateName The name of the state in which the event is being raised. e The event being raised.","title":"IActorRuntimeLog.OnMonitorRaiseEvent method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnMonitorRaiseEvent/#see-also","text":"class Event interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnMonitorStateTransition/","text":"IActorRuntimeLog.OnMonitorStateTransition method Invoked when the specified monitor enters or exits a state. public void OnMonitorStateTransition(string monitorType, string stateName, bool isEntry, bool? isInHotState) parameter description monitorType The name of the type of the monitor entering or exiting the state. stateName The name of the state being entered or exited; if isInHotState is not null, then the temperature is appended to the statename in brackets, e.g. \u201cstateName[hot]\u201d. isEntry If true, this is called for a state entry; otherwise, exit. isInHotState If true, the monitor is in a hot state; if false, the monitor is in a cold state; else no liveness state is available. See Also interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnMonitorStateTransition"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnMonitorStateTransition/#iactorruntimelogonmonitorstatetransition-method","text":"Invoked when the specified monitor enters or exits a state. public void OnMonitorStateTransition(string monitorType, string stateName, bool isEntry, bool? isInHotState) parameter description monitorType The name of the type of the monitor entering or exiting the state. stateName The name of the state being entered or exited; if isInHotState is not null, then the temperature is appended to the statename in brackets, e.g. \u201cstateName[hot]\u201d. isEntry If true, this is called for a state entry; otherwise, exit. isInHotState If true, the monitor is in a hot state; if false, the monitor is in a cold state; else no liveness state is available.","title":"IActorRuntimeLog.OnMonitorStateTransition method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnMonitorStateTransition/#see-also","text":"interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnPopState/","text":"IActorRuntimeLog.OnPopState method Invoked when the specified state machine has popped its current state. public void OnPopState(ActorId id, string currentStateName, string restoredStateName) parameter description id The id of the actor that the pop executed in. currentStateName The name of the current state. restoredStateName The name of the state being re-entered, if any. See Also class ActorId interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnPopState"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnPopState/#iactorruntimelogonpopstate-method","text":"Invoked when the specified state machine has popped its current state. public void OnPopState(ActorId id, string currentStateName, string restoredStateName) parameter description id The id of the actor that the pop executed in. currentStateName The name of the current state. restoredStateName The name of the state being re-entered, if any.","title":"IActorRuntimeLog.OnPopState method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnPopState/#see-also","text":"class ActorId interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnPopStateUnhandledEvent/","text":"IActorRuntimeLog.OnPopStateUnhandledEvent method Invoked when the specified event cannot be handled in the current state, its exit handler is executed and then the state is popped and any previous \u201ccurrent state\u201d is reentered. This handler is called when that pop has been done. public void OnPopStateUnhandledEvent(ActorId id, string stateName, Event e) parameter description id The id of the actor that the pop executed in. stateName The state name, if the actor is a state machine and a state exists, else null. e The event that cannot be handled. See Also class ActorId class Event interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnPopStateUnhandledEvent"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnPopStateUnhandledEvent/#iactorruntimelogonpopstateunhandledevent-method","text":"Invoked when the specified event cannot be handled in the current state, its exit handler is executed and then the state is popped and any previous \u201ccurrent state\u201d is reentered. This handler is called when that pop has been done. public void OnPopStateUnhandledEvent(ActorId id, string stateName, Event e) parameter description id The id of the actor that the pop executed in. stateName The state name, if the actor is a state machine and a state exists, else null. e The event that cannot be handled.","title":"IActorRuntimeLog.OnPopStateUnhandledEvent method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnPopStateUnhandledEvent/#see-also","text":"class ActorId class Event interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnPushState/","text":"IActorRuntimeLog.OnPushState method Invoked when the specified state machine is being pushed to a state. public void OnPushState(ActorId id, string currentStateName, string newStateName) parameter description id The id of the actor being pushed to the state. currentStateName The name of the current state. newStateName The target state of the transition. See Also class ActorId interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnPushState"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnPushState/#iactorruntimelogonpushstate-method","text":"Invoked when the specified state machine is being pushed to a state. public void OnPushState(ActorId id, string currentStateName, string newStateName) parameter description id The id of the actor being pushed to the state. currentStateName The name of the current state. newStateName The target state of the transition.","title":"IActorRuntimeLog.OnPushState method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnPushState/#see-also","text":"class ActorId interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnRaiseEvent/","text":"IActorRuntimeLog.OnRaiseEvent method Invoked when the specified state machine raises an event. public void OnRaiseEvent(ActorId id, string stateName, Event e) parameter description id The id of the actor raising the event. stateName The name of the current state. e The event being raised. See Also class ActorId class Event interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnRaiseEvent"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnRaiseEvent/#iactorruntimelogonraiseevent-method","text":"Invoked when the specified state machine raises an event. public void OnRaiseEvent(ActorId id, string stateName, Event e) parameter description id The id of the actor raising the event. stateName The name of the current state. e The event being raised.","title":"IActorRuntimeLog.OnRaiseEvent method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnRaiseEvent/#see-also","text":"class ActorId class Event interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnRandom/","text":"IActorRuntimeLog.OnRandom method Invoked when the specified controlled nondeterministic result has been obtained. public void OnRandom(object result, string callerName, string callerType) parameter description result The nondeterministic result (may be bool or int). callerName The name of the caller, if any. callerType The type of the caller, if any. See Also interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnRandom"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnRandom/#iactorruntimelogonrandom-method","text":"Invoked when the specified controlled nondeterministic result has been obtained. public void OnRandom(object result, string callerName, string callerType) parameter description result The nondeterministic result (may be bool or int). callerName The name of the caller, if any. callerType The type of the caller, if any.","title":"IActorRuntimeLog.OnRandom method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnRandom/#see-also","text":"interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnReceiveEvent/","text":"IActorRuntimeLog.OnReceiveEvent method Invoked when the specified event is received by an actor. public void OnReceiveEvent(ActorId id, string stateName, Event e, bool wasBlocked) parameter description id The id of the actor that received the event. stateName The state name, if the actor is a state machine and a state exists, else null. e The the event being received. wasBlocked The actor was waiting for one or more specific events, and e was one of them. See Also class ActorId class Event interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnReceiveEvent"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnReceiveEvent/#iactorruntimelogonreceiveevent-method","text":"Invoked when the specified event is received by an actor. public void OnReceiveEvent(ActorId id, string stateName, Event e, bool wasBlocked) parameter description id The id of the actor that received the event. stateName The state name, if the actor is a state machine and a state exists, else null. e The the event being received. wasBlocked The actor was waiting for one or more specific events, and e was one of them.","title":"IActorRuntimeLog.OnReceiveEvent method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnReceiveEvent/#see-also","text":"class ActorId class Event interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnSendEvent/","text":"IActorRuntimeLog.OnSendEvent method Invoked when the specified event is sent to a target actor. public void OnSendEvent(ActorId targetActorId, string senderName, string senderType, string senderStateName, Event e, Guid eventGroupId, bool isTargetHalted) parameter description targetActorId The id of the target actor. senderName The name of the sender, if any. senderType The type of the sender, if any. senderStateName The state name, if the sender is a state machine, else null. e The event being sent. eventGroupId The id used to identify the send operation. isTargetHalted Is the target actor halted. See Also class ActorId class Event interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnSendEvent"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnSendEvent/#iactorruntimelogonsendevent-method","text":"Invoked when the specified event is sent to a target actor. public void OnSendEvent(ActorId targetActorId, string senderName, string senderType, string senderStateName, Event e, Guid eventGroupId, bool isTargetHalted) parameter description targetActorId The id of the target actor. senderName The name of the sender, if any. senderType The type of the sender, if any. senderStateName The state name, if the sender is a state machine, else null. e The event being sent. eventGroupId The id used to identify the send operation. isTargetHalted Is the target actor halted.","title":"IActorRuntimeLog.OnSendEvent method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnSendEvent/#see-also","text":"class ActorId class Event interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnStateTransition/","text":"IActorRuntimeLog.OnStateTransition method Invoked when the specified state machine enters or exits a state. public void OnStateTransition(ActorId id, string stateName, bool isEntry) parameter description id The id of the actor entering or exiting the state. stateName The name of the state being entered or exited. isEntry If true, this is called for a state entry; otherwise, exit. See Also class ActorId interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnStateTransition"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnStateTransition/#iactorruntimelogonstatetransition-method","text":"Invoked when the specified state machine enters or exits a state. public void OnStateTransition(ActorId id, string stateName, bool isEntry) parameter description id The id of the actor entering or exiting the state. stateName The name of the state being entered or exited. isEntry If true, this is called for a state entry; otherwise, exit.","title":"IActorRuntimeLog.OnStateTransition method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnStateTransition/#see-also","text":"class ActorId interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnStopTimer/","text":"IActorRuntimeLog.OnStopTimer method Invoked when the specified actor timer has been stopped. public void OnStopTimer(TimerInfo info) parameter description info Handle that contains information about the timer. See Also class TimerInfo interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnStopTimer"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnStopTimer/#iactorruntimelogonstoptimer-method","text":"Invoked when the specified actor timer has been stopped. public void OnStopTimer(TimerInfo info) parameter description info Handle that contains information about the timer.","title":"IActorRuntimeLog.OnStopTimer method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnStopTimer/#see-also","text":"class TimerInfo interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnStrategyDescription/","text":"IActorRuntimeLog.OnStrategyDescription method Invoked to describe the specified scheduling strategy. public void OnStrategyDescription(string strategyName, string description) parameter description strategyName The name of the strategy that was used. description More information about the scheduling strategy. See Also interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnStrategyDescription"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnStrategyDescription/#iactorruntimelogonstrategydescription-method","text":"Invoked to describe the specified scheduling strategy. public void OnStrategyDescription(string strategyName, string description) parameter description strategyName The name of the strategy that was used. description More information about the scheduling strategy.","title":"IActorRuntimeLog.OnStrategyDescription method"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnStrategyDescription/#see-also","text":"interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnWaitEvent/","text":"IActorRuntimeLog.OnWaitEvent method (1 of 2) Invoked when the specified actor waits to receive an event of a specified type. public void OnWaitEvent(ActorId id, string stateName, Type eventType) parameter description id The id of the actor that is entering the wait state. stateName The state name, if the actor is a state machine and a state exists, else null. eventType The type of the event being waited for. See Also class ActorId interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote IActorRuntimeLog.OnWaitEvent method (2 of 2) Invoked when the specified actor waits to receive an event of one of the specified types. public void OnWaitEvent(ActorId id, string stateName, params Type[] eventTypes) parameter description id The id of the actor that is entering the wait state. stateName The state name, if the actor is a state machine and a state exists, else null. eventTypes The types of the events being waited for, if any. See Also class ActorId interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnWaitEvent"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnWaitEvent/#iactorruntimelogonwaitevent-method-1-of-2","text":"Invoked when the specified actor waits to receive an event of a specified type. public void OnWaitEvent(ActorId id, string stateName, Type eventType) parameter description id The id of the actor that is entering the wait state. stateName The state name, if the actor is a state machine and a state exists, else null. eventType The type of the event being waited for.","title":"IActorRuntimeLog.OnWaitEvent method (1 of 2)"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnWaitEvent/#see-also","text":"class ActorId interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnWaitEvent/#iactorruntimelogonwaitevent-method-2-of-2","text":"Invoked when the specified actor waits to receive an event of one of the specified types. public void OnWaitEvent(ActorId id, string stateName, params Type[] eventTypes) parameter description id The id of the actor that is entering the wait state. stateName The state name, if the actor is a state machine and a state exists, else null. eventTypes The types of the events being waited for, if any.","title":"IActorRuntimeLog.OnWaitEvent method (2 of 2)"},{"location":"ref/Microsoft.Coyote.Actors/IActorRuntimeLog/OnWaitEvent/#see-also_1","text":"class ActorId interface IActorRuntimeLog namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/RuntimeFactory/Create/","text":"RuntimeFactory.Create method (1 of 2) Creates a new actor runtime. public static IActorRuntime Create() Return Value The created actor runtime. Remarks Only one runtime can be created per async local context. This is not a thread-safe operation. See Also interface IActorRuntime class RuntimeFactory namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote RuntimeFactory.Create method (2 of 2) Creates a new actor runtime with the specified Configuration . public static IActorRuntime Create(Configuration configuration) parameter description configuration The runtime configuration to use. Return Value The created actor runtime. Remarks Only one runtime can be created per async local context. This is not a thread-safe operation. See Also interface IActorRuntime class Configuration class RuntimeFactory namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Create"},{"location":"ref/Microsoft.Coyote.Actors/RuntimeFactory/Create/#runtimefactorycreate-method-1-of-2","text":"Creates a new actor runtime. public static IActorRuntime Create()","title":"RuntimeFactory.Create method (1 of 2)"},{"location":"ref/Microsoft.Coyote.Actors/RuntimeFactory/Create/#return-value","text":"The created actor runtime.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Actors/RuntimeFactory/Create/#remarks","text":"Only one runtime can be created per async local context. This is not a thread-safe operation.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Actors/RuntimeFactory/Create/#see-also","text":"interface IActorRuntime class RuntimeFactory namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/RuntimeFactory/Create/#runtimefactorycreate-method-2-of-2","text":"Creates a new actor runtime with the specified Configuration . public static IActorRuntime Create(Configuration configuration) parameter description configuration The runtime configuration to use.","title":"RuntimeFactory.Create method (2 of 2)"},{"location":"ref/Microsoft.Coyote.Actors/RuntimeFactory/Create/#return-value_1","text":"The created actor runtime.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Actors/RuntimeFactory/Create/#remarks_1","text":"Only one runtime can be created per async local context. This is not a thread-safe operation.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Actors/RuntimeFactory/Create/#see-also_1","text":"interface IActorRuntime class Configuration class RuntimeFactory namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/SendOptions/Assert/","text":"SendOptions.Assert property Asserts that there must not be more than N instances of the event in the inbox queue of the receiver. public int Assert { get; } See Also class SendOptions namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Assert"},{"location":"ref/Microsoft.Coyote.Actors/SendOptions/Assert/#sendoptionsassert-property","text":"Asserts that there must not be more than N instances of the event in the inbox queue of the receiver. public int Assert { get; }","title":"SendOptions.Assert property"},{"location":"ref/Microsoft.Coyote.Actors/SendOptions/Assert/#see-also","text":"class SendOptions namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/SendOptions/Default/","text":"SendOptions.Default property The default send options. public static SendOptions Default { get; } See Also class SendOptions namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"Default"},{"location":"ref/Microsoft.Coyote.Actors/SendOptions/Default/#sendoptionsdefault-property","text":"The default send options. public static SendOptions Default { get; }","title":"SendOptions.Default property"},{"location":"ref/Microsoft.Coyote.Actors/SendOptions/Default/#see-also","text":"class SendOptions namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/SendOptions/HashedState/","text":"SendOptions.HashedState property User-defined hash of the event. The default value is 0. Override to improve the accuracy of stateful techniques during testing. public int HashedState { get; } See Also class SendOptions namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"HashedState"},{"location":"ref/Microsoft.Coyote.Actors/SendOptions/HashedState/#sendoptionshashedstate-property","text":"User-defined hash of the event. The default value is 0. Override to improve the accuracy of stateful techniques during testing. public int HashedState { get; }","title":"SendOptions.HashedState property"},{"location":"ref/Microsoft.Coyote.Actors/SendOptions/HashedState/#see-also","text":"class SendOptions namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/SendOptions/MustHandle/","text":"SendOptions.MustHandle property True if this event must always be handled, else false. public bool MustHandle { get; } See Also class SendOptions namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"MustHandle"},{"location":"ref/Microsoft.Coyote.Actors/SendOptions/MustHandle/#sendoptionsmusthandle-property","text":"True if this event must always be handled, else false. public bool MustHandle { get; }","title":"SendOptions.MustHandle property"},{"location":"ref/Microsoft.Coyote.Actors/SendOptions/MustHandle/#see-also","text":"class SendOptions namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/SendOptions/SendOptions/","text":"SendOptions constructor Initializes a new instance of the SendOptions class. public SendOptions(bool mustHandle = false, int assert = -1, int hashedState = 0) See Also class SendOptions namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"SendOptions"},{"location":"ref/Microsoft.Coyote.Actors/SendOptions/SendOptions/#sendoptions-constructor","text":"Initializes a new instance of the SendOptions class. public SendOptions(bool mustHandle = false, int assert = -1, int hashedState = 0)","title":"SendOptions constructor"},{"location":"ref/Microsoft.Coyote.Actors/SendOptions/SendOptions/#see-also","text":"class SendOptions namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/SendOptions/ToString/","text":"SendOptions.ToString method A string that represents the current options. public override string ToString() See Also class SendOptions namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"ToString"},{"location":"ref/Microsoft.Coyote.Actors/SendOptions/ToString/#sendoptionstostring-method","text":"A string that represents the current options. public override string ToString()","title":"SendOptions.ToString method"},{"location":"ref/Microsoft.Coyote.Actors/SendOptions/ToString/#see-also","text":"class SendOptions namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/CurrentState/","text":"StateMachine.CurrentState property Gets the Type of the current state. protected internal Type CurrentState { get; } See Also class StateMachine namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"CurrentState"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/CurrentState/#statemachinecurrentstate-property","text":"Gets the Type of the current state. protected internal Type CurrentState { get; }","title":"StateMachine.CurrentState property"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/CurrentState/#see-also","text":"class StateMachine namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/OnEventHandledAsync/","text":"StateMachine.OnEventHandledAsync method Asynchronous callback that is invoked when the actor finishes handling a dequeued event, unless the handler of the dequeued event raised an event or caused the actor to halt (either normally or due to an exception). Unless this callback raises an event, the actor will either become idle or dequeue the next event from its inbox. protected override Task OnEventHandledAsync(Event e) parameter description e The event that was handled. See Also class Event class StateMachine namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnEventHandledAsync"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/OnEventHandledAsync/#statemachineoneventhandledasync-method","text":"Asynchronous callback that is invoked when the actor finishes handling a dequeued event, unless the handler of the dequeued event raised an event or caused the actor to halt (either normally or due to an exception). Unless this callback raises an event, the actor will either become idle or dequeue the next event from its inbox. protected override Task OnEventHandledAsync(Event e) parameter description e The event that was handled.","title":"StateMachine.OnEventHandledAsync method"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/OnEventHandledAsync/#see-also","text":"class Event class StateMachine namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/RaiseEvent/","text":"StateMachine.RaiseEvent method Raises the specified Event at the end of the current action. protected void RaiseEvent(Event e) parameter description e The event to raise. Remarks This event is not handled until the action that calls this method returns control back to the Coyote runtime. It is handled before any other events are dequeued from the inbox. Only one of the following can be called per action: RaiseEvent , RaiseGotoStateEvent , RaisePushStateEvent or RaisePopStateEvent and RaiseHaltEvent . An Assert is raised if you accidentally try and do two of these operations in a single action. See Also class Event class StateMachine namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"RaiseEvent"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/RaiseEvent/#statemachineraiseevent-method","text":"Raises the specified Event at the end of the current action. protected void RaiseEvent(Event e) parameter description e The event to raise.","title":"StateMachine.RaiseEvent method"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/RaiseEvent/#remarks","text":"This event is not handled until the action that calls this method returns control back to the Coyote runtime. It is handled before any other events are dequeued from the inbox. Only one of the following can be called per action: RaiseEvent , RaiseGotoStateEvent , RaisePushStateEvent or RaisePopStateEvent and RaiseHaltEvent . An Assert is raised if you accidentally try and do two of these operations in a single action.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/RaiseEvent/#see-also","text":"class Event class StateMachine namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/RaiseGotoStateEvent/","text":"StateMachine.RaiseGotoStateEvent method (1 of 2) Raise a special event that performs a goto state operation at the end of the current action. protected void RaiseGotoStateEvent(Type state) parameter description state Type of the state. Remarks Goto state pops the current State and pushes the specified State on the active state stack. This is shorthand for the following code: class Event E { } [OnEventGotoState(typeof(E), typeof(S))] this.RaiseEvent(new E()); This event is not handled until the action that calls this method returns control back to the Coyote runtime. It is handled before any other events are dequeued from the inbox. Only one of the following can be called per action: RaiseEvent , RaiseGotoStateEvent , RaisePushStateEvent or RaisePopStateEvent and RaiseHaltEvent . An Assert is raised if you accidentally try and do two of these operations in a single action. See Also class StateMachine namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote StateMachine.RaiseGotoStateEvent<TState> method (2 of 2) Raise a special event that performs a goto state operation at the end of the current action. protected void RaiseGotoStateEvent<TState>() where TState : State parameter description TState Type of the state. Remarks Goto state pops the current State and pushes the specified State on the active state stack. This is shorthand for the following code: class Event E { } [OnEventGotoState(typeof(E), typeof(S))] this.RaiseEvent(new E()); This event is not handled until the action that calls this method returns control back to the Coyote runtime. It is handled before any other events are dequeued from the inbox. Only one of the following can be called per action: RaiseEvent , RaiseGotoStateEvent , RaisePushStateEvent or RaisePopStateEvent and RaiseHaltEvent . An Assert is raised if you accidentally try and do two of these operations in a single action. See Also class State class StateMachine namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"RaiseGotoStateEvent"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/RaiseGotoStateEvent/#statemachineraisegotostateevent-method-1-of-2","text":"Raise a special event that performs a goto state operation at the end of the current action. protected void RaiseGotoStateEvent(Type state) parameter description state Type of the state.","title":"StateMachine.RaiseGotoStateEvent method (1 of 2)"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/RaiseGotoStateEvent/#remarks","text":"Goto state pops the current State and pushes the specified State on the active state stack. This is shorthand for the following code: class Event E { } [OnEventGotoState(typeof(E), typeof(S))] this.RaiseEvent(new E()); This event is not handled until the action that calls this method returns control back to the Coyote runtime. It is handled before any other events are dequeued from the inbox. Only one of the following can be called per action: RaiseEvent , RaiseGotoStateEvent , RaisePushStateEvent or RaisePopStateEvent and RaiseHaltEvent . An Assert is raised if you accidentally try and do two of these operations in a single action.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/RaiseGotoStateEvent/#see-also","text":"class StateMachine namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/RaiseGotoStateEvent/#statemachineraisegotostateeventtstate-method-2-of-2","text":"Raise a special event that performs a goto state operation at the end of the current action. protected void RaiseGotoStateEvent<TState>() where TState : State parameter description TState Type of the state.","title":"StateMachine.RaiseGotoStateEvent&lt;TState&gt; method (2 of 2)"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/RaiseGotoStateEvent/#remarks_1","text":"Goto state pops the current State and pushes the specified State on the active state stack. This is shorthand for the following code: class Event E { } [OnEventGotoState(typeof(E), typeof(S))] this.RaiseEvent(new E()); This event is not handled until the action that calls this method returns control back to the Coyote runtime. It is handled before any other events are dequeued from the inbox. Only one of the following can be called per action: RaiseEvent , RaiseGotoStateEvent , RaisePushStateEvent or RaisePopStateEvent and RaiseHaltEvent . An Assert is raised if you accidentally try and do two of these operations in a single action.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/RaiseGotoStateEvent/#see-also_1","text":"class State class StateMachine namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/RaiseHaltEvent/","text":"StateMachine.RaiseHaltEvent method Raises a HaltEvent to halt the actor at the end of the current action. protected void RaiseHaltEvent() Remarks This event is not handled until the action that calls this method returns control back to the Coyote runtime. It is handled before any other events are dequeued from the inbox. Only one of the following can be called per action: RaiseEvent , RaiseGotoStateEvent , RaisePushStateEvent or RaisePopStateEvent and RaiseHaltEvent . An Assert is raised if you accidentally try and do two of these operations in a single action. See Also class StateMachine namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"RaiseHaltEvent"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/RaiseHaltEvent/#statemachineraisehaltevent-method","text":"Raises a HaltEvent to halt the actor at the end of the current action. protected void RaiseHaltEvent()","title":"StateMachine.RaiseHaltEvent method"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/RaiseHaltEvent/#remarks","text":"This event is not handled until the action that calls this method returns control back to the Coyote runtime. It is handled before any other events are dequeued from the inbox. Only one of the following can be called per action: RaiseEvent , RaiseGotoStateEvent , RaisePushStateEvent or RaisePopStateEvent and RaiseHaltEvent . An Assert is raised if you accidentally try and do two of these operations in a single action.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/RaiseHaltEvent/#see-also","text":"class StateMachine namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/RaisePopStateEvent/","text":"StateMachine.RaisePopStateEvent method Raise a special event that performs a pop state operation at the end of the current action. protected void RaisePopStateEvent() Remarks Popping a state pops the current State that was pushed using RaisePushStateEvent or an OnEventPushStateAttribute. An assert is raised if there are no states left to pop. This event is not handled until the action that calls this method returns control back to the Coyote runtime. It is handled before any other events are dequeued from the inbox. Only one of the following can be called per action: RaiseEvent , RaiseGotoStateEvent , RaisePushStateEvent or RaisePopStateEvent and RaiseHaltEvent . An Assert is raised if you accidentally try and do two of these operations in a single action. See Also class StateMachine namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"RaisePopStateEvent"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/RaisePopStateEvent/#statemachineraisepopstateevent-method","text":"Raise a special event that performs a pop state operation at the end of the current action. protected void RaisePopStateEvent()","title":"StateMachine.RaisePopStateEvent method"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/RaisePopStateEvent/#remarks","text":"Popping a state pops the current State that was pushed using RaisePushStateEvent or an OnEventPushStateAttribute. An assert is raised if there are no states left to pop. This event is not handled until the action that calls this method returns control back to the Coyote runtime. It is handled before any other events are dequeued from the inbox. Only one of the following can be called per action: RaiseEvent , RaiseGotoStateEvent , RaisePushStateEvent or RaisePopStateEvent and RaiseHaltEvent . An Assert is raised if you accidentally try and do two of these operations in a single action.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/RaisePopStateEvent/#see-also","text":"class StateMachine namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/RaisePushStateEvent/","text":"StateMachine.RaisePushStateEvent method (1 of 2) Raise a special event that performs a push state operation at the end of the current action. protected void RaisePushStateEvent(Type state) parameter description state Type of the state. Remarks Pushing a state does not pop the current State , instead it pushes the specified State on the active state stack so that you can have multiple active states. In this case events can be handled by all active states on the stack. This is shorthand for the following code: class Event E { } [OnEventPushState(typeof(E), typeof(S))] this.RaiseEvent(new E()); This event is not handled until the action that calls this method returns control back to the Coyote runtime. It is handled before any other events are dequeued from the inbox. Only one of the following can be called per action: RaiseEvent , RaiseGotoStateEvent , RaisePushStateEvent or RaisePopStateEvent and RaiseHaltEvent . An Assert is raised if you accidentally try and do two of these operations in a single action. See Also class StateMachine namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote StateMachine.RaisePushStateEvent<TState> method (2 of 2) Raise a special event that performs a push state operation at the end of the current action. protected void RaisePushStateEvent<TState>() where TState : State parameter description TState Type of the state. Remarks Pushing a state does not pop the current State , instead it pushes the specified State on the active state stack so that you can have multiple active states. In this case events can be handled by all active states on the stack. This is shorthand for the following code: class Event E { } [OnEventPushState(typeof(E), typeof(S))] this.RaiseEvent(new E()); This event is not handled until the action that calls this method returns control back to the Coyote runtime. It is handled before any other events are dequeued from the inbox. Only one of the following can be called per action: RaiseEvent , RaiseGotoStateEvent , RaisePushStateEvent or RaisePopStateEvent and RaiseHaltEvent . An Assert is raised if you accidentally try and do two of these operations in a single action. See Also class State class StateMachine namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"RaisePushStateEvent"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/RaisePushStateEvent/#statemachineraisepushstateevent-method-1-of-2","text":"Raise a special event that performs a push state operation at the end of the current action. protected void RaisePushStateEvent(Type state) parameter description state Type of the state.","title":"StateMachine.RaisePushStateEvent method (1 of 2)"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/RaisePushStateEvent/#remarks","text":"Pushing a state does not pop the current State , instead it pushes the specified State on the active state stack so that you can have multiple active states. In this case events can be handled by all active states on the stack. This is shorthand for the following code: class Event E { } [OnEventPushState(typeof(E), typeof(S))] this.RaiseEvent(new E()); This event is not handled until the action that calls this method returns control back to the Coyote runtime. It is handled before any other events are dequeued from the inbox. Only one of the following can be called per action: RaiseEvent , RaiseGotoStateEvent , RaisePushStateEvent or RaisePopStateEvent and RaiseHaltEvent . An Assert is raised if you accidentally try and do two of these operations in a single action.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/RaisePushStateEvent/#see-also","text":"class StateMachine namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/RaisePushStateEvent/#statemachineraisepushstateeventtstate-method-2-of-2","text":"Raise a special event that performs a push state operation at the end of the current action. protected void RaisePushStateEvent<TState>() where TState : State parameter description TState Type of the state.","title":"StateMachine.RaisePushStateEvent&lt;TState&gt; method (2 of 2)"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/RaisePushStateEvent/#remarks_1","text":"Pushing a state does not pop the current State , instead it pushes the specified State on the active state stack so that you can have multiple active states. In this case events can be handled by all active states on the stack. This is shorthand for the following code: class Event E { } [OnEventPushState(typeof(E), typeof(S))] this.RaiseEvent(new E()); This event is not handled until the action that calls this method returns control back to the Coyote runtime. It is handled before any other events are dequeued from the inbox. Only one of the following can be called per action: RaiseEvent , RaiseGotoStateEvent , RaisePushStateEvent or RaisePopStateEvent and RaiseHaltEvent . An Assert is raised if you accidentally try and do two of these operations in a single action.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/RaisePushStateEvent/#see-also_1","text":"class State class StateMachine namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/StateMachine/","text":"StateMachine constructor Initializes a new instance of the StateMachine class. protected StateMachine() See Also class StateMachine namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"StateMachine"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/StateMachine/#statemachine-constructor","text":"Initializes a new instance of the StateMachine class. protected StateMachine()","title":"StateMachine constructor"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine/StateMachine/#see-also","text":"class StateMachine namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State/State/","text":"StateMachine.State constructor Initializes a new instance of the State class. protected State() See Also class State namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"State"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State/State/#statemachinestate-constructor","text":"Initializes a new instance of the State class. protected State()","title":"StateMachine.State constructor"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State/State/#see-also","text":"class State namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.DeferEventsAttribute/DeferEventsAttribute/","text":"StateMachine.State.DeferEventsAttribute constructor Initializes a new instance of the DeferEventsAttribute class. public DeferEventsAttribute(params Type[] eventTypes) parameter description eventTypes Event types. See Also class DeferEventsAttribute namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"DeferEventsAttribute"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.DeferEventsAttribute/DeferEventsAttribute/#statemachinestatedefereventsattribute-constructor","text":"Initializes a new instance of the DeferEventsAttribute class. public DeferEventsAttribute(params Type[] eventTypes) parameter description eventTypes Event types.","title":"StateMachine.State.DeferEventsAttribute constructor"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.DeferEventsAttribute/DeferEventsAttribute/#see-also","text":"class DeferEventsAttribute namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.IgnoreEventsAttribute/IgnoreEventsAttribute/","text":"StateMachine.State.IgnoreEventsAttribute constructor Initializes a new instance of the IgnoreEventsAttribute class. public IgnoreEventsAttribute(params Type[] eventTypes) parameter description eventTypes Event types. See Also class IgnoreEventsAttribute namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"IgnoreEventsAttribute"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.IgnoreEventsAttribute/IgnoreEventsAttribute/#statemachinestateignoreeventsattribute-constructor","text":"Initializes a new instance of the IgnoreEventsAttribute class. public IgnoreEventsAttribute(params Type[] eventTypes) parameter description eventTypes Event types.","title":"StateMachine.State.IgnoreEventsAttribute constructor"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.IgnoreEventsAttribute/IgnoreEventsAttribute/#see-also","text":"class IgnoreEventsAttribute namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnEntryAttribute/OnEntryAttribute/","text":"StateMachine.State.OnEntryAttribute constructor Initializes a new instance of the OnEntryAttribute class. public OnEntryAttribute(string actionName) parameter description actionName The name of the action to execute. See Also class OnEntryAttribute namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnEntryAttribute"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnEntryAttribute/OnEntryAttribute/#statemachinestateonentryattribute-constructor","text":"Initializes a new instance of the OnEntryAttribute class. public OnEntryAttribute(string actionName) parameter description actionName The name of the action to execute.","title":"StateMachine.State.OnEntryAttribute constructor"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnEntryAttribute/OnEntryAttribute/#see-also","text":"class OnEntryAttribute namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnEventDoActionAttribute/OnEventDoActionAttribute/","text":"StateMachine.State.OnEventDoActionAttribute constructor Initializes a new instance of the OnEventDoActionAttribute class. public OnEventDoActionAttribute(Type eventType, string actionName) parameter description eventType The type of the dequeued event. actionName The name of the action to invoke. See Also class OnEventDoActionAttribute namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnEventDoActionAttribute"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnEventDoActionAttribute/OnEventDoActionAttribute/#statemachinestateoneventdoactionattribute-constructor","text":"Initializes a new instance of the OnEventDoActionAttribute class. public OnEventDoActionAttribute(Type eventType, string actionName) parameter description eventType The type of the dequeued event. actionName The name of the action to invoke.","title":"StateMachine.State.OnEventDoActionAttribute constructor"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnEventDoActionAttribute/OnEventDoActionAttribute/#see-also","text":"class OnEventDoActionAttribute namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnEventGotoStateAttribute/OnEventGotoStateAttribute/","text":"StateMachine.State.OnEventGotoStateAttribute constructor (1 of 2) Initializes a new instance of the OnEventGotoStateAttribute class. public OnEventGotoStateAttribute(Type eventType, Type stateType) parameter description eventType The type of the dequeued event. stateType The type of the state. See Also class OnEventGotoStateAttribute namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote StateMachine.State.OnEventGotoStateAttribute constructor (2 of 2) Initializes a new instance of the OnEventGotoStateAttribute class. public OnEventGotoStateAttribute(Type eventType, Type stateType, string actionName) parameter description eventType The type of the dequeued event. stateType The type of the state. actionName Name of action to perform on exit. See Also class OnEventGotoStateAttribute namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnEventGotoStateAttribute"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnEventGotoStateAttribute/OnEventGotoStateAttribute/#statemachinestateoneventgotostateattribute-constructor-1-of-2","text":"Initializes a new instance of the OnEventGotoStateAttribute class. public OnEventGotoStateAttribute(Type eventType, Type stateType) parameter description eventType The type of the dequeued event. stateType The type of the state.","title":"StateMachine.State.OnEventGotoStateAttribute constructor (1 of 2)"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnEventGotoStateAttribute/OnEventGotoStateAttribute/#see-also","text":"class OnEventGotoStateAttribute namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnEventGotoStateAttribute/OnEventGotoStateAttribute/#statemachinestateoneventgotostateattribute-constructor-2-of-2","text":"Initializes a new instance of the OnEventGotoStateAttribute class. public OnEventGotoStateAttribute(Type eventType, Type stateType, string actionName) parameter description eventType The type of the dequeued event. stateType The type of the state. actionName Name of action to perform on exit.","title":"StateMachine.State.OnEventGotoStateAttribute constructor (2 of 2)"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnEventGotoStateAttribute/OnEventGotoStateAttribute/#see-also_1","text":"class OnEventGotoStateAttribute namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnEventPushStateAttribute/OnEventPushStateAttribute/","text":"StateMachine.State.OnEventPushStateAttribute constructor Initializes a new instance of the OnEventPushStateAttribute class. public OnEventPushStateAttribute(Type eventType, Type stateType) parameter description eventType The type of the dequeued event. stateType The type of the state. See Also class OnEventPushStateAttribute namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnEventPushStateAttribute"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnEventPushStateAttribute/OnEventPushStateAttribute/#statemachinestateoneventpushstateattribute-constructor","text":"Initializes a new instance of the OnEventPushStateAttribute class. public OnEventPushStateAttribute(Type eventType, Type stateType) parameter description eventType The type of the dequeued event. stateType The type of the state.","title":"StateMachine.State.OnEventPushStateAttribute constructor"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnEventPushStateAttribute/OnEventPushStateAttribute/#see-also","text":"class OnEventPushStateAttribute namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnExitAttribute/OnExitAttribute/","text":"StateMachine.State.OnExitAttribute constructor Initializes a new instance of the OnExitAttribute class. public OnExitAttribute(string actionName) parameter description actionName The name of the action to execute. See Also class OnExitAttribute namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"OnExitAttribute"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnExitAttribute/OnExitAttribute/#statemachinestateonexitattribute-constructor","text":"Initializes a new instance of the OnExitAttribute class. public OnExitAttribute(string actionName) parameter description actionName The name of the action to execute.","title":"StateMachine.State.OnExitAttribute constructor"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.OnExitAttribute/OnExitAttribute/#see-also","text":"class OnExitAttribute namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.StartAttribute/StartAttribute/","text":"StateMachine.State.StartAttribute constructor The default constructor. public StartAttribute() See Also class StartAttribute namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"StartAttribute"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.StartAttribute/StartAttribute/#statemachinestatestartattribute-constructor","text":"The default constructor. public StartAttribute()","title":"StateMachine.State.StartAttribute constructor"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.State.StartAttribute/StartAttribute/#see-also","text":"class StartAttribute namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.StateGroup/StateGroup/","text":"StateMachine.StateGroup constructor The default constructor. protected StateGroup() See Also class StateGroup namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"StateGroup"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.StateGroup/StateGroup/#statemachinestategroup-constructor","text":"The default constructor. protected StateGroup()","title":"StateMachine.StateGroup constructor"},{"location":"ref/Microsoft.Coyote.Actors/StateMachine.StateGroup/StateGroup/#see-also","text":"class StateGroup namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/UnhandledEventException/CurrentStateName/","text":"UnhandledEventException.CurrentStateName field The name of the current state, if the actor that threw the exception is a StateMachine and a state exists, else null. public string CurrentStateName; See Also class UnhandledEventException namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"CurrentStateName"},{"location":"ref/Microsoft.Coyote.Actors/UnhandledEventException/CurrentStateName/#unhandledeventexceptioncurrentstatename-field","text":"The name of the current state, if the actor that threw the exception is a StateMachine and a state exists, else null. public string CurrentStateName;","title":"UnhandledEventException.CurrentStateName field"},{"location":"ref/Microsoft.Coyote.Actors/UnhandledEventException/CurrentStateName/#see-also","text":"class UnhandledEventException namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/UnhandledEventException/UnhandledEvent/","text":"UnhandledEventException.UnhandledEvent field The unhandled event. public Event UnhandledEvent; See Also class Event class UnhandledEventException namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"UnhandledEvent"},{"location":"ref/Microsoft.Coyote.Actors/UnhandledEventException/UnhandledEvent/#unhandledeventexceptionunhandledevent-field","text":"The unhandled event. public Event UnhandledEvent;","title":"UnhandledEventException.UnhandledEvent field"},{"location":"ref/Microsoft.Coyote.Actors/UnhandledEventException/UnhandledEvent/#see-also","text":"class Event class UnhandledEventException namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors/WildCardEvent/WildCardEvent/","text":"WildCardEvent constructor Initializes a new instance of the WildCardEvent class. public WildCardEvent() See Also class WildCardEvent namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"WildCardEvent"},{"location":"ref/Microsoft.Coyote.Actors/WildCardEvent/WildCardEvent/#wildcardevent-constructor","text":"Initializes a new instance of the WildCardEvent class. public WildCardEvent()","title":"WildCardEvent constructor"},{"location":"ref/Microsoft.Coyote.Actors/WildCardEvent/WildCardEvent/#see-also","text":"class WildCardEvent namespace Microsoft.Coyote.Actors assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedCounter/","text":"SharedCounter class A thread-safe counter that can be shared in-memory by actors. public class SharedCounter Public Members name description static Create (\u2026) Creates a new shared counter. virtual Add (\u2026) Adds a value to the counter atomically. virtual CompareExchange (\u2026) Sets the counter to a value atomically if it is equal to a given value. virtual Decrement () Decrements the shared counter. virtual Exchange (\u2026) Sets the counter to a value atomically. virtual GetValue () Gets the current value of the shared counter. virtual Increment () Increments the shared counter. Remarks See also Sharing Objects . See Also namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedCounter/#sharedcounter-class","text":"A thread-safe counter that can be shared in-memory by actors. public class SharedCounter","title":"SharedCounter class"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedCounter/#public-members","text":"name description static Create (\u2026) Creates a new shared counter. virtual Add (\u2026) Adds a value to the counter atomically. virtual CompareExchange (\u2026) Sets the counter to a value atomically if it is equal to a given value. virtual Decrement () Decrements the shared counter. virtual Exchange (\u2026) Sets the counter to a value atomically. virtual GetValue () Gets the current value of the shared counter. virtual Increment () Increments the shared counter.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedCounter/#remarks","text":"See also Sharing Objects .","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedCounter/#see-also","text":"namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedDictionary-2/","text":"SharedDictionary<TKey,TValue> class A thread-safe dictionary that can be shared in-memory by actors. public class SharedDictionary<TKey, TValue> parameter description TKey The type of the key. TValue The type of the value. Public Members name description virtual Count { get; } Gets the number of elements in the dictionary. virtual Item { get; set; } Gets or sets the value associated with the specified key. virtual TryAdd (\u2026) Adds a new key to the dictionary, if it doesn\u2019t already exist in the dictionary. virtual TryGetValue (\u2026) Attempts to get the value associated with the specified key. virtual TryRemove (\u2026) Removes the specified key from the dictionary. virtual TryUpdate (\u2026) Updates the value for an existing key in the dictionary, if that key has a specific value. See Also namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedDictionary-2/#shareddictionarytkeytvalue-class","text":"A thread-safe dictionary that can be shared in-memory by actors. public class SharedDictionary<TKey, TValue> parameter description TKey The type of the key. TValue The type of the value.","title":"SharedDictionary&lt;TKey,TValue&gt; class"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedDictionary-2/#public-members","text":"name description virtual Count { get; } Gets the number of elements in the dictionary. virtual Item { get; set; } Gets or sets the value associated with the specified key. virtual TryAdd (\u2026) Adds a new key to the dictionary, if it doesn\u2019t already exist in the dictionary. virtual TryGetValue (\u2026) Attempts to get the value associated with the specified key. virtual TryRemove (\u2026) Removes the specified key from the dictionary. virtual TryUpdate (\u2026) Updates the value for an existing key in the dictionary, if that key has a specific value.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedDictionary-2/#see-also","text":"namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedDictionary/","text":"SharedDictionary class A thread-safe dictionary that can be shared in-memory by actors. public static class SharedDictionary Public Members name description static Create<TKey,TValue> (\u2026) Creates a new shared dictionary. (2 methods) Remarks See also Sharing Objects . See Also namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedDictionary/#shareddictionary-class","text":"A thread-safe dictionary that can be shared in-memory by actors. public static class SharedDictionary","title":"SharedDictionary class"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedDictionary/#public-members","text":"name description static Create<TKey,TValue> (\u2026) Creates a new shared dictionary. (2 methods)","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedDictionary/#remarks","text":"See also Sharing Objects .","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedDictionary/#see-also","text":"namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedRegister-1/","text":"SharedRegister<T> class A thread-safe register that can be shared in-memory by actors. public class SharedRegister<T> where T : struct parameter description T The type of the value. Public Members name description virtual GetValue () Gets current value of the register. virtual SetValue (\u2026) Sets current value of the register. virtual Update (\u2026) Reads and updates the register. See Also namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedRegister-1/#sharedregistert-class","text":"A thread-safe register that can be shared in-memory by actors. public class SharedRegister<T> where T : struct parameter description T The type of the value.","title":"SharedRegister&lt;T&gt; class"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedRegister-1/#public-members","text":"name description virtual GetValue () Gets current value of the register. virtual SetValue (\u2026) Sets current value of the register. virtual Update (\u2026) Reads and updates the register.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedRegister-1/#see-also","text":"namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedRegister/","text":"SharedRegister class A thread-safe register that can be shared in-memory by actors. public static class SharedRegister Public Members name description static Create<T> (\u2026) Creates a new shared register. Remarks See also Sharing Objects . See Also namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedRegister/#sharedregister-class","text":"A thread-safe register that can be shared in-memory by actors. public static class SharedRegister","title":"SharedRegister class"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedRegister/#public-members","text":"name description static Create<T> (\u2026) Creates a new shared register.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedRegister/#remarks","text":"See also Sharing Objects .","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedRegister/#see-also","text":"namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedCounter/Add/","text":"SharedCounter.Add method Adds a value to the counter atomically. public virtual int Add(int value) See Also class SharedCounter namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"Add"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedCounter/Add/#sharedcounteradd-method","text":"Adds a value to the counter atomically. public virtual int Add(int value)","title":"SharedCounter.Add method"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedCounter/Add/#see-also","text":"class SharedCounter namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedCounter/CompareExchange/","text":"SharedCounter.CompareExchange method Sets the counter to a value atomically if it is equal to a given value. public virtual int CompareExchange(int value, int comparand) See Also class SharedCounter namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"CompareExchange"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedCounter/CompareExchange/#sharedcountercompareexchange-method","text":"Sets the counter to a value atomically if it is equal to a given value. public virtual int CompareExchange(int value, int comparand)","title":"SharedCounter.CompareExchange method"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedCounter/CompareExchange/#see-also","text":"class SharedCounter namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedCounter/Create/","text":"SharedCounter.Create method Creates a new shared counter. public static SharedCounter Create(IActorRuntime runtime, int value = 0) parameter description runtime The actor runtime. value The initial value. See Also interface IActorRuntime class SharedCounter namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"Create"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedCounter/Create/#sharedcountercreate-method","text":"Creates a new shared counter. public static SharedCounter Create(IActorRuntime runtime, int value = 0) parameter description runtime The actor runtime. value The initial value.","title":"SharedCounter.Create method"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedCounter/Create/#see-also","text":"interface IActorRuntime class SharedCounter namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedCounter/Decrement/","text":"SharedCounter.Decrement method Decrements the shared counter. public virtual void Decrement() See Also class SharedCounter namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"Decrement"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedCounter/Decrement/#sharedcounterdecrement-method","text":"Decrements the shared counter. public virtual void Decrement()","title":"SharedCounter.Decrement method"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedCounter/Decrement/#see-also","text":"class SharedCounter namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedCounter/Exchange/","text":"SharedCounter.Exchange method Sets the counter to a value atomically. public virtual int Exchange(int value) See Also class SharedCounter namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"Exchange"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedCounter/Exchange/#sharedcounterexchange-method","text":"Sets the counter to a value atomically. public virtual int Exchange(int value)","title":"SharedCounter.Exchange method"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedCounter/Exchange/#see-also","text":"class SharedCounter namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedCounter/GetValue/","text":"SharedCounter.GetValue method Gets the current value of the shared counter. public virtual int GetValue() See Also class SharedCounter namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"GetValue"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedCounter/GetValue/#sharedcountergetvalue-method","text":"Gets the current value of the shared counter. public virtual int GetValue()","title":"SharedCounter.GetValue method"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedCounter/GetValue/#see-also","text":"class SharedCounter namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedCounter/Increment/","text":"SharedCounter.Increment method Increments the shared counter. public virtual void Increment() See Also class SharedCounter namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"Increment"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedCounter/Increment/#sharedcounterincrement-method","text":"Increments the shared counter. public virtual void Increment()","title":"SharedCounter.Increment method"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedCounter/Increment/#see-also","text":"class SharedCounter namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedDictionary/Create/","text":"SharedDictionary.Create<TKey,TValue> method (1 of 2) Creates a new shared dictionary. public static SharedDictionary<TKey, TValue> Create<TKey, TValue>(IActorRuntime runtime) parameter description TKey The type of the key. TValue The type of the value. runtime The actor runtime. See Also class SharedDictionary<TKey,TValue> interface IActorRuntime class SharedDictionary namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote SharedDictionary.Create<TKey,TValue> method (2 of 2) Creates a new shared dictionary. public static SharedDictionary<TKey, TValue> Create<TKey, TValue>(IEqualityComparer<TKey> comparer, IActorRuntime runtime) parameter description TKey The type of the key. TValue The type of the value. comparer The key comparer. runtime The actor runtime. See Also class SharedDictionary<TKey,TValue> interface IActorRuntime class SharedDictionary namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"Create"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedDictionary/Create/#shareddictionarycreatetkeytvalue-method-1-of-2","text":"Creates a new shared dictionary. public static SharedDictionary<TKey, TValue> Create<TKey, TValue>(IActorRuntime runtime) parameter description TKey The type of the key. TValue The type of the value. runtime The actor runtime.","title":"SharedDictionary.Create&lt;TKey,TValue&gt; method (1 of 2)"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedDictionary/Create/#see-also","text":"class SharedDictionary<TKey,TValue> interface IActorRuntime class SharedDictionary namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedDictionary/Create/#shareddictionarycreatetkeytvalue-method-2-of-2","text":"Creates a new shared dictionary. public static SharedDictionary<TKey, TValue> Create<TKey, TValue>(IEqualityComparer<TKey> comparer, IActorRuntime runtime) parameter description TKey The type of the key. TValue The type of the value. comparer The key comparer. runtime The actor runtime.","title":"SharedDictionary.Create&lt;TKey,TValue&gt; method (2 of 2)"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedDictionary/Create/#see-also_1","text":"class SharedDictionary<TKey,TValue> interface IActorRuntime class SharedDictionary namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedDictionary-2/Count/","text":"SharedDictionary<TKey,TValue>.Count property Gets the number of elements in the dictionary. public virtual int Count { get; } See Also class SharedDictionary<TKey,TValue> namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"Count"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedDictionary-2/Count/#shareddictionarytkeytvaluecount-property","text":"Gets the number of elements in the dictionary. public virtual int Count { get; }","title":"SharedDictionary&lt;TKey,TValue&gt;.Count property"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedDictionary-2/Count/#see-also","text":"class SharedDictionary<TKey,TValue> namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedDictionary-2/Item/","text":"SharedDictionary<TKey,TValue> indexer Gets or sets the value associated with the specified key. public virtual TValue this[TKey key] { get; set; } See Also class SharedDictionary<TKey,TValue> namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"Item"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedDictionary-2/Item/#shareddictionarytkeytvalue-indexer","text":"Gets or sets the value associated with the specified key. public virtual TValue this[TKey key] { get; set; }","title":"SharedDictionary&lt;TKey,TValue&gt; indexer"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedDictionary-2/Item/#see-also","text":"class SharedDictionary<TKey,TValue> namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedDictionary-2/TryAdd/","text":"SharedDictionary<TKey,TValue>.TryAdd method Adds a new key to the dictionary, if it doesn\u2019t already exist in the dictionary. public virtual bool TryAdd(TKey key, TValue value) See Also class SharedDictionary<TKey,TValue> namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"TryAdd"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedDictionary-2/TryAdd/#shareddictionarytkeytvaluetryadd-method","text":"Adds a new key to the dictionary, if it doesn\u2019t already exist in the dictionary. public virtual bool TryAdd(TKey key, TValue value)","title":"SharedDictionary&lt;TKey,TValue&gt;.TryAdd method"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedDictionary-2/TryAdd/#see-also","text":"class SharedDictionary<TKey,TValue> namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedDictionary-2/TryGetValue/","text":"SharedDictionary<TKey,TValue>.TryGetValue method Attempts to get the value associated with the specified key. public virtual bool TryGetValue(TKey key, out TValue value) See Also class SharedDictionary<TKey,TValue> namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"TryGetValue"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedDictionary-2/TryGetValue/#shareddictionarytkeytvaluetrygetvalue-method","text":"Attempts to get the value associated with the specified key. public virtual bool TryGetValue(TKey key, out TValue value)","title":"SharedDictionary&lt;TKey,TValue&gt;.TryGetValue method"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedDictionary-2/TryGetValue/#see-also","text":"class SharedDictionary<TKey,TValue> namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedDictionary-2/TryRemove/","text":"SharedDictionary<TKey,TValue>.TryRemove method Removes the specified key from the dictionary. public virtual bool TryRemove(TKey key, out TValue value) See Also class SharedDictionary<TKey,TValue> namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"TryRemove"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedDictionary-2/TryRemove/#shareddictionarytkeytvaluetryremove-method","text":"Removes the specified key from the dictionary. public virtual bool TryRemove(TKey key, out TValue value)","title":"SharedDictionary&lt;TKey,TValue&gt;.TryRemove method"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedDictionary-2/TryRemove/#see-also","text":"class SharedDictionary<TKey,TValue> namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedDictionary-2/TryUpdate/","text":"SharedDictionary<TKey,TValue>.TryUpdate method Updates the value for an existing key in the dictionary, if that key has a specific value. public virtual bool TryUpdate(TKey key, TValue newValue, TValue comparisonValue) See Also class SharedDictionary<TKey,TValue> namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"TryUpdate"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedDictionary-2/TryUpdate/#shareddictionarytkeytvaluetryupdate-method","text":"Updates the value for an existing key in the dictionary, if that key has a specific value. public virtual bool TryUpdate(TKey key, TValue newValue, TValue comparisonValue)","title":"SharedDictionary&lt;TKey,TValue&gt;.TryUpdate method"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedDictionary-2/TryUpdate/#see-also","text":"class SharedDictionary<TKey,TValue> namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedRegister/Create/","text":"SharedRegister.Create<T> method Creates a new shared register. public static SharedRegister<T> Create<T>(IActorRuntime runtime, T value = default(T)) where T : struct parameter description T The type of the value. runtime The actor runtime. value The initial value. See Also class SharedRegister<T> interface IActorRuntime class SharedRegister namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"Create"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedRegister/Create/#sharedregistercreatet-method","text":"Creates a new shared register. public static SharedRegister<T> Create<T>(IActorRuntime runtime, T value = default(T)) where T : struct parameter description T The type of the value. runtime The actor runtime. value The initial value.","title":"SharedRegister.Create&lt;T&gt; method"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedRegister/Create/#see-also","text":"class SharedRegister<T> interface IActorRuntime class SharedRegister namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedRegister-1/GetValue/","text":"SharedRegister<T>.GetValue method Gets current value of the register. public virtual T GetValue() See Also class SharedRegister<T> namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"GetValue"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedRegister-1/GetValue/#sharedregistertgetvalue-method","text":"Gets current value of the register. public virtual T GetValue()","title":"SharedRegister&lt;T&gt;.GetValue method"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedRegister-1/GetValue/#see-also","text":"class SharedRegister<T> namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedRegister-1/SetValue/","text":"SharedRegister<T>.SetValue method Sets current value of the register. public virtual void SetValue(T value) See Also class SharedRegister<T> namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"SetValue"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedRegister-1/SetValue/#sharedregistertsetvalue-method","text":"Sets current value of the register. public virtual void SetValue(T value)","title":"SharedRegister&lt;T&gt;.SetValue method"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedRegister-1/SetValue/#see-also","text":"class SharedRegister<T> namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedRegister-1/Update/","text":"SharedRegister<T>.Update method Reads and updates the register. public virtual T Update(Func<T, T> func) See Also class SharedRegister<T> namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"Update"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedRegister-1/Update/#sharedregistertupdate-method","text":"Reads and updates the register. public virtual T Update(Func<T, T> func)","title":"SharedRegister&lt;T&gt;.Update method"},{"location":"ref/Microsoft.Coyote.Actors.SharedObjects/SharedRegister-1/Update/#see-also","text":"class SharedRegister<T> namespace Microsoft.Coyote.Actors.SharedObjects assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerElapsedEvent/","text":"TimerElapsedEvent class Defines a timer elapsed event that is sent from a timer to the actor that owns the timer. public class TimerElapsedEvent : Event Public Members name description TimerElapsedEvent () Initializes a new instance of the TimerElapsedEvent class. Info { get; } Stores information about the timer. Remarks See Using timers in actors for more information. See Also class Event namespace Microsoft.Coyote.Actors.Timers assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerElapsedEvent/#timerelapsedevent-class","text":"Defines a timer elapsed event that is sent from a timer to the actor that owns the timer. public class TimerElapsedEvent : Event","title":"TimerElapsedEvent class"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerElapsedEvent/#public-members","text":"name description TimerElapsedEvent () Initializes a new instance of the TimerElapsedEvent class. Info { get; } Stores information about the timer.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerElapsedEvent/#remarks","text":"See Using timers in actors for more information.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerElapsedEvent/#see-also","text":"class Event namespace Microsoft.Coyote.Actors.Timers assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerInfo/","text":"TimerInfo class Stores information about a timer that can send timeout events to its owner actor. public class TimerInfo : IEquatable<TimerInfo> Public Members name description readonly CustomEvent The optional custom event to raise instead of the default TimerElapsedEvent. readonly DueTime The amount of time to wait before sending the first timeout event. readonly OwnerId The id of the actor that owns the timer. readonly Period The time interval between timeout events. override Equals (\u2026) Determines whether the specified object is equal to the current object. Equals (\u2026) Indicates whether the specified TimerInfo is equal to the current TimerInfo . override GetHashCode () Returns the hash code for this instance. override ToString () Returns a string that represents the current instance. Remarks See Using timers in actors for more information. See Also namespace Microsoft.Coyote.Actors.Timers assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerInfo/#timerinfo-class","text":"Stores information about a timer that can send timeout events to its owner actor. public class TimerInfo : IEquatable<TimerInfo>","title":"TimerInfo class"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerInfo/#public-members","text":"name description readonly CustomEvent The optional custom event to raise instead of the default TimerElapsedEvent. readonly DueTime The amount of time to wait before sending the first timeout event. readonly OwnerId The id of the actor that owns the timer. readonly Period The time interval between timeout events. override Equals (\u2026) Determines whether the specified object is equal to the current object. Equals (\u2026) Indicates whether the specified TimerInfo is equal to the current TimerInfo . override GetHashCode () Returns the hash code for this instance. override ToString () Returns a string that represents the current instance.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerInfo/#remarks","text":"See Using timers in actors for more information.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerInfo/#see-also","text":"namespace Microsoft.Coyote.Actors.Timers assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerElapsedEvent/Info/","text":"TimerElapsedEvent.Info property Stores information about the timer. public TimerInfo Info { get; } See Also class TimerInfo class TimerElapsedEvent namespace Microsoft.Coyote.Actors.Timers assembly Microsoft.Coyote","title":"Info"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerElapsedEvent/Info/#timerelapsedeventinfo-property","text":"Stores information about the timer. public TimerInfo Info { get; }","title":"TimerElapsedEvent.Info property"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerElapsedEvent/Info/#see-also","text":"class TimerInfo class TimerElapsedEvent namespace Microsoft.Coyote.Actors.Timers assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerElapsedEvent/TimerElapsedEvent/","text":"TimerElapsedEvent constructor Initializes a new instance of the TimerElapsedEvent class. public TimerElapsedEvent() See Also class TimerElapsedEvent namespace Microsoft.Coyote.Actors.Timers assembly Microsoft.Coyote","title":"TimerElapsedEvent"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerElapsedEvent/TimerElapsedEvent/#timerelapsedevent-constructor","text":"Initializes a new instance of the TimerElapsedEvent class. public TimerElapsedEvent()","title":"TimerElapsedEvent constructor"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerElapsedEvent/TimerElapsedEvent/#see-also","text":"class TimerElapsedEvent namespace Microsoft.Coyote.Actors.Timers assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerInfo/CustomEvent/","text":"TimerInfo.CustomEvent field The optional custom event to raise instead of the default TimerElapsedEvent. public readonly TimerElapsedEvent CustomEvent; See Also class TimerElapsedEvent class TimerInfo namespace Microsoft.Coyote.Actors.Timers assembly Microsoft.Coyote","title":"CustomEvent"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerInfo/CustomEvent/#timerinfocustomevent-field","text":"The optional custom event to raise instead of the default TimerElapsedEvent. public readonly TimerElapsedEvent CustomEvent;","title":"TimerInfo.CustomEvent field"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerInfo/CustomEvent/#see-also","text":"class TimerElapsedEvent class TimerInfo namespace Microsoft.Coyote.Actors.Timers assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerInfo/DueTime/","text":"TimerInfo.DueTime field The amount of time to wait before sending the first timeout event. public readonly TimeSpan DueTime; See Also class TimerInfo namespace Microsoft.Coyote.Actors.Timers assembly Microsoft.Coyote","title":"DueTime"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerInfo/DueTime/#timerinfoduetime-field","text":"The amount of time to wait before sending the first timeout event. public readonly TimeSpan DueTime;","title":"TimerInfo.DueTime field"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerInfo/DueTime/#see-also","text":"class TimerInfo namespace Microsoft.Coyote.Actors.Timers assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerInfo/Equals/","text":"TimerInfo.Equals method (1 of 2) Determines whether the specified object is equal to the current object. public override bool Equals(object obj) See Also class TimerInfo namespace Microsoft.Coyote.Actors.Timers assembly Microsoft.Coyote TimerInfo.Equals method (2 of 2) Indicates whether the specified TimerInfo is equal to the current TimerInfo . public bool Equals(TimerInfo other) See Also class TimerInfo namespace Microsoft.Coyote.Actors.Timers assembly Microsoft.Coyote","title":"Equals"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerInfo/Equals/#timerinfoequals-method-1-of-2","text":"Determines whether the specified object is equal to the current object. public override bool Equals(object obj)","title":"TimerInfo.Equals method (1 of 2)"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerInfo/Equals/#see-also","text":"class TimerInfo namespace Microsoft.Coyote.Actors.Timers assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerInfo/Equals/#timerinfoequals-method-2-of-2","text":"Indicates whether the specified TimerInfo is equal to the current TimerInfo . public bool Equals(TimerInfo other)","title":"TimerInfo.Equals method (2 of 2)"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerInfo/Equals/#see-also_1","text":"class TimerInfo namespace Microsoft.Coyote.Actors.Timers assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerInfo/GetHashCode/","text":"TimerInfo.GetHashCode method Returns the hash code for this instance. public override int GetHashCode() See Also class TimerInfo namespace Microsoft.Coyote.Actors.Timers assembly Microsoft.Coyote","title":"GetHashCode"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerInfo/GetHashCode/#timerinfogethashcode-method","text":"Returns the hash code for this instance. public override int GetHashCode()","title":"TimerInfo.GetHashCode method"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerInfo/GetHashCode/#see-also","text":"class TimerInfo namespace Microsoft.Coyote.Actors.Timers assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerInfo/OwnerId/","text":"TimerInfo.OwnerId field The id of the actor that owns the timer. public readonly ActorId OwnerId; See Also class ActorId class TimerInfo namespace Microsoft.Coyote.Actors.Timers assembly Microsoft.Coyote","title":"OwnerId"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerInfo/OwnerId/#timerinfoownerid-field","text":"The id of the actor that owns the timer. public readonly ActorId OwnerId;","title":"TimerInfo.OwnerId field"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerInfo/OwnerId/#see-also","text":"class ActorId class TimerInfo namespace Microsoft.Coyote.Actors.Timers assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerInfo/Period/","text":"TimerInfo.Period field The time interval between timeout events. public readonly TimeSpan Period; See Also class TimerInfo namespace Microsoft.Coyote.Actors.Timers assembly Microsoft.Coyote","title":"Period"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerInfo/Period/#timerinfoperiod-field","text":"The time interval between timeout events. public readonly TimeSpan Period;","title":"TimerInfo.Period field"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerInfo/Period/#see-also","text":"class TimerInfo namespace Microsoft.Coyote.Actors.Timers assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerInfo/ToString/","text":"TimerInfo.ToString method Returns a string that represents the current instance. public override string ToString() See Also class TimerInfo namespace Microsoft.Coyote.Actors.Timers assembly Microsoft.Coyote","title":"ToString"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerInfo/ToString/#timerinfotostring-method","text":"Returns a string that represents the current instance. public override string ToString()","title":"TimerInfo.ToString method"},{"location":"ref/Microsoft.Coyote.Actors.Timers/TimerInfo/ToString/#see-also","text":"class TimerInfo namespace Microsoft.Coyote.Actors.Timers assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/ConsoleLogger/","text":"ConsoleLogger class Logger that writes text to the console. public sealed class ConsoleLogger : TextWriter, ILogger Public Members name description ConsoleLogger () Initializes a new instance of the ConsoleLogger class. override Encoding { get; } When overridden in a derived class, returns the character encoding in which the output is written. LogLevel { get; set; } The level of detail to report. TextWriter { get; } This property provides a TextWriter that implements ILogger which is handy if you have existing code that requires a TextWriter. override Write (\u2026) Writes an informational string to the log. Write (\u2026) Writes a string to the log. (2 methods) override WriteLine (\u2026) Writes an informational string to the log. (2 methods) WriteLine (\u2026) Writes a string followed by a line terminator to the text string or stream. (2 methods) Remarks See Logging for more information. See Also interface ILogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.IO/ConsoleLogger/#consolelogger-class","text":"Logger that writes text to the console. public sealed class ConsoleLogger : TextWriter, ILogger","title":"ConsoleLogger class"},{"location":"ref/Microsoft.Coyote.IO/ConsoleLogger/#public-members","text":"name description ConsoleLogger () Initializes a new instance of the ConsoleLogger class. override Encoding { get; } When overridden in a derived class, returns the character encoding in which the output is written. LogLevel { get; set; } The level of detail to report. TextWriter { get; } This property provides a TextWriter that implements ILogger which is handy if you have existing code that requires a TextWriter. override Write (\u2026) Writes an informational string to the log. Write (\u2026) Writes a string to the log. (2 methods) override WriteLine (\u2026) Writes an informational string to the log. (2 methods) WriteLine (\u2026) Writes a string followed by a line terminator to the text string or stream. (2 methods)","title":"Public Members"},{"location":"ref/Microsoft.Coyote.IO/ConsoleLogger/#remarks","text":"See Logging for more information.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.IO/ConsoleLogger/#see-also","text":"interface ILogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/ILogger/","text":"ILogger interface A logger is used to capture messages, warnings and errors. public interface ILogger : IDisposable Members name description TextWriter { get; } This property provides a TextWriter that implements ILogger which is handy if you have existing code that requires a TextWriter. Write (\u2026) Writes an informational string to the log. (4 methods) WriteLine (\u2026) Writes an informational string to the log. (4 methods) See Also namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.IO/ILogger/#ilogger-interface","text":"A logger is used to capture messages, warnings and errors. public interface ILogger : IDisposable","title":"ILogger interface"},{"location":"ref/Microsoft.Coyote.IO/ILogger/#members","text":"name description TextWriter { get; } This property provides a TextWriter that implements ILogger which is handy if you have existing code that requires a TextWriter. Write (\u2026) Writes an informational string to the log. (4 methods) WriteLine (\u2026) Writes an informational string to the log. (4 methods)","title":"Members"},{"location":"ref/Microsoft.Coyote.IO/ILogger/#see-also","text":"namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/InMemoryLogger/","text":"InMemoryLogger class Thread safe logger that writes text to an in-memory buffer. The buffered text can be extracted using the ToString() method. public sealed class InMemoryLogger : TextWriter, ILogger Public Members name description InMemoryLogger () Initializes a new instance of the InMemoryLogger class. override Encoding { get; } When overridden in a derived class, returns the character encoding in which the output is written. TextWriter { get; } This property provides a TextWriter that implements ILogger which is handy if you have existing code that requires a TextWriter. override ToString () Returns the logged text as a string. override Write (\u2026) Writes an informational string to the log. Write (\u2026) Writes a string to the log. (2 methods) override WriteLine (\u2026) Writes an informational string to the log. WriteLine (\u2026) Writes a string followed by a line terminator to the text string or stream. (2 methods) Remarks See Logging for more information. See Also interface ILogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.IO/InMemoryLogger/#inmemorylogger-class","text":"Thread safe logger that writes text to an in-memory buffer. The buffered text can be extracted using the ToString() method. public sealed class InMemoryLogger : TextWriter, ILogger","title":"InMemoryLogger class"},{"location":"ref/Microsoft.Coyote.IO/InMemoryLogger/#public-members","text":"name description InMemoryLogger () Initializes a new instance of the InMemoryLogger class. override Encoding { get; } When overridden in a derived class, returns the character encoding in which the output is written. TextWriter { get; } This property provides a TextWriter that implements ILogger which is handy if you have existing code that requires a TextWriter. override ToString () Returns the logged text as a string. override Write (\u2026) Writes an informational string to the log. Write (\u2026) Writes a string to the log. (2 methods) override WriteLine (\u2026) Writes an informational string to the log. WriteLine (\u2026) Writes a string followed by a line terminator to the text string or stream. (2 methods)","title":"Public Members"},{"location":"ref/Microsoft.Coyote.IO/InMemoryLogger/#remarks","text":"See Logging for more information.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.IO/InMemoryLogger/#see-also","text":"interface ILogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/LogSeverity/","text":"LogSeverity enumeration Flag indicating the type of logging information being provided to the ILogger . public enum LogSeverity Values name value description Informational 0 General information about what is happening in the program. Warning 1 Warnings that something unusual is found and is being handled. Error 2 Error is something unexpected that usually means program cannot proceed normally. Important 3 Output that is not an error or warning, but is important. See Also namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"LogSeverity"},{"location":"ref/Microsoft.Coyote.IO/LogSeverity/#logseverity-enumeration","text":"Flag indicating the type of logging information being provided to the ILogger . public enum LogSeverity","title":"LogSeverity enumeration"},{"location":"ref/Microsoft.Coyote.IO/LogSeverity/#values","text":"name value description Informational 0 General information about what is happening in the program. Warning 1 Warnings that something unusual is found and is being handled. Error 2 Error is something unexpected that usually means program cannot proceed normally. Important 3 Output that is not an error or warning, but is important.","title":"Values"},{"location":"ref/Microsoft.Coyote.IO/LogSeverity/#see-also","text":"namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/TextWriterLogger/","text":"TextWriterLogger class Bridges custom user provided TextWriter logger so it can be passed into Coyote via the ILogger interface. public class TextWriterLogger : TextWriter, ILogger Public Members name description TextWriterLogger (\u2026) Initializes a new instance of the TextWriterLogger class. override Encoding { get; } TextWriter { get; } This property provides a TextWriter that implements ILogger which is handy if you have existing code that requires a TextWriter. override Write (\u2026) Writes an informational string to the log. (2 methods) Write (\u2026) Writes a string to the log. (2 methods) override WriteLine (\u2026) Writes an informational string to the log. (2 methods) WriteLine (\u2026) Writes a string followed by a line terminator to the text string or stream. (2 methods) See Also interface ILogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.IO/TextWriterLogger/#textwriterlogger-class","text":"Bridges custom user provided TextWriter logger so it can be passed into Coyote via the ILogger interface. public class TextWriterLogger : TextWriter, ILogger","title":"TextWriterLogger class"},{"location":"ref/Microsoft.Coyote.IO/TextWriterLogger/#public-members","text":"name description TextWriterLogger (\u2026) Initializes a new instance of the TextWriterLogger class. override Encoding { get; } TextWriter { get; } This property provides a TextWriter that implements ILogger which is handy if you have existing code that requires a TextWriter. override Write (\u2026) Writes an informational string to the log. (2 methods) Write (\u2026) Writes a string to the log. (2 methods) override WriteLine (\u2026) Writes an informational string to the log. (2 methods) WriteLine (\u2026) Writes a string followed by a line terminator to the text string or stream. (2 methods)","title":"Public Members"},{"location":"ref/Microsoft.Coyote.IO/TextWriterLogger/#see-also","text":"interface ILogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/ConsoleLogger/ConsoleLogger/","text":"ConsoleLogger constructor Initializes a new instance of the ConsoleLogger class. public ConsoleLogger() See Also class ConsoleLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"ConsoleLogger"},{"location":"ref/Microsoft.Coyote.IO/ConsoleLogger/ConsoleLogger/#consolelogger-constructor","text":"Initializes a new instance of the ConsoleLogger class. public ConsoleLogger()","title":"ConsoleLogger constructor"},{"location":"ref/Microsoft.Coyote.IO/ConsoleLogger/ConsoleLogger/#see-also","text":"class ConsoleLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/ConsoleLogger/Encoding/","text":"ConsoleLogger.Encoding property When overridden in a derived class, returns the character encoding in which the output is written. public override Encoding Encoding { get; } See Also class ConsoleLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"Encoding"},{"location":"ref/Microsoft.Coyote.IO/ConsoleLogger/Encoding/#consoleloggerencoding-property","text":"When overridden in a derived class, returns the character encoding in which the output is written. public override Encoding Encoding { get; }","title":"ConsoleLogger.Encoding property"},{"location":"ref/Microsoft.Coyote.IO/ConsoleLogger/Encoding/#see-also","text":"class ConsoleLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/ConsoleLogger/LogLevel/","text":"ConsoleLogger.LogLevel property The level of detail to report. public LogSeverity LogLevel { get; set; } See Also enum LogSeverity class ConsoleLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"LogLevel"},{"location":"ref/Microsoft.Coyote.IO/ConsoleLogger/LogLevel/#consoleloggerloglevel-property","text":"The level of detail to report. public LogSeverity LogLevel { get; set; }","title":"ConsoleLogger.LogLevel property"},{"location":"ref/Microsoft.Coyote.IO/ConsoleLogger/LogLevel/#see-also","text":"enum LogSeverity class ConsoleLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/ConsoleLogger/TextWriter/","text":"ConsoleLogger.TextWriter property This property provides a TextWriter that implements ILogger which is handy if you have existing code that requires a TextWriter. public TextWriter TextWriter { get; } See Also class ConsoleLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"TextWriter"},{"location":"ref/Microsoft.Coyote.IO/ConsoleLogger/TextWriter/#consoleloggertextwriter-property","text":"This property provides a TextWriter that implements ILogger which is handy if you have existing code that requires a TextWriter. public TextWriter TextWriter { get; }","title":"ConsoleLogger.TextWriter property"},{"location":"ref/Microsoft.Coyote.IO/ConsoleLogger/TextWriter/#see-also","text":"class ConsoleLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/ConsoleLogger/Write/","text":"ConsoleLogger.Write method (1 of 3) Writes an informational string to the log. public override void Write(string value) parameter description value The string to write. See Also class ConsoleLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote ConsoleLogger.Write method (2 of 3) Writes a string to the log. public void Write(LogSeverity severity, string value) parameter description severity The severity of the issue being logged. value The string to write. See Also enum LogSeverity class ConsoleLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote ConsoleLogger.Write method (3 of 3) Writes a string to the log. public void Write(LogSeverity severity, string format, params object[] args) parameter description severity The severity of the issue being logged. format The string format to write. args The arguments needed to format the string. See Also enum LogSeverity class ConsoleLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"Write"},{"location":"ref/Microsoft.Coyote.IO/ConsoleLogger/Write/#consoleloggerwrite-method-1-of-3","text":"Writes an informational string to the log. public override void Write(string value) parameter description value The string to write.","title":"ConsoleLogger.Write method (1 of 3)"},{"location":"ref/Microsoft.Coyote.IO/ConsoleLogger/Write/#see-also","text":"class ConsoleLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/ConsoleLogger/Write/#consoleloggerwrite-method-2-of-3","text":"Writes a string to the log. public void Write(LogSeverity severity, string value) parameter description severity The severity of the issue being logged. value The string to write.","title":"ConsoleLogger.Write method (2 of 3)"},{"location":"ref/Microsoft.Coyote.IO/ConsoleLogger/Write/#see-also_1","text":"enum LogSeverity class ConsoleLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/ConsoleLogger/Write/#consoleloggerwrite-method-3-of-3","text":"Writes a string to the log. public void Write(LogSeverity severity, string format, params object[] args) parameter description severity The severity of the issue being logged. format The string format to write. args The arguments needed to format the string.","title":"ConsoleLogger.Write method (3 of 3)"},{"location":"ref/Microsoft.Coyote.IO/ConsoleLogger/Write/#see-also_2","text":"enum LogSeverity class ConsoleLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/ConsoleLogger/WriteLine/","text":"ConsoleLogger.WriteLine method (1 of 4) Writes an informational string to the log. public override void WriteLine(string value) parameter description value The string to write. See Also class ConsoleLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote ConsoleLogger.WriteLine method (2 of 4) Writes a string followed by a line terminator to the text string or stream. public void WriteLine(LogSeverity severity, string value) parameter description severity The severity of the issue being logged. value The string to write. See Also enum LogSeverity class ConsoleLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote ConsoleLogger.WriteLine method (3 of 4) Writes an informational string to the log. public override void WriteLine(string format, params object[] args) parameter description format The string format to write. args The arguments needed to format the string. See Also class ConsoleLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote ConsoleLogger.WriteLine method (4 of 4) Writes a string followed by a line terminator to the text string or stream. public void WriteLine(LogSeverity severity, string format, params object[] args) parameter description severity The severity of the issue being logged. format The string format to write. args The arguments needed to format the string. See Also enum LogSeverity class ConsoleLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"WriteLine"},{"location":"ref/Microsoft.Coyote.IO/ConsoleLogger/WriteLine/#consoleloggerwriteline-method-1-of-4","text":"Writes an informational string to the log. public override void WriteLine(string value) parameter description value The string to write.","title":"ConsoleLogger.WriteLine method (1 of 4)"},{"location":"ref/Microsoft.Coyote.IO/ConsoleLogger/WriteLine/#see-also","text":"class ConsoleLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/ConsoleLogger/WriteLine/#consoleloggerwriteline-method-2-of-4","text":"Writes a string followed by a line terminator to the text string or stream. public void WriteLine(LogSeverity severity, string value) parameter description severity The severity of the issue being logged. value The string to write.","title":"ConsoleLogger.WriteLine method (2 of 4)"},{"location":"ref/Microsoft.Coyote.IO/ConsoleLogger/WriteLine/#see-also_1","text":"enum LogSeverity class ConsoleLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/ConsoleLogger/WriteLine/#consoleloggerwriteline-method-3-of-4","text":"Writes an informational string to the log. public override void WriteLine(string format, params object[] args) parameter description format The string format to write. args The arguments needed to format the string.","title":"ConsoleLogger.WriteLine method (3 of 4)"},{"location":"ref/Microsoft.Coyote.IO/ConsoleLogger/WriteLine/#see-also_2","text":"class ConsoleLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/ConsoleLogger/WriteLine/#consoleloggerwriteline-method-4-of-4","text":"Writes a string followed by a line terminator to the text string or stream. public void WriteLine(LogSeverity severity, string format, params object[] args) parameter description severity The severity of the issue being logged. format The string format to write. args The arguments needed to format the string.","title":"ConsoleLogger.WriteLine method (4 of 4)"},{"location":"ref/Microsoft.Coyote.IO/ConsoleLogger/WriteLine/#see-also_3","text":"enum LogSeverity class ConsoleLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/ILogger/TextWriter/","text":"ILogger.TextWriter property This property provides a TextWriter that implements ILogger which is handy if you have existing code that requires a TextWriter. public TextWriter TextWriter { get; } See Also interface ILogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"TextWriter"},{"location":"ref/Microsoft.Coyote.IO/ILogger/TextWriter/#iloggertextwriter-property","text":"This property provides a TextWriter that implements ILogger which is handy if you have existing code that requires a TextWriter. public TextWriter TextWriter { get; }","title":"ILogger.TextWriter property"},{"location":"ref/Microsoft.Coyote.IO/ILogger/TextWriter/#see-also","text":"interface ILogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/ILogger/Write/","text":"ILogger.Write method (1 of 4) Writes an informational string to the log. public void Write(string value) parameter description value The string to write. See Also interface ILogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote ILogger.Write method (2 of 4) Writes a string to the log. public void Write(LogSeverity severity, string value) parameter description severity The severity of the issue being logged. value The string to write. See Also enum LogSeverity interface ILogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote ILogger.Write method (3 of 4) Writes an informational string to the log. public void Write(string format, params object[] args) parameter description format The string format to write. args The arguments needed to format the string. See Also interface ILogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote ILogger.Write method (4 of 4) Writes a string to the log. public void Write(LogSeverity severity, string format, params object[] args) parameter description severity The severity of the issue being logged. format The string format to write. args The arguments needed to format the string. See Also enum LogSeverity interface ILogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"Write"},{"location":"ref/Microsoft.Coyote.IO/ILogger/Write/#iloggerwrite-method-1-of-4","text":"Writes an informational string to the log. public void Write(string value) parameter description value The string to write.","title":"ILogger.Write method (1 of 4)"},{"location":"ref/Microsoft.Coyote.IO/ILogger/Write/#see-also","text":"interface ILogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/ILogger/Write/#iloggerwrite-method-2-of-4","text":"Writes a string to the log. public void Write(LogSeverity severity, string value) parameter description severity The severity of the issue being logged. value The string to write.","title":"ILogger.Write method (2 of 4)"},{"location":"ref/Microsoft.Coyote.IO/ILogger/Write/#see-also_1","text":"enum LogSeverity interface ILogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/ILogger/Write/#iloggerwrite-method-3-of-4","text":"Writes an informational string to the log. public void Write(string format, params object[] args) parameter description format The string format to write. args The arguments needed to format the string.","title":"ILogger.Write method (3 of 4)"},{"location":"ref/Microsoft.Coyote.IO/ILogger/Write/#see-also_2","text":"interface ILogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/ILogger/Write/#iloggerwrite-method-4-of-4","text":"Writes a string to the log. public void Write(LogSeverity severity, string format, params object[] args) parameter description severity The severity of the issue being logged. format The string format to write. args The arguments needed to format the string.","title":"ILogger.Write method (4 of 4)"},{"location":"ref/Microsoft.Coyote.IO/ILogger/Write/#see-also_3","text":"enum LogSeverity interface ILogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/ILogger/WriteLine/","text":"ILogger.WriteLine method (1 of 4) Writes an informational string to the log. public void WriteLine(string value) parameter description value The string to write. See Also interface ILogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote ILogger.WriteLine method (2 of 4) Writes a string followed by a line terminator to the text string or stream. public void WriteLine(LogSeverity severity, string value) parameter description severity The severity of the issue being logged. value The string to write. See Also enum LogSeverity interface ILogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote ILogger.WriteLine method (3 of 4) Writes an informational string to the log. public void WriteLine(string format, params object[] args) parameter description format The string format to write. args The arguments needed to format the string. See Also interface ILogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote ILogger.WriteLine method (4 of 4) Writes a string followed by a line terminator to the text string or stream. public void WriteLine(LogSeverity severity, string format, params object[] args) parameter description severity The severity of the issue being logged. format The string format to write. args The arguments needed to format the string. See Also enum LogSeverity interface ILogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"WriteLine"},{"location":"ref/Microsoft.Coyote.IO/ILogger/WriteLine/#iloggerwriteline-method-1-of-4","text":"Writes an informational string to the log. public void WriteLine(string value) parameter description value The string to write.","title":"ILogger.WriteLine method (1 of 4)"},{"location":"ref/Microsoft.Coyote.IO/ILogger/WriteLine/#see-also","text":"interface ILogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/ILogger/WriteLine/#iloggerwriteline-method-2-of-4","text":"Writes a string followed by a line terminator to the text string or stream. public void WriteLine(LogSeverity severity, string value) parameter description severity The severity of the issue being logged. value The string to write.","title":"ILogger.WriteLine method (2 of 4)"},{"location":"ref/Microsoft.Coyote.IO/ILogger/WriteLine/#see-also_1","text":"enum LogSeverity interface ILogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/ILogger/WriteLine/#iloggerwriteline-method-3-of-4","text":"Writes an informational string to the log. public void WriteLine(string format, params object[] args) parameter description format The string format to write. args The arguments needed to format the string.","title":"ILogger.WriteLine method (3 of 4)"},{"location":"ref/Microsoft.Coyote.IO/ILogger/WriteLine/#see-also_2","text":"interface ILogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/ILogger/WriteLine/#iloggerwriteline-method-4-of-4","text":"Writes a string followed by a line terminator to the text string or stream. public void WriteLine(LogSeverity severity, string format, params object[] args) parameter description severity The severity of the issue being logged. format The string format to write. args The arguments needed to format the string.","title":"ILogger.WriteLine method (4 of 4)"},{"location":"ref/Microsoft.Coyote.IO/ILogger/WriteLine/#see-also_3","text":"enum LogSeverity interface ILogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/InMemoryLogger/Encoding/","text":"InMemoryLogger.Encoding property When overridden in a derived class, returns the character encoding in which the output is written. public override Encoding Encoding { get; } See Also class InMemoryLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"Encoding"},{"location":"ref/Microsoft.Coyote.IO/InMemoryLogger/Encoding/#inmemoryloggerencoding-property","text":"When overridden in a derived class, returns the character encoding in which the output is written. public override Encoding Encoding { get; }","title":"InMemoryLogger.Encoding property"},{"location":"ref/Microsoft.Coyote.IO/InMemoryLogger/Encoding/#see-also","text":"class InMemoryLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/InMemoryLogger/InMemoryLogger/","text":"InMemoryLogger constructor Initializes a new instance of the InMemoryLogger class. public InMemoryLogger() See Also class InMemoryLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"InMemoryLogger"},{"location":"ref/Microsoft.Coyote.IO/InMemoryLogger/InMemoryLogger/#inmemorylogger-constructor","text":"Initializes a new instance of the InMemoryLogger class. public InMemoryLogger()","title":"InMemoryLogger constructor"},{"location":"ref/Microsoft.Coyote.IO/InMemoryLogger/InMemoryLogger/#see-also","text":"class InMemoryLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/InMemoryLogger/TextWriter/","text":"InMemoryLogger.TextWriter property This property provides a TextWriter that implements ILogger which is handy if you have existing code that requires a TextWriter. public TextWriter TextWriter { get; } See Also class InMemoryLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"TextWriter"},{"location":"ref/Microsoft.Coyote.IO/InMemoryLogger/TextWriter/#inmemoryloggertextwriter-property","text":"This property provides a TextWriter that implements ILogger which is handy if you have existing code that requires a TextWriter. public TextWriter TextWriter { get; }","title":"InMemoryLogger.TextWriter property"},{"location":"ref/Microsoft.Coyote.IO/InMemoryLogger/TextWriter/#see-also","text":"class InMemoryLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/InMemoryLogger/ToString/","text":"InMemoryLogger.ToString method Returns the logged text as a string. public override string ToString() See Also class InMemoryLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"ToString"},{"location":"ref/Microsoft.Coyote.IO/InMemoryLogger/ToString/#inmemoryloggertostring-method","text":"Returns the logged text as a string. public override string ToString()","title":"InMemoryLogger.ToString method"},{"location":"ref/Microsoft.Coyote.IO/InMemoryLogger/ToString/#see-also","text":"class InMemoryLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/InMemoryLogger/Write/","text":"InMemoryLogger.Write method (1 of 3) Writes an informational string to the log. public override void Write(string value) parameter description value The string to write. See Also class InMemoryLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote InMemoryLogger.Write method (2 of 3) Writes a string to the log. public void Write(LogSeverity severity, string value) parameter description severity The severity of the issue being logged. value The string to write. See Also enum LogSeverity class InMemoryLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote InMemoryLogger.Write method (3 of 3) Writes a string to the log. public void Write(LogSeverity severity, string format, params object[] args) parameter description severity The severity of the issue being logged. format The string format to write. args The arguments needed to format the string. See Also enum LogSeverity class InMemoryLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"Write"},{"location":"ref/Microsoft.Coyote.IO/InMemoryLogger/Write/#inmemoryloggerwrite-method-1-of-3","text":"Writes an informational string to the log. public override void Write(string value) parameter description value The string to write.","title":"InMemoryLogger.Write method (1 of 3)"},{"location":"ref/Microsoft.Coyote.IO/InMemoryLogger/Write/#see-also","text":"class InMemoryLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/InMemoryLogger/Write/#inmemoryloggerwrite-method-2-of-3","text":"Writes a string to the log. public void Write(LogSeverity severity, string value) parameter description severity The severity of the issue being logged. value The string to write.","title":"InMemoryLogger.Write method (2 of 3)"},{"location":"ref/Microsoft.Coyote.IO/InMemoryLogger/Write/#see-also_1","text":"enum LogSeverity class InMemoryLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/InMemoryLogger/Write/#inmemoryloggerwrite-method-3-of-3","text":"Writes a string to the log. public void Write(LogSeverity severity, string format, params object[] args) parameter description severity The severity of the issue being logged. format The string format to write. args The arguments needed to format the string.","title":"InMemoryLogger.Write method (3 of 3)"},{"location":"ref/Microsoft.Coyote.IO/InMemoryLogger/Write/#see-also_2","text":"enum LogSeverity class InMemoryLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/InMemoryLogger/WriteLine/","text":"InMemoryLogger.WriteLine method (1 of 3) Writes an informational string to the log. public override void WriteLine(string value) parameter description value The string to write. See Also class InMemoryLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote InMemoryLogger.WriteLine method (2 of 3) Writes a string followed by a line terminator to the text string or stream. public void WriteLine(LogSeverity severity, string value) parameter description severity The severity of the issue being logged. value The string to write. See Also enum LogSeverity class InMemoryLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote InMemoryLogger.WriteLine method (3 of 3) Writes a string followed by a line terminator to the text string or stream. public void WriteLine(LogSeverity severity, string format, params object[] args) parameter description severity The severity of the issue being logged. format The string format to write. args The arguments needed to format the string. See Also enum LogSeverity class InMemoryLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"WriteLine"},{"location":"ref/Microsoft.Coyote.IO/InMemoryLogger/WriteLine/#inmemoryloggerwriteline-method-1-of-3","text":"Writes an informational string to the log. public override void WriteLine(string value) parameter description value The string to write.","title":"InMemoryLogger.WriteLine method (1 of 3)"},{"location":"ref/Microsoft.Coyote.IO/InMemoryLogger/WriteLine/#see-also","text":"class InMemoryLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/InMemoryLogger/WriteLine/#inmemoryloggerwriteline-method-2-of-3","text":"Writes a string followed by a line terminator to the text string or stream. public void WriteLine(LogSeverity severity, string value) parameter description severity The severity of the issue being logged. value The string to write.","title":"InMemoryLogger.WriteLine method (2 of 3)"},{"location":"ref/Microsoft.Coyote.IO/InMemoryLogger/WriteLine/#see-also_1","text":"enum LogSeverity class InMemoryLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/InMemoryLogger/WriteLine/#inmemoryloggerwriteline-method-3-of-3","text":"Writes a string followed by a line terminator to the text string or stream. public void WriteLine(LogSeverity severity, string format, params object[] args) parameter description severity The severity of the issue being logged. format The string format to write. args The arguments needed to format the string.","title":"InMemoryLogger.WriteLine method (3 of 3)"},{"location":"ref/Microsoft.Coyote.IO/InMemoryLogger/WriteLine/#see-also_2","text":"enum LogSeverity class InMemoryLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/TextWriterLogger/Encoding/","text":"TextWriterLogger.Encoding property public override Encoding Encoding { get; } See Also class TextWriterLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"Encoding"},{"location":"ref/Microsoft.Coyote.IO/TextWriterLogger/Encoding/#textwriterloggerencoding-property","text":"public override Encoding Encoding { get; }","title":"TextWriterLogger.Encoding property"},{"location":"ref/Microsoft.Coyote.IO/TextWriterLogger/Encoding/#see-also","text":"class TextWriterLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/TextWriterLogger/TextWriter/","text":"TextWriterLogger.TextWriter property This property provides a TextWriter that implements ILogger which is handy if you have existing code that requires a TextWriter. public TextWriter TextWriter { get; } See Also class TextWriterLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"TextWriter"},{"location":"ref/Microsoft.Coyote.IO/TextWriterLogger/TextWriter/#textwriterloggertextwriter-property","text":"This property provides a TextWriter that implements ILogger which is handy if you have existing code that requires a TextWriter. public TextWriter TextWriter { get; }","title":"TextWriterLogger.TextWriter property"},{"location":"ref/Microsoft.Coyote.IO/TextWriterLogger/TextWriter/#see-also","text":"class TextWriterLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/TextWriterLogger/TextWriterLogger/","text":"TextWriterLogger constructor Initializes a new instance of the TextWriterLogger class. public TextWriterLogger(TextWriter userLogger) parameter description userLogger The TextWriter to delegate to. See Also class TextWriterLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"TextWriterLogger"},{"location":"ref/Microsoft.Coyote.IO/TextWriterLogger/TextWriterLogger/#textwriterlogger-constructor","text":"Initializes a new instance of the TextWriterLogger class. public TextWriterLogger(TextWriter userLogger) parameter description userLogger The TextWriter to delegate to.","title":"TextWriterLogger constructor"},{"location":"ref/Microsoft.Coyote.IO/TextWriterLogger/TextWriterLogger/#see-also","text":"class TextWriterLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/TextWriterLogger/Write/","text":"TextWriterLogger.Write method (1 of 4) Writes an informational string to the log. public override void Write(string message) parameter description value The string to write. See Also class TextWriterLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote TextWriterLogger.Write method (2 of 4) Writes a string to the log. public void Write(LogSeverity severity, string value) parameter description severity The severity of the issue being logged. value The string to write. See Also enum LogSeverity class TextWriterLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote TextWriterLogger.Write method (3 of 4) Writes an informational string to the log. public override void Write(string format, params object[] args) parameter description format The string format to write. args The arguments needed to format the string. See Also class TextWriterLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote TextWriterLogger.Write method (4 of 4) Writes a string to the log. public void Write(LogSeverity severity, string format, params object[] args) parameter description severity The severity of the issue being logged. format The string format to write. args The arguments needed to format the string. See Also enum LogSeverity class TextWriterLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"Write"},{"location":"ref/Microsoft.Coyote.IO/TextWriterLogger/Write/#textwriterloggerwrite-method-1-of-4","text":"Writes an informational string to the log. public override void Write(string message) parameter description value The string to write.","title":"TextWriterLogger.Write method (1 of 4)"},{"location":"ref/Microsoft.Coyote.IO/TextWriterLogger/Write/#see-also","text":"class TextWriterLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/TextWriterLogger/Write/#textwriterloggerwrite-method-2-of-4","text":"Writes a string to the log. public void Write(LogSeverity severity, string value) parameter description severity The severity of the issue being logged. value The string to write.","title":"TextWriterLogger.Write method (2 of 4)"},{"location":"ref/Microsoft.Coyote.IO/TextWriterLogger/Write/#see-also_1","text":"enum LogSeverity class TextWriterLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/TextWriterLogger/Write/#textwriterloggerwrite-method-3-of-4","text":"Writes an informational string to the log. public override void Write(string format, params object[] args) parameter description format The string format to write. args The arguments needed to format the string.","title":"TextWriterLogger.Write method (3 of 4)"},{"location":"ref/Microsoft.Coyote.IO/TextWriterLogger/Write/#see-also_2","text":"class TextWriterLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/TextWriterLogger/Write/#textwriterloggerwrite-method-4-of-4","text":"Writes a string to the log. public void Write(LogSeverity severity, string format, params object[] args) parameter description severity The severity of the issue being logged. format The string format to write. args The arguments needed to format the string.","title":"TextWriterLogger.Write method (4 of 4)"},{"location":"ref/Microsoft.Coyote.IO/TextWriterLogger/Write/#see-also_3","text":"enum LogSeverity class TextWriterLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/TextWriterLogger/WriteLine/","text":"TextWriterLogger.WriteLine method (1 of 4) Writes an informational string to the log. public override void WriteLine(string message) parameter description value The string to write. See Also class TextWriterLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote TextWriterLogger.WriteLine method (2 of 4) Writes a string followed by a line terminator to the text string or stream. public void WriteLine(LogSeverity severity, string value) parameter description severity The severity of the issue being logged. value The string to write. See Also enum LogSeverity class TextWriterLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote TextWriterLogger.WriteLine method (3 of 4) Writes an informational string to the log. public override void WriteLine(string format, params object[] args) parameter description format The string format to write. args The arguments needed to format the string. See Also class TextWriterLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote TextWriterLogger.WriteLine method (4 of 4) Writes a string followed by a line terminator to the text string or stream. public void WriteLine(LogSeverity severity, string format, params object[] args) parameter description severity The severity of the issue being logged. format The string format to write. args The arguments needed to format the string. See Also enum LogSeverity class TextWriterLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"WriteLine"},{"location":"ref/Microsoft.Coyote.IO/TextWriterLogger/WriteLine/#textwriterloggerwriteline-method-1-of-4","text":"Writes an informational string to the log. public override void WriteLine(string message) parameter description value The string to write.","title":"TextWriterLogger.WriteLine method (1 of 4)"},{"location":"ref/Microsoft.Coyote.IO/TextWriterLogger/WriteLine/#see-also","text":"class TextWriterLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/TextWriterLogger/WriteLine/#textwriterloggerwriteline-method-2-of-4","text":"Writes a string followed by a line terminator to the text string or stream. public void WriteLine(LogSeverity severity, string value) parameter description severity The severity of the issue being logged. value The string to write.","title":"TextWriterLogger.WriteLine method (2 of 4)"},{"location":"ref/Microsoft.Coyote.IO/TextWriterLogger/WriteLine/#see-also_1","text":"enum LogSeverity class TextWriterLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/TextWriterLogger/WriteLine/#textwriterloggerwriteline-method-3-of-4","text":"Writes an informational string to the log. public override void WriteLine(string format, params object[] args) parameter description format The string format to write. args The arguments needed to format the string.","title":"TextWriterLogger.WriteLine method (3 of 4)"},{"location":"ref/Microsoft.Coyote.IO/TextWriterLogger/WriteLine/#see-also_2","text":"class TextWriterLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.IO/TextWriterLogger/WriteLine/#textwriterloggerwriteline-method-4-of-4","text":"Writes a string followed by a line terminator to the text string or stream. public void WriteLine(LogSeverity severity, string format, params object[] args) parameter description severity The severity of the issue being logged. format The string format to write. args The arguments needed to format the string.","title":"TextWriterLogger.WriteLine method (4 of 4)"},{"location":"ref/Microsoft.Coyote.IO/TextWriterLogger/WriteLine/#see-also_3","text":"enum LogSeverity class TextWriterLogger namespace Microsoft.Coyote.IO assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Random/Generator/","text":"Generator class Represents a pseudo-random value generator, which is an algorithm that produces a sequence of values that meet certain statistical requirements for randomness. During systematic testing, the generation of random values is controlled, which allows the runtime to explore combinations of choices to find bugs. public class Generator Public Members name description static Create () Creates a new pseudo-random value generator. NextBoolean () Returns a random boolean, that can be controlled during testing. NextBoolean (\u2026) Returns a random boolean, that can be controlled during testing. NextInteger (\u2026) Returns a random integer, that can be controlled during testing. Remarks See Program non-determinism for more information. See Also namespace Microsoft.Coyote.Random assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Random/Generator/#generator-class","text":"Represents a pseudo-random value generator, which is an algorithm that produces a sequence of values that meet certain statistical requirements for randomness. During systematic testing, the generation of random values is controlled, which allows the runtime to explore combinations of choices to find bugs. public class Generator","title":"Generator class"},{"location":"ref/Microsoft.Coyote.Random/Generator/#public-members","text":"name description static Create () Creates a new pseudo-random value generator. NextBoolean () Returns a random boolean, that can be controlled during testing. NextBoolean (\u2026) Returns a random boolean, that can be controlled during testing. NextInteger (\u2026) Returns a random integer, that can be controlled during testing.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Random/Generator/#remarks","text":"See Program non-determinism for more information.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Random/Generator/#see-also","text":"namespace Microsoft.Coyote.Random assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Random/Generator/Create/","text":"Generator.Create method Creates a new pseudo-random value generator. public static Generator Create() Return Value The pseudo-random value generator. See Also class Generator namespace Microsoft.Coyote.Random assembly Microsoft.Coyote","title":"Create"},{"location":"ref/Microsoft.Coyote.Random/Generator/Create/#generatorcreate-method","text":"Creates a new pseudo-random value generator. public static Generator Create()","title":"Generator.Create method"},{"location":"ref/Microsoft.Coyote.Random/Generator/Create/#return-value","text":"The pseudo-random value generator.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Random/Generator/Create/#see-also","text":"class Generator namespace Microsoft.Coyote.Random assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Random/Generator/NextBoolean/","text":"Generator.NextBoolean method (1 of 2) Returns a random boolean, that can be controlled during testing. public bool NextBoolean() See Also class Generator namespace Microsoft.Coyote.Random assembly Microsoft.Coyote Generator.NextBoolean method (2 of 2) Returns a random boolean, that can be controlled during testing. public bool NextBoolean(int maxValue) See Also class Generator namespace Microsoft.Coyote.Random assembly Microsoft.Coyote","title":"NextBoolean"},{"location":"ref/Microsoft.Coyote.Random/Generator/NextBoolean/#generatornextboolean-method-1-of-2","text":"Returns a random boolean, that can be controlled during testing. public bool NextBoolean()","title":"Generator.NextBoolean method (1 of 2)"},{"location":"ref/Microsoft.Coyote.Random/Generator/NextBoolean/#see-also","text":"class Generator namespace Microsoft.Coyote.Random assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Random/Generator/NextBoolean/#generatornextboolean-method-2-of-2","text":"Returns a random boolean, that can be controlled during testing. public bool NextBoolean(int maxValue)","title":"Generator.NextBoolean method (2 of 2)"},{"location":"ref/Microsoft.Coyote.Random/Generator/NextBoolean/#see-also_1","text":"class Generator namespace Microsoft.Coyote.Random assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Random/Generator/NextInteger/","text":"Generator.NextInteger method Returns a random integer, that can be controlled during testing. public int NextInteger(int maxValue) See Also class Generator namespace Microsoft.Coyote.Random assembly Microsoft.Coyote","title":"NextInteger"},{"location":"ref/Microsoft.Coyote.Random/Generator/NextInteger/#generatornextinteger-method","text":"Returns a random integer, that can be controlled during testing. public int NextInteger(int maxValue)","title":"Generator.NextInteger method"},{"location":"ref/Microsoft.Coyote.Random/Generator/NextInteger/#see-also","text":"class Generator namespace Microsoft.Coyote.Random assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Rewriting/IsAssemblyRewrittenAttribute/","text":"IsAssemblyRewrittenAttribute class Attribute for checking if an assembly has been rewritten by Coyote. If this attribute is applied to an assembly, it denotes that the assembly has been rewritten. [AttributeUsage(AttributeTargets.Assembly)] public sealed class IsAssemblyRewrittenAttribute : Attribute Public Members name description IsAssemblyRewrittenAttribute (\u2026) Initializes a new instance of the IsAssemblyRewrittenAttribute class. readonly Version The version of Coyote used for the rewritting. See Also namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"Overview"},{"location":"ref/Microsoft.Coyote.Rewriting/IsAssemblyRewrittenAttribute/#isassemblyrewrittenattribute-class","text":"Attribute for checking if an assembly has been rewritten by Coyote. If this attribute is applied to an assembly, it denotes that the assembly has been rewritten. [AttributeUsage(AttributeTargets.Assembly)] public sealed class IsAssemblyRewrittenAttribute : Attribute","title":"IsAssemblyRewrittenAttribute class"},{"location":"ref/Microsoft.Coyote.Rewriting/IsAssemblyRewrittenAttribute/#public-members","text":"name description IsAssemblyRewrittenAttribute (\u2026) Initializes a new instance of the IsAssemblyRewrittenAttribute class. readonly Version The version of Coyote used for the rewritting.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Rewriting/IsAssemblyRewrittenAttribute/#see-also","text":"namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingEngine/","text":"RewritingEngine class Engine that can rewrite a set of assemblies for systematic testing. public class RewritingEngine Public Members name description static IsAssemblyRewritten (\u2026) Checks if the specified assembly has been already rewritten with the current version of Coyote. static Run (\u2026) Runs the engine using the specified rewriting options. Remarks See rewriting for more information. See Also namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"Overview"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingEngine/#rewritingengine-class","text":"Engine that can rewrite a set of assemblies for systematic testing. public class RewritingEngine","title":"RewritingEngine class"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingEngine/#public-members","text":"name description static IsAssemblyRewritten (\u2026) Checks if the specified assembly has been already rewritten with the current version of Coyote. static Run (\u2026) Runs the engine using the specified rewriting options.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingEngine/#remarks","text":"See rewriting for more information.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingEngine/#see-also","text":"namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/","text":"RewritingOptions class Options for rewriting binaries. public class RewritingOptions Public Members name description RewritingOptions () The default constructor. static ParseFromJSON (\u2026) Parses the RewritingOptions from the specified JSON configuration file. AssembliesDirectory { get; set; } The directory containing the assemblies to rewrite. AssemblyPaths { get; set; } The file names of the assemblies to rewrite. If this list is empty then it will rewrite all assemblies in the AssembliesDirectory . DependencySearchPaths { get; set; } The paths to search for resolving dependencies. IgnoredAssemblies { get; set; } The regular expressions used to match against assembly names to determine which assemblies to ignore when rewriting dependencies or a whole directory. IsDataRaceCheckingEnabled { get; set; } True if rewriting for data race checking is enabled, else false. IsRewritingDependencies { get; set; } True if rewriting dependent assemblies that are found in the same location is enabled, else false. IsRewritingThreads { get; } True if rewriting Threads as controlled tasks. IsRewritingUnitTests { get; } True if rewriting of unit test methods is enabled, else false. Logger { get; set; } The logger used for rewriting. LogLevel { get; set; } The amount of log output to produce. OutputDirectory { get; set; } The output directory where rewritten assemblies are placed. If this is the same as the AssembliesDirectory then the rewritten assemblies will replace the original assemblies. StrongNameKeyFile { get; set; } Path of strong name key to use for signing rewritten assemblies. Remarks See rewriting for more information. See Also namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"Overview"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/#rewritingoptions-class","text":"Options for rewriting binaries. public class RewritingOptions","title":"RewritingOptions class"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/#public-members","text":"name description RewritingOptions () The default constructor. static ParseFromJSON (\u2026) Parses the RewritingOptions from the specified JSON configuration file. AssembliesDirectory { get; set; } The directory containing the assemblies to rewrite. AssemblyPaths { get; set; } The file names of the assemblies to rewrite. If this list is empty then it will rewrite all assemblies in the AssembliesDirectory . DependencySearchPaths { get; set; } The paths to search for resolving dependencies. IgnoredAssemblies { get; set; } The regular expressions used to match against assembly names to determine which assemblies to ignore when rewriting dependencies or a whole directory. IsDataRaceCheckingEnabled { get; set; } True if rewriting for data race checking is enabled, else false. IsRewritingDependencies { get; set; } True if rewriting dependent assemblies that are found in the same location is enabled, else false. IsRewritingThreads { get; } True if rewriting Threads as controlled tasks. IsRewritingUnitTests { get; } True if rewriting of unit test methods is enabled, else false. Logger { get; set; } The logger used for rewriting. LogLevel { get; set; } The amount of log output to produce. OutputDirectory { get; set; } The output directory where rewritten assemblies are placed. If this is the same as the AssembliesDirectory then the rewritten assemblies will replace the original assemblies. StrongNameKeyFile { get; set; } Path of strong name key to use for signing rewritten assemblies.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/#remarks","text":"See rewriting for more information.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/#see-also","text":"namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.Rewriting/IsAssemblyRewrittenAttribute/IsAssemblyRewrittenAttribute/","text":"IsAssemblyRewrittenAttribute constructor Initializes a new instance of the IsAssemblyRewrittenAttribute class. public IsAssemblyRewrittenAttribute(string version) See Also class IsAssemblyRewrittenAttribute namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"IsAssemblyRewrittenAttribute"},{"location":"ref/Microsoft.Coyote.Rewriting/IsAssemblyRewrittenAttribute/IsAssemblyRewrittenAttribute/#isassemblyrewrittenattribute-constructor","text":"Initializes a new instance of the IsAssemblyRewrittenAttribute class. public IsAssemblyRewrittenAttribute(string version)","title":"IsAssemblyRewrittenAttribute constructor"},{"location":"ref/Microsoft.Coyote.Rewriting/IsAssemblyRewrittenAttribute/IsAssemblyRewrittenAttribute/#see-also","text":"class IsAssemblyRewrittenAttribute namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.Rewriting/IsAssemblyRewrittenAttribute/Version/","text":"IsAssemblyRewrittenAttribute.Version field The version of Coyote used for the rewritting. public readonly string Version; See Also class IsAssemblyRewrittenAttribute namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"Version"},{"location":"ref/Microsoft.Coyote.Rewriting/IsAssemblyRewrittenAttribute/Version/#isassemblyrewrittenattributeversion-field","text":"The version of Coyote used for the rewritting. public readonly string Version;","title":"IsAssemblyRewrittenAttribute.Version field"},{"location":"ref/Microsoft.Coyote.Rewriting/IsAssemblyRewrittenAttribute/Version/#see-also","text":"class IsAssemblyRewrittenAttribute namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingEngine/IsAssemblyRewritten/","text":"RewritingEngine.IsAssemblyRewritten method Checks if the specified assembly has been already rewritten with the current version of Coyote. public static bool IsAssemblyRewritten(Assembly assembly) parameter description assembly The assembly to check. Return Value True if the assembly has been rewritten, else false. See Also class RewritingEngine namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"IsAssemblyRewritten"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingEngine/IsAssemblyRewritten/#rewritingengineisassemblyrewritten-method","text":"Checks if the specified assembly has been already rewritten with the current version of Coyote. public static bool IsAssemblyRewritten(Assembly assembly) parameter description assembly The assembly to check.","title":"RewritingEngine.IsAssemblyRewritten method"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingEngine/IsAssemblyRewritten/#return-value","text":"True if the assembly has been rewritten, else false.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingEngine/IsAssemblyRewritten/#see-also","text":"class RewritingEngine namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingEngine/Run/","text":"RewritingEngine.Run method Runs the engine using the specified rewriting options. public static void Run(Configuration configuration, RewritingOptions options) See Also class RewritingOptions class RewritingEngine namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"Run"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingEngine/Run/#rewritingenginerun-method","text":"Runs the engine using the specified rewriting options. public static void Run(Configuration configuration, RewritingOptions options)","title":"RewritingEngine.Run method"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingEngine/Run/#see-also","text":"class RewritingOptions class RewritingEngine namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/AssembliesDirectory/","text":"RewritingOptions.AssembliesDirectory property The directory containing the assemblies to rewrite. public string AssembliesDirectory { get; set; } See Also class RewritingOptions namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"AssembliesDirectory"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/AssembliesDirectory/#rewritingoptionsassembliesdirectory-property","text":"The directory containing the assemblies to rewrite. public string AssembliesDirectory { get; set; }","title":"RewritingOptions.AssembliesDirectory property"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/AssembliesDirectory/#see-also","text":"class RewritingOptions namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/AssemblyPaths/","text":"RewritingOptions.AssemblyPaths property The file names of the assemblies to rewrite. If this list is empty then it will rewrite all assemblies in the AssembliesDirectory . public HashSet<string> AssemblyPaths { get; set; } See Also class RewritingOptions namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"AssemblyPaths"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/AssemblyPaths/#rewritingoptionsassemblypaths-property","text":"The file names of the assemblies to rewrite. If this list is empty then it will rewrite all assemblies in the AssembliesDirectory . public HashSet<string> AssemblyPaths { get; set; }","title":"RewritingOptions.AssemblyPaths property"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/AssemblyPaths/#see-also","text":"class RewritingOptions namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/DependencySearchPaths/","text":"RewritingOptions.DependencySearchPaths property The paths to search for resolving dependencies. public IList<string> DependencySearchPaths { get; set; } See Also class RewritingOptions namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"DependencySearchPaths"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/DependencySearchPaths/#rewritingoptionsdependencysearchpaths-property","text":"The paths to search for resolving dependencies. public IList<string> DependencySearchPaths { get; set; }","title":"RewritingOptions.DependencySearchPaths property"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/DependencySearchPaths/#see-also","text":"class RewritingOptions namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/IgnoredAssemblies/","text":"RewritingOptions.IgnoredAssemblies property The regular expressions used to match against assembly names to determine which assemblies to ignore when rewriting dependencies or a whole directory. public IList<string> IgnoredAssemblies { get; set; } Remarks The list automatically includes the following expressions: Microsoft.Coyote. Microsoft.TestPlatform. Microsoft.VisualStudio.TestPlatform. Newtonsoft.Json. System.Private.CoreLib mscorlib. See Also class RewritingOptions namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"IgnoredAssemblies"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/IgnoredAssemblies/#rewritingoptionsignoredassemblies-property","text":"The regular expressions used to match against assembly names to determine which assemblies to ignore when rewriting dependencies or a whole directory. public IList<string> IgnoredAssemblies { get; set; }","title":"RewritingOptions.IgnoredAssemblies property"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/IgnoredAssemblies/#remarks","text":"The list automatically includes the following expressions: Microsoft.Coyote. Microsoft.TestPlatform. Microsoft.VisualStudio.TestPlatform. Newtonsoft.Json. System.Private.CoreLib mscorlib.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/IgnoredAssemblies/#see-also","text":"class RewritingOptions namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/IsDataRaceCheckingEnabled/","text":"RewritingOptions.IsDataRaceCheckingEnabled property True if rewriting for data race checking is enabled, else false. public bool IsDataRaceCheckingEnabled { get; set; } See Also class RewritingOptions namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"IsDataRaceCheckingEnabled"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/IsDataRaceCheckingEnabled/#rewritingoptionsisdataracecheckingenabled-property","text":"True if rewriting for data race checking is enabled, else false. public bool IsDataRaceCheckingEnabled { get; set; }","title":"RewritingOptions.IsDataRaceCheckingEnabled property"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/IsDataRaceCheckingEnabled/#see-also","text":"class RewritingOptions namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/IsRewritingDependencies/","text":"RewritingOptions.IsRewritingDependencies property True if rewriting dependent assemblies that are found in the same location is enabled, else false. public bool IsRewritingDependencies { get; set; } See Also class RewritingOptions namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"IsRewritingDependencies"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/IsRewritingDependencies/#rewritingoptionsisrewritingdependencies-property","text":"True if rewriting dependent assemblies that are found in the same location is enabled, else false. public bool IsRewritingDependencies { get; set; }","title":"RewritingOptions.IsRewritingDependencies property"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/IsRewritingDependencies/#see-also","text":"class RewritingOptions namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/IsRewritingThreads/","text":"RewritingOptions.IsRewritingThreads property True if rewriting Threads as controlled tasks. public bool IsRewritingThreads { get; } Remarks Normally Thread is not supported by Coyote, but this experimental feature wraps the thread in a Task so that Coyote knows about it which avoids uncontrolled concurrency errors in some cases. See Also class RewritingOptions namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"IsRewritingThreads"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/IsRewritingThreads/#rewritingoptionsisrewritingthreads-property","text":"True if rewriting Threads as controlled tasks. public bool IsRewritingThreads { get; }","title":"RewritingOptions.IsRewritingThreads property"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/IsRewritingThreads/#remarks","text":"Normally Thread is not supported by Coyote, but this experimental feature wraps the thread in a Task so that Coyote knows about it which avoids uncontrolled concurrency errors in some cases.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/IsRewritingThreads/#see-also","text":"class RewritingOptions namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/IsRewritingUnitTests/","text":"RewritingOptions.IsRewritingUnitTests property True if rewriting of unit test methods is enabled, else false. public bool IsRewritingUnitTests { get; } Remarks If unit test rewriting is enabled, Coyote will instrument the binary to run unit test methods in the scope of the Coyote testing engine. Note that this rewriting does not change the semantics of the original test. For example, if the test is sequential it will remain sequential, limiting the concurrency coverage that Coyote can achieve. See Also class RewritingOptions namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"IsRewritingUnitTests"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/IsRewritingUnitTests/#rewritingoptionsisrewritingunittests-property","text":"True if rewriting of unit test methods is enabled, else false. public bool IsRewritingUnitTests { get; }","title":"RewritingOptions.IsRewritingUnitTests property"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/IsRewritingUnitTests/#remarks","text":"If unit test rewriting is enabled, Coyote will instrument the binary to run unit test methods in the scope of the Coyote testing engine. Note that this rewriting does not change the semantics of the original test. For example, if the test is sequential it will remain sequential, limiting the concurrency coverage that Coyote can achieve.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/IsRewritingUnitTests/#see-also","text":"class RewritingOptions namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/LogLevel/","text":"RewritingOptions.LogLevel property The amount of log output to produce. public LogSeverity LogLevel { get; set; } See Also class RewritingOptions namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"LogLevel"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/LogLevel/#rewritingoptionsloglevel-property","text":"The amount of log output to produce. public LogSeverity LogLevel { get; set; }","title":"RewritingOptions.LogLevel property"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/LogLevel/#see-also","text":"class RewritingOptions namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/Logger/","text":"RewritingOptions.Logger property The logger used for rewriting. public ILogger Logger { get; set; } Remarks By default the logger write to Console. See Also class RewritingOptions namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"Logger"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/Logger/#rewritingoptionslogger-property","text":"The logger used for rewriting. public ILogger Logger { get; set; }","title":"RewritingOptions.Logger property"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/Logger/#remarks","text":"By default the logger write to Console.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/Logger/#see-also","text":"class RewritingOptions namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/OutputDirectory/","text":"RewritingOptions.OutputDirectory property The output directory where rewritten assemblies are placed. If this is the same as the AssembliesDirectory then the rewritten assemblies will replace the original assemblies. public string OutputDirectory { get; set; } See Also class RewritingOptions namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"OutputDirectory"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/OutputDirectory/#rewritingoptionsoutputdirectory-property","text":"The output directory where rewritten assemblies are placed. If this is the same as the AssembliesDirectory then the rewritten assemblies will replace the original assemblies. public string OutputDirectory { get; set; }","title":"RewritingOptions.OutputDirectory property"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/OutputDirectory/#see-also","text":"class RewritingOptions namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/ParseFromJSON/","text":"RewritingOptions.ParseFromJSON method Parses the RewritingOptions from the specified JSON configuration file. public static RewritingOptions ParseFromJSON(string configurationPath) See Also class RewritingOptions namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"ParseFromJSON"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/ParseFromJSON/#rewritingoptionsparsefromjson-method","text":"Parses the RewritingOptions from the specified JSON configuration file. public static RewritingOptions ParseFromJSON(string configurationPath)","title":"RewritingOptions.ParseFromJSON method"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/ParseFromJSON/#see-also","text":"class RewritingOptions namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/RewritingOptions/","text":"RewritingOptions constructor The default constructor. public RewritingOptions() See Also class RewritingOptions namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"RewritingOptions"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/RewritingOptions/#rewritingoptions-constructor","text":"The default constructor. public RewritingOptions()","title":"RewritingOptions constructor"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/RewritingOptions/#see-also","text":"class RewritingOptions namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/StrongNameKeyFile/","text":"RewritingOptions.StrongNameKeyFile property Path of strong name key to use for signing rewritten assemblies. public string StrongNameKeyFile { get; set; } See Also class RewritingOptions namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"StrongNameKeyFile"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/StrongNameKeyFile/#rewritingoptionsstrongnamekeyfile-property","text":"Path of strong name key to use for signing rewritten assemblies. public string StrongNameKeyFile { get; set; }","title":"RewritingOptions.StrongNameKeyFile property"},{"location":"ref/Microsoft.Coyote.Rewriting/RewritingOptions/StrongNameKeyFile/#see-also","text":"class RewritingOptions namespace Microsoft.Coyote.Rewriting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.Runtime/AssertionFailureException/","text":"AssertionFailureException class The exception that is thrown by the Coyote runtime upon assertion failure. public sealed class AssertionFailureException : RuntimeException See Also class RuntimeException namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"AssertionFailureException"},{"location":"ref/Microsoft.Coyote.Runtime/AssertionFailureException/#assertionfailureexception-class","text":"The exception that is thrown by the Coyote runtime upon assertion failure. public sealed class AssertionFailureException : RuntimeException","title":"AssertionFailureException class"},{"location":"ref/Microsoft.Coyote.Runtime/AssertionFailureException/#see-also","text":"class RuntimeException namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Runtime/ExecutionCanceledException/","text":"ExecutionCanceledException class Exception that is thrown upon cancellation of testing execution by the runtime. public sealed class ExecutionCanceledException : RuntimeException See Also class RuntimeException namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"ExecutionCanceledException"},{"location":"ref/Microsoft.Coyote.Runtime/ExecutionCanceledException/#executioncanceledexception-class","text":"Exception that is thrown upon cancellation of testing execution by the runtime. public sealed class ExecutionCanceledException : RuntimeException","title":"ExecutionCanceledException class"},{"location":"ref/Microsoft.Coyote.Runtime/ExecutionCanceledException/#see-also","text":"class RuntimeException namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/","text":"ICoyoteRuntime interface Interface that exposes base runtime methods for Coyote. public interface ICoyoteRuntime : IDisposable Members name description Logger { get; set; } Get or set the ILogger used to log messages. event OnFailure Callback that is fired when an exception is thrown that includes failed assertions. Assert (\u2026) Checks if the assertion holds, and if not, throws an AssertionFailureException exception. (5 methods) Monitor<T> (\u2026) Invokes the specified monitor with the specified Event . RandomBoolean () Returns a nondeterministic boolean choice, that can be controlled during analysis or testing. RandomBoolean (\u2026) Returns a nondeterministic boolean choice, that can be controlled during analysis or testing. The value is used to generate a number in the range [0..maxValue), where 0 triggers true. RandomInteger (\u2026) Returns a nondeterministic integer choice, that can be controlled during analysis or testing. The value is used to generate an integer in the range [0..maxValue). RegisterMonitor<T> () Registers a new specification monitor of the specified Type. Stop () Terminates the runtime and notifies each active actor to halt execution. See Also namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/#icoyoteruntime-interface","text":"Interface that exposes base runtime methods for Coyote. public interface ICoyoteRuntime : IDisposable","title":"ICoyoteRuntime interface"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/#members","text":"name description Logger { get; set; } Get or set the ILogger used to log messages. event OnFailure Callback that is fired when an exception is thrown that includes failed assertions. Assert (\u2026) Checks if the assertion holds, and if not, throws an AssertionFailureException exception. (5 methods) Monitor<T> (\u2026) Invokes the specified monitor with the specified Event . RandomBoolean () Returns a nondeterministic boolean choice, that can be controlled during analysis or testing. RandomBoolean (\u2026) Returns a nondeterministic boolean choice, that can be controlled during analysis or testing. The value is used to generate a number in the range [0..maxValue), where 0 triggers true. RandomInteger (\u2026) Returns a nondeterministic integer choice, that can be controlled during analysis or testing. The value is used to generate an integer in the range [0..maxValue). RegisterMonitor<T> () Registers a new specification monitor of the specified Type. Stop () Terminates the runtime and notifies each active actor to halt execution.","title":"Members"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/#see-also","text":"namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Runtime/OnFailureHandler/","text":"OnFailureHandler delegate Handles the OnFailure event. public delegate void OnFailureHandler(Exception ex); See Also namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"OnFailureHandler"},{"location":"ref/Microsoft.Coyote.Runtime/OnFailureHandler/#onfailurehandler-delegate","text":"Handles the OnFailure event. public delegate void OnFailureHandler(Exception ex);","title":"OnFailureHandler delegate"},{"location":"ref/Microsoft.Coyote.Runtime/OnFailureHandler/#see-also","text":"namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Runtime/RuntimeException/","text":"RuntimeException class An exception that is thrown by the Coyote runtime. public class RuntimeException : Exception Protected Members name description RuntimeException (\u2026) Initializes a new instance of the RuntimeException class. See Also namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Runtime/RuntimeException/#runtimeexception-class","text":"An exception that is thrown by the Coyote runtime. public class RuntimeException : Exception","title":"RuntimeException class"},{"location":"ref/Microsoft.Coyote.Runtime/RuntimeException/#protected-members","text":"name description RuntimeException (\u2026) Initializes a new instance of the RuntimeException class.","title":"Protected Members"},{"location":"ref/Microsoft.Coyote.Runtime/RuntimeException/#see-also","text":"namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Runtime/RuntimeFactory/","text":"RuntimeFactory class Provides methods for creating a ICoyoteRuntime runtime. public static class RuntimeFactory Public Members name description static Create () Creates a new Coyote runtime. static Create (\u2026) Creates a new Coyote runtime with the specified Configuration . See Also namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Runtime/RuntimeFactory/#runtimefactory-class","text":"Provides methods for creating a ICoyoteRuntime runtime. public static class RuntimeFactory","title":"RuntimeFactory class"},{"location":"ref/Microsoft.Coyote.Runtime/RuntimeFactory/#public-members","text":"name description static Create () Creates a new Coyote runtime. static Create (\u2026) Creates a new Coyote runtime with the specified Configuration .","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Runtime/RuntimeFactory/#see-also","text":"namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Runtime/SchedulingPoint/","text":"SchedulingPoint class Provides a set of static methods for declaring points in the execution where interleavings between operations should be explored during testing. public static class SchedulingPoint Public Members name description static Deprioritize () Lowers the scheduling priority of the currently executing operation during testing. static Interleave () Explores a possible interleaving with another operation during testing. Remarks These methods are no-op in production. See Also namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Runtime/SchedulingPoint/#schedulingpoint-class","text":"Provides a set of static methods for declaring points in the execution where interleavings between operations should be explored during testing. public static class SchedulingPoint","title":"SchedulingPoint class"},{"location":"ref/Microsoft.Coyote.Runtime/SchedulingPoint/#public-members","text":"name description static Deprioritize () Lowers the scheduling priority of the currently executing operation during testing. static Interleave () Explores a possible interleaving with another operation during testing.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Runtime/SchedulingPoint/#remarks","text":"These methods are no-op in production.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Runtime/SchedulingPoint/#see-also","text":"namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/Assert/","text":"ICoyoteRuntime.Assert method (1 of 5) Checks if the assertion holds, and if not, throws an AssertionFailureException exception. public void Assert(bool predicate) parameter description predicate The predicate to check. See Also interface ICoyoteRuntime namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote ICoyoteRuntime.Assert method (2 of 5) Checks if the assertion holds, and if not, throws an AssertionFailureException exception. public void Assert(bool predicate, string s, object arg0) parameter description predicate The predicate to check. s The message to print if the assertion fails. arg0 The first argument. See Also interface ICoyoteRuntime namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote ICoyoteRuntime.Assert method (3 of 5) Checks if the assertion holds, and if not, throws an AssertionFailureException exception. public void Assert(bool predicate, string s, params object[] args) parameter description predicate The predicate to check. s The message to print if the assertion fails. args The message arguments. See Also interface ICoyoteRuntime namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote ICoyoteRuntime.Assert method (4 of 5) Checks if the assertion holds, and if not, throws an AssertionFailureException exception. public void Assert(bool predicate, string s, object arg0, object arg1) parameter description predicate The predicate to check. s The message to print if the assertion fails. arg0 The first argument. arg1 The second argument. See Also interface ICoyoteRuntime namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote ICoyoteRuntime.Assert method (5 of 5) Checks if the assertion holds, and if not, throws an AssertionFailureException exception. public void Assert(bool predicate, string s, object arg0, object arg1, object arg2) parameter description predicate The predicate to check. s The message to print if the assertion fails. arg0 The first argument. arg1 The second argument. arg2 The third argument. See Also interface ICoyoteRuntime namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"Assert"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/Assert/#icoyoteruntimeassert-method-1-of-5","text":"Checks if the assertion holds, and if not, throws an AssertionFailureException exception. public void Assert(bool predicate) parameter description predicate The predicate to check.","title":"ICoyoteRuntime.Assert method (1 of 5)"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/Assert/#see-also","text":"interface ICoyoteRuntime namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/Assert/#icoyoteruntimeassert-method-2-of-5","text":"Checks if the assertion holds, and if not, throws an AssertionFailureException exception. public void Assert(bool predicate, string s, object arg0) parameter description predicate The predicate to check. s The message to print if the assertion fails. arg0 The first argument.","title":"ICoyoteRuntime.Assert method (2 of 5)"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/Assert/#see-also_1","text":"interface ICoyoteRuntime namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/Assert/#icoyoteruntimeassert-method-3-of-5","text":"Checks if the assertion holds, and if not, throws an AssertionFailureException exception. public void Assert(bool predicate, string s, params object[] args) parameter description predicate The predicate to check. s The message to print if the assertion fails. args The message arguments.","title":"ICoyoteRuntime.Assert method (3 of 5)"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/Assert/#see-also_2","text":"interface ICoyoteRuntime namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/Assert/#icoyoteruntimeassert-method-4-of-5","text":"Checks if the assertion holds, and if not, throws an AssertionFailureException exception. public void Assert(bool predicate, string s, object arg0, object arg1) parameter description predicate The predicate to check. s The message to print if the assertion fails. arg0 The first argument. arg1 The second argument.","title":"ICoyoteRuntime.Assert method (4 of 5)"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/Assert/#see-also_3","text":"interface ICoyoteRuntime namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/Assert/#icoyoteruntimeassert-method-5-of-5","text":"Checks if the assertion holds, and if not, throws an AssertionFailureException exception. public void Assert(bool predicate, string s, object arg0, object arg1, object arg2) parameter description predicate The predicate to check. s The message to print if the assertion fails. arg0 The first argument. arg1 The second argument. arg2 The third argument.","title":"ICoyoteRuntime.Assert method (5 of 5)"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/Assert/#see-also_4","text":"interface ICoyoteRuntime namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/Logger/","text":"ICoyoteRuntime.Logger property Get or set the ILogger used to log messages. public ILogger Logger { get; set; } Remarks See Logging for more information. See Also interface ILogger interface ICoyoteRuntime namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"Logger"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/Logger/#icoyoteruntimelogger-property","text":"Get or set the ILogger used to log messages. public ILogger Logger { get; set; }","title":"ICoyoteRuntime.Logger property"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/Logger/#remarks","text":"See Logging for more information.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/Logger/#see-also","text":"interface ILogger interface ICoyoteRuntime namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/Monitor/","text":"ICoyoteRuntime.Monitor<T> method Invokes the specified monitor with the specified Event . public void Monitor<T>(Event e) where T : Monitor parameter description T Type of the monitor. e Event to send to the monitor. See Also class Event class Monitor interface ICoyoteRuntime namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"Monitor"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/Monitor/#icoyoteruntimemonitort-method","text":"Invokes the specified monitor with the specified Event . public void Monitor<T>(Event e) where T : Monitor parameter description T Type of the monitor. e Event to send to the monitor.","title":"ICoyoteRuntime.Monitor&lt;T&gt; method"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/Monitor/#see-also","text":"class Event class Monitor interface ICoyoteRuntime namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/OnFailure/","text":"ICoyoteRuntime.OnFailure event Callback that is fired when an exception is thrown that includes failed assertions. public event OnFailureHandler OnFailure; See Also delegate OnFailureHandler interface ICoyoteRuntime namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"OnFailure"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/OnFailure/#icoyoteruntimeonfailure-event","text":"Callback that is fired when an exception is thrown that includes failed assertions. public event OnFailureHandler OnFailure;","title":"ICoyoteRuntime.OnFailure event"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/OnFailure/#see-also","text":"delegate OnFailureHandler interface ICoyoteRuntime namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/RandomBoolean/","text":"ICoyoteRuntime.RandomBoolean method (1 of 2) Returns a nondeterministic boolean choice, that can be controlled during analysis or testing. public bool RandomBoolean() Return Value The nondeterministic boolean choice. Remarks See Program non-determinism for more information. See Also interface ICoyoteRuntime namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote ICoyoteRuntime.RandomBoolean method (2 of 2) Returns a nondeterministic boolean choice, that can be controlled during analysis or testing. The value is used to generate a number in the range [0..maxValue), where 0 triggers true. public bool RandomBoolean(int maxValue) parameter description maxValue The max value. Return Value The nondeterministic boolean choice. Remarks See Program non-determinism for more information. See Also interface ICoyoteRuntime namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"RandomBoolean"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/RandomBoolean/#icoyoteruntimerandomboolean-method-1-of-2","text":"Returns a nondeterministic boolean choice, that can be controlled during analysis or testing. public bool RandomBoolean()","title":"ICoyoteRuntime.RandomBoolean method (1 of 2)"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/RandomBoolean/#return-value","text":"The nondeterministic boolean choice.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/RandomBoolean/#remarks","text":"See Program non-determinism for more information.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/RandomBoolean/#see-also","text":"interface ICoyoteRuntime namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/RandomBoolean/#icoyoteruntimerandomboolean-method-2-of-2","text":"Returns a nondeterministic boolean choice, that can be controlled during analysis or testing. The value is used to generate a number in the range [0..maxValue), where 0 triggers true. public bool RandomBoolean(int maxValue) parameter description maxValue The max value.","title":"ICoyoteRuntime.RandomBoolean method (2 of 2)"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/RandomBoolean/#return-value_1","text":"The nondeterministic boolean choice.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/RandomBoolean/#remarks_1","text":"See Program non-determinism for more information.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/RandomBoolean/#see-also_1","text":"interface ICoyoteRuntime namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/RandomInteger/","text":"ICoyoteRuntime.RandomInteger method Returns a nondeterministic integer choice, that can be controlled during analysis or testing. The value is used to generate an integer in the range [0..maxValue). public int RandomInteger(int maxValue) parameter description maxValue The max value. Return Value The nondeterministic integer choice. Remarks See Program non-determinism for more information. See Also interface ICoyoteRuntime namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"RandomInteger"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/RandomInteger/#icoyoteruntimerandominteger-method","text":"Returns a nondeterministic integer choice, that can be controlled during analysis or testing. The value is used to generate an integer in the range [0..maxValue). public int RandomInteger(int maxValue) parameter description maxValue The max value.","title":"ICoyoteRuntime.RandomInteger method"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/RandomInteger/#return-value","text":"The nondeterministic integer choice.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/RandomInteger/#remarks","text":"See Program non-determinism for more information.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/RandomInteger/#see-also","text":"interface ICoyoteRuntime namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/RegisterMonitor/","text":"ICoyoteRuntime.RegisterMonitor<T> method Registers a new specification monitor of the specified Type. public void RegisterMonitor<T>() where T : Monitor parameter description T Type of the monitor. See Also class Monitor interface ICoyoteRuntime namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"RegisterMonitor"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/RegisterMonitor/#icoyoteruntimeregistermonitort-method","text":"Registers a new specification monitor of the specified Type. public void RegisterMonitor<T>() where T : Monitor parameter description T Type of the monitor.","title":"ICoyoteRuntime.RegisterMonitor&lt;T&gt; method"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/RegisterMonitor/#see-also","text":"class Monitor interface ICoyoteRuntime namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/Stop/","text":"ICoyoteRuntime.Stop method Terminates the runtime and notifies each active actor to halt execution. public void Stop() See Also interface ICoyoteRuntime namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"Stop"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/Stop/#icoyoteruntimestop-method","text":"Terminates the runtime and notifies each active actor to halt execution. public void Stop()","title":"ICoyoteRuntime.Stop method"},{"location":"ref/Microsoft.Coyote.Runtime/ICoyoteRuntime/Stop/#see-also","text":"interface ICoyoteRuntime namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Runtime/RuntimeException/RuntimeException/","text":"RuntimeException constructor Initializes a new instance of the RuntimeException class. protected RuntimeException(SerializationInfo serializationInfo, StreamingContext streamingContext) See Also class RuntimeException namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"RuntimeException"},{"location":"ref/Microsoft.Coyote.Runtime/RuntimeException/RuntimeException/#runtimeexception-constructor","text":"Initializes a new instance of the RuntimeException class. protected RuntimeException(SerializationInfo serializationInfo, StreamingContext streamingContext)","title":"RuntimeException constructor"},{"location":"ref/Microsoft.Coyote.Runtime/RuntimeException/RuntimeException/#see-also","text":"class RuntimeException namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Runtime/RuntimeFactory/Create/","text":"RuntimeFactory.Create method (1 of 2) Creates a new Coyote runtime. public static ICoyoteRuntime Create() Return Value The created task runtime. Remarks Only one task runtime can be created per process. If you create a new task runtime it replaces the previously installed one. See Also interface ICoyoteRuntime class RuntimeFactory namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote RuntimeFactory.Create method (2 of 2) Creates a new Coyote runtime with the specified Configuration . public static ICoyoteRuntime Create(Configuration configuration) parameter description configuration The runtime configuration to use. Return Value The created task runtime. Remarks Only one task runtime can be created per process. If you create a new task runtime it replaces the previously installed one. See Also interface ICoyoteRuntime class Configuration class RuntimeFactory namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"Create"},{"location":"ref/Microsoft.Coyote.Runtime/RuntimeFactory/Create/#runtimefactorycreate-method-1-of-2","text":"Creates a new Coyote runtime. public static ICoyoteRuntime Create()","title":"RuntimeFactory.Create method (1 of 2)"},{"location":"ref/Microsoft.Coyote.Runtime/RuntimeFactory/Create/#return-value","text":"The created task runtime.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Runtime/RuntimeFactory/Create/#remarks","text":"Only one task runtime can be created per process. If you create a new task runtime it replaces the previously installed one.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Runtime/RuntimeFactory/Create/#see-also","text":"interface ICoyoteRuntime class RuntimeFactory namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Runtime/RuntimeFactory/Create/#runtimefactorycreate-method-2-of-2","text":"Creates a new Coyote runtime with the specified Configuration . public static ICoyoteRuntime Create(Configuration configuration) parameter description configuration The runtime configuration to use.","title":"RuntimeFactory.Create method (2 of 2)"},{"location":"ref/Microsoft.Coyote.Runtime/RuntimeFactory/Create/#return-value_1","text":"The created task runtime.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Runtime/RuntimeFactory/Create/#remarks_1","text":"Only one task runtime can be created per process. If you create a new task runtime it replaces the previously installed one.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Runtime/RuntimeFactory/Create/#see-also_1","text":"interface ICoyoteRuntime class Configuration class RuntimeFactory namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Runtime/SchedulingPoint/Deprioritize/","text":"SchedulingPoint.Deprioritize method Lowers the scheduling priority of the currently executing operation during testing. public static void Deprioritize() See Also class SchedulingPoint namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"Deprioritize"},{"location":"ref/Microsoft.Coyote.Runtime/SchedulingPoint/Deprioritize/#schedulingpointdeprioritize-method","text":"Lowers the scheduling priority of the currently executing operation during testing. public static void Deprioritize()","title":"SchedulingPoint.Deprioritize method"},{"location":"ref/Microsoft.Coyote.Runtime/SchedulingPoint/Deprioritize/#see-also","text":"class SchedulingPoint namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Runtime/SchedulingPoint/Interleave/","text":"SchedulingPoint.Interleave method Explores a possible interleaving with another operation during testing. public static void Interleave() See Also class SchedulingPoint namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"Interleave"},{"location":"ref/Microsoft.Coyote.Runtime/SchedulingPoint/Interleave/#schedulingpointinterleave-method","text":"Explores a possible interleaving with another operation during testing. public static void Interleave()","title":"SchedulingPoint.Interleave method"},{"location":"ref/Microsoft.Coyote.Runtime/SchedulingPoint/Interleave/#see-also","text":"class SchedulingPoint namespace Microsoft.Coyote.Runtime assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.ColdAttribute/","text":"Monitor.State.ColdAttribute class Attribute for declaring a cold monitor state. A monitor that is in a cold state satisfies a liveness property. [AttributeUsage(AttributeTargets.Class)] protected sealed class ColdAttribute : Attribute Public Members name description ColdAttribute () The default constructor. See Also class State namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.ColdAttribute/#monitorstatecoldattribute-class","text":"Attribute for declaring a cold monitor state. A monitor that is in a cold state satisfies a liveness property. [AttributeUsage(AttributeTargets.Class)] protected sealed class ColdAttribute : Attribute","title":"Monitor.State.ColdAttribute class"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.ColdAttribute/#public-members","text":"name description ColdAttribute () The default constructor.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.ColdAttribute/#see-also","text":"class State namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.HotAttribute/","text":"Monitor.State.HotAttribute class Attribute for declaring a hot monitor state. A monitor that is in a hot state violates a liveness property. [AttributeUsage(AttributeTargets.Class)] protected sealed class HotAttribute : Attribute Public Members name description HotAttribute () The default constructor. See Also class State namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.HotAttribute/#monitorstatehotattribute-class","text":"Attribute for declaring a hot monitor state. A monitor that is in a hot state violates a liveness property. [AttributeUsage(AttributeTargets.Class)] protected sealed class HotAttribute : Attribute","title":"Monitor.State.HotAttribute class"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.HotAttribute/#public-members","text":"name description HotAttribute () The default constructor.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.HotAttribute/#see-also","text":"class State namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.IgnoreEventsAttribute/","text":"Monitor.State.IgnoreEventsAttribute class Attribute for declaring what events should be ignored in a monitor state. [AttributeUsage(AttributeTargets.Class)] protected sealed class IgnoreEventsAttribute : Attribute Public Members name description IgnoreEventsAttribute (\u2026) Initializes a new instance of the IgnoreEventsAttribute class. See Also class State namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.IgnoreEventsAttribute/#monitorstateignoreeventsattribute-class","text":"Attribute for declaring what events should be ignored in a monitor state. [AttributeUsage(AttributeTargets.Class)] protected sealed class IgnoreEventsAttribute : Attribute","title":"Monitor.State.IgnoreEventsAttribute class"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.IgnoreEventsAttribute/#public-members","text":"name description IgnoreEventsAttribute (\u2026) Initializes a new instance of the IgnoreEventsAttribute class.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.IgnoreEventsAttribute/#see-also","text":"class State namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.OnEntryAttribute/","text":"Monitor.State.OnEntryAttribute class Attribute for declaring what action to perform when entering a monitor state. [AttributeUsage(AttributeTargets.Class)] protected sealed class OnEntryAttribute : Attribute Public Members name description OnEntryAttribute (\u2026) Initializes a new instance of the OnEntryAttribute class. See Also class State namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.OnEntryAttribute/#monitorstateonentryattribute-class","text":"Attribute for declaring what action to perform when entering a monitor state. [AttributeUsage(AttributeTargets.Class)] protected sealed class OnEntryAttribute : Attribute","title":"Monitor.State.OnEntryAttribute class"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.OnEntryAttribute/#public-members","text":"name description OnEntryAttribute (\u2026) Initializes a new instance of the OnEntryAttribute class.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.OnEntryAttribute/#see-also","text":"class State namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.OnEventDoActionAttribute/","text":"Monitor.State.OnEventDoActionAttribute class Attribute for declaring what action a monitor should perform when it receives an event in a given state. [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] protected sealed class OnEventDoActionAttribute : Attribute Public Members name description OnEventDoActionAttribute (\u2026) Initializes a new instance of the OnEventDoActionAttribute class. See Also class State namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.OnEventDoActionAttribute/#monitorstateoneventdoactionattribute-class","text":"Attribute for declaring what action a monitor should perform when it receives an event in a given state. [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] protected sealed class OnEventDoActionAttribute : Attribute","title":"Monitor.State.OnEventDoActionAttribute class"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.OnEventDoActionAttribute/#public-members","text":"name description OnEventDoActionAttribute (\u2026) Initializes a new instance of the OnEventDoActionAttribute class.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.OnEventDoActionAttribute/#see-also","text":"class State namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.OnEventGotoStateAttribute/","text":"Monitor.State.OnEventGotoStateAttribute class Attribute for declaring which state a monitor should transition to when it receives an event in a given state. [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] protected sealed class OnEventGotoStateAttribute : Attribute Public Members name description OnEventGotoStateAttribute (\u2026) Initializes a new instance of the OnEventGotoStateAttribute class. (2 constructors) See Also class State namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.OnEventGotoStateAttribute/#monitorstateoneventgotostateattribute-class","text":"Attribute for declaring which state a monitor should transition to when it receives an event in a given state. [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] protected sealed class OnEventGotoStateAttribute : Attribute","title":"Monitor.State.OnEventGotoStateAttribute class"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.OnEventGotoStateAttribute/#public-members","text":"name description OnEventGotoStateAttribute (\u2026) Initializes a new instance of the OnEventGotoStateAttribute class. (2 constructors)","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.OnEventGotoStateAttribute/#see-also","text":"class State namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.OnExitAttribute/","text":"Monitor.State.OnExitAttribute class Attribute for declaring what action to perform when exiting a monitor state. [AttributeUsage(AttributeTargets.Class)] protected sealed class OnExitAttribute : Attribute Public Members name description OnExitAttribute (\u2026) Initializes a new instance of the OnExitAttribute class. See Also class State namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.OnExitAttribute/#monitorstateonexitattribute-class","text":"Attribute for declaring what action to perform when exiting a monitor state. [AttributeUsage(AttributeTargets.Class)] protected sealed class OnExitAttribute : Attribute","title":"Monitor.State.OnExitAttribute class"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.OnExitAttribute/#public-members","text":"name description OnExitAttribute (\u2026) Initializes a new instance of the OnExitAttribute class.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.OnExitAttribute/#see-also","text":"class State namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.StartAttribute/","text":"Monitor.State.StartAttribute class Attribute for declaring that a state of a monitor is the start one. [AttributeUsage(AttributeTargets.Class)] protected sealed class StartAttribute : Attribute Public Members name description StartAttribute () The default constructor. See Also class State namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.StartAttribute/#monitorstatestartattribute-class","text":"Attribute for declaring that a state of a monitor is the start one. [AttributeUsage(AttributeTargets.Class)] protected sealed class StartAttribute : Attribute","title":"Monitor.State.StartAttribute class"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.StartAttribute/#public-members","text":"name description StartAttribute () The default constructor.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.StartAttribute/#see-also","text":"class State namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State/","text":"Monitor.State class Abstract class representing a state. public abstract class State Protected Members name description State () Initializes a new instance of the State class. class ColdAttribute Attribute for declaring a cold monitor state. A monitor that is in a cold state satisfies a liveness property. class HotAttribute Attribute for declaring a hot monitor state. A monitor that is in a hot state violates a liveness property. class IgnoreEventsAttribute Attribute for declaring what events should be ignored in a monitor state. class OnEntryAttribute Attribute for declaring what action to perform when entering a monitor state. class OnEventDoActionAttribute Attribute for declaring what action a monitor should perform when it receives an event in a given state. class OnEventGotoStateAttribute Attribute for declaring which state a monitor should transition to when it receives an event in a given state. class OnExitAttribute Attribute for declaring what action to perform when exiting a monitor state. class StartAttribute Attribute for declaring that a state of a monitor is the start one. See Also class Monitor namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State/#monitorstate-class","text":"Abstract class representing a state. public abstract class State","title":"Monitor.State class"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State/#protected-members","text":"name description State () Initializes a new instance of the State class. class ColdAttribute Attribute for declaring a cold monitor state. A monitor that is in a cold state satisfies a liveness property. class HotAttribute Attribute for declaring a hot monitor state. A monitor that is in a hot state violates a liveness property. class IgnoreEventsAttribute Attribute for declaring what events should be ignored in a monitor state. class OnEntryAttribute Attribute for declaring what action to perform when entering a monitor state. class OnEventDoActionAttribute Attribute for declaring what action a monitor should perform when it receives an event in a given state. class OnEventGotoStateAttribute Attribute for declaring which state a monitor should transition to when it receives an event in a given state. class OnExitAttribute Attribute for declaring what action to perform when exiting a monitor state. class StartAttribute Attribute for declaring that a state of a monitor is the start one.","title":"Protected Members"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State/#see-also","text":"class Monitor namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.StateGroup/","text":"Monitor.StateGroup class Abstract class used for representing a group of related states. public abstract class StateGroup Protected Members name description StateGroup () The default constructor. See Also class Monitor namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.StateGroup/#monitorstategroup-class","text":"Abstract class used for representing a group of related states. public abstract class StateGroup","title":"Monitor.StateGroup class"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.StateGroup/#protected-members","text":"name description StateGroup () The default constructor.","title":"Protected Members"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.StateGroup/#see-also","text":"class Monitor namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/","text":"Monitor class Abstract class representing a specification monitor. public abstract class Monitor Public Members name description override ToString () Returns a string that represents the current monitor. abstract class State Abstract class representing a state. abstract class StateGroup Abstract class used for representing a group of related states. Protected Members name description Monitor () Initializes a new instance of the Monitor class. CurrentState { get; } Gets the current state. virtual HashedState { get; } User-defined hashed state of the monitor. Override to improve the accuracy of stateful techniques during testing. Logger { get; } The logger installed to the runtime. Assert (\u2026) Checks if the assertion holds, and if not, throws an AssertionFailureException exception. (2 methods) RaiseEvent (\u2026) Raises the specified Event at the end of the current action. RaiseGotoStateEvent (\u2026) Raise a special event that performs a goto state operation at the end of the current action. RaiseGotoStateEvent<TState> () Raise a special event that performs a goto state operation at the end of the current action. Remarks See Specifications Overview for more information. See Also namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/#monitor-class","text":"Abstract class representing a specification monitor. public abstract class Monitor","title":"Monitor class"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/#public-members","text":"name description override ToString () Returns a string that represents the current monitor. abstract class State Abstract class representing a state. abstract class StateGroup Abstract class used for representing a group of related states.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/#protected-members","text":"name description Monitor () Initializes a new instance of the Monitor class. CurrentState { get; } Gets the current state. virtual HashedState { get; } User-defined hashed state of the monitor. Override to improve the accuracy of stateful techniques during testing. Logger { get; } The logger installed to the runtime. Assert (\u2026) Checks if the assertion holds, and if not, throws an AssertionFailureException exception. (2 methods) RaiseEvent (\u2026) Raises the specified Event at the end of the current action. RaiseGotoStateEvent (\u2026) Raise a special event that performs a goto state operation at the end of the current action. RaiseGotoStateEvent<TState> () Raise a special event that performs a goto state operation at the end of the current action.","title":"Protected Members"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/#remarks","text":"See Specifications Overview for more information.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/#see-also","text":"namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Specification/","text":"Specification class Provides static methods that are useful for writing specifications and interacting with the systematic testing engine. public static class Specification Public Members name description static Assert (\u2026) Checks if the predicate holds, and if not, throws an exception. (4 methods) static IsEventuallyCompletedSuccessfully (\u2026) Creates a monitor that checks if the specified task eventually completes its execution successfully, and if not, fails with a liveness property violation. static Monitor<T> (\u2026) Invokes the specified monitor with the given event. static RegisterMonitor<T> () Registers a new safety or liveness monitor. Remarks See Specifications Overview for more information. See Also namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Specifications/Specification/#specification-class","text":"Provides static methods that are useful for writing specifications and interacting with the systematic testing engine. public static class Specification","title":"Specification class"},{"location":"ref/Microsoft.Coyote.Specifications/Specification/#public-members","text":"name description static Assert (\u2026) Checks if the predicate holds, and if not, throws an exception. (4 methods) static IsEventuallyCompletedSuccessfully (\u2026) Creates a monitor that checks if the specified task eventually completes its execution successfully, and if not, fails with a liveness property violation. static Monitor<T> (\u2026) Invokes the specified monitor with the given event. static RegisterMonitor<T> () Registers a new safety or liveness monitor.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Specifications/Specification/#remarks","text":"See Specifications Overview for more information.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Specifications/Specification/#see-also","text":"namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/Assert/","text":"Monitor.Assert method (1 of 2) Checks if the assertion holds, and if not, throws an AssertionFailureException exception. protected void Assert(bool predicate) See Also class Monitor namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote Monitor.Assert method (2 of 2) Checks if the assertion holds, and if not, throws an AssertionFailureException exception. protected void Assert(bool predicate, string s, params object[] args) See Also class Monitor namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"Assert"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/Assert/#monitorassert-method-1-of-2","text":"Checks if the assertion holds, and if not, throws an AssertionFailureException exception. protected void Assert(bool predicate)","title":"Monitor.Assert method (1 of 2)"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/Assert/#see-also","text":"class Monitor namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/Assert/#monitorassert-method-2-of-2","text":"Checks if the assertion holds, and if not, throws an AssertionFailureException exception. protected void Assert(bool predicate, string s, params object[] args)","title":"Monitor.Assert method (2 of 2)"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/Assert/#see-also_1","text":"class Monitor namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/CurrentState/","text":"Monitor.CurrentState property Gets the current state. protected Type CurrentState { get; } See Also class Monitor namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"CurrentState"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/CurrentState/#monitorcurrentstate-property","text":"Gets the current state. protected Type CurrentState { get; }","title":"Monitor.CurrentState property"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/CurrentState/#see-also","text":"class Monitor namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/HashedState/","text":"Monitor.HashedState property User-defined hashed state of the monitor. Override to improve the accuracy of stateful techniques during testing. protected virtual int HashedState { get; } See Also class Monitor namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"HashedState"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/HashedState/#monitorhashedstate-property","text":"User-defined hashed state of the monitor. Override to improve the accuracy of stateful techniques during testing. protected virtual int HashedState { get; }","title":"Monitor.HashedState property"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/HashedState/#see-also","text":"class Monitor namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/Logger/","text":"Monitor.Logger property The logger installed to the runtime. protected ILogger Logger { get; } Remarks See Logging for more information. See Also interface ILogger class Monitor namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"Logger"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/Logger/#monitorlogger-property","text":"The logger installed to the runtime. protected ILogger Logger { get; }","title":"Monitor.Logger property"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/Logger/#remarks","text":"See Logging for more information.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/Logger/#see-also","text":"interface ILogger class Monitor namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/Monitor/","text":"Monitor constructor Initializes a new instance of the Monitor class. protected Monitor() See Also class Monitor namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"Monitor"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/Monitor/#monitor-constructor","text":"Initializes a new instance of the Monitor class. protected Monitor()","title":"Monitor constructor"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/Monitor/#see-also","text":"class Monitor namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/RaiseEvent/","text":"Monitor.RaiseEvent method Raises the specified Event at the end of the current action. protected void RaiseEvent(Event e) parameter description e The event to raise. Remarks This event is not handled until the action that calls this method returns control back to the Coyote runtime. It is handled before any other events are dequeued from the inbox. Only one of the following can be called per action: RaiseEvent , RaiseGotoStateEvent . An Assert is raised if you accidentally try and do two of these operations in a single action. See Also class Event class Monitor namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"RaiseEvent"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/RaiseEvent/#monitorraiseevent-method","text":"Raises the specified Event at the end of the current action. protected void RaiseEvent(Event e) parameter description e The event to raise.","title":"Monitor.RaiseEvent method"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/RaiseEvent/#remarks","text":"This event is not handled until the action that calls this method returns control back to the Coyote runtime. It is handled before any other events are dequeued from the inbox. Only one of the following can be called per action: RaiseEvent , RaiseGotoStateEvent . An Assert is raised if you accidentally try and do two of these operations in a single action.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/RaiseEvent/#see-also","text":"class Event class Monitor namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/RaiseGotoStateEvent/","text":"Monitor.RaiseGotoStateEvent method (1 of 2) Raise a special event that performs a goto state operation at the end of the current action. protected void RaiseGotoStateEvent(Type state) parameter description state Type of the state. Remarks Goto state pops the current State and pushes the specified State on the active state stack. This is shorthand for the following code: class Event E { } [OnEventGotoState(typeof(E), typeof(S))] this.RaiseEvent(new E()); This event is not handled until the action that calls this method returns control back to the Coyote runtime. It is handled before any other events are dequeued from the inbox. Only one of the following can be called per action: RaiseEvent , RaiseGotoStateEvent . An Assert is raised if you accidentally try and do two of these operations in a single action. See Also class Monitor namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote Monitor.RaiseGotoStateEvent<TState> method (2 of 2) Raise a special event that performs a goto state operation at the end of the current action. protected void RaiseGotoStateEvent<TState>() where TState : State parameter description TState Type of the state. Remarks Goto state pops the current State and pushes the specified State on the active state stack. This is shorthand for the following code: class Event E { } [OnEventGotoState(typeof(E), typeof(S))] this.RaiseEvent(new E()); This event is not handled until the action that calls this method returns control back to the Coyote runtime. It is handled before any other events are dequeued from the inbox. Only one of the following can be called per action: RaiseEvent , RaiseGotoStateEvent . An Assert is raised if you accidentally try and do two of these operations in a single action. See Also class State class Monitor namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"RaiseGotoStateEvent"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/RaiseGotoStateEvent/#monitorraisegotostateevent-method-1-of-2","text":"Raise a special event that performs a goto state operation at the end of the current action. protected void RaiseGotoStateEvent(Type state) parameter description state Type of the state.","title":"Monitor.RaiseGotoStateEvent method (1 of 2)"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/RaiseGotoStateEvent/#remarks","text":"Goto state pops the current State and pushes the specified State on the active state stack. This is shorthand for the following code: class Event E { } [OnEventGotoState(typeof(E), typeof(S))] this.RaiseEvent(new E()); This event is not handled until the action that calls this method returns control back to the Coyote runtime. It is handled before any other events are dequeued from the inbox. Only one of the following can be called per action: RaiseEvent , RaiseGotoStateEvent . An Assert is raised if you accidentally try and do two of these operations in a single action.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/RaiseGotoStateEvent/#see-also","text":"class Monitor namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/RaiseGotoStateEvent/#monitorraisegotostateeventtstate-method-2-of-2","text":"Raise a special event that performs a goto state operation at the end of the current action. protected void RaiseGotoStateEvent<TState>() where TState : State parameter description TState Type of the state.","title":"Monitor.RaiseGotoStateEvent&lt;TState&gt; method (2 of 2)"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/RaiseGotoStateEvent/#remarks_1","text":"Goto state pops the current State and pushes the specified State on the active state stack. This is shorthand for the following code: class Event E { } [OnEventGotoState(typeof(E), typeof(S))] this.RaiseEvent(new E()); This event is not handled until the action that calls this method returns control back to the Coyote runtime. It is handled before any other events are dequeued from the inbox. Only one of the following can be called per action: RaiseEvent , RaiseGotoStateEvent . An Assert is raised if you accidentally try and do two of these operations in a single action.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/RaiseGotoStateEvent/#see-also_1","text":"class State class Monitor namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/ToString/","text":"Monitor.ToString method Returns a string that represents the current monitor. public override string ToString() See Also class Monitor namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"ToString"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/ToString/#monitortostring-method","text":"Returns a string that represents the current monitor. public override string ToString()","title":"Monitor.ToString method"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor/ToString/#see-also","text":"class Monitor namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State/State/","text":"Monitor.State constructor Initializes a new instance of the State class. protected State() See Also class State namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"State"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State/State/#monitorstate-constructor","text":"Initializes a new instance of the State class. protected State()","title":"Monitor.State constructor"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State/State/#see-also","text":"class State namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.ColdAttribute/ColdAttribute/","text":"Monitor.State.ColdAttribute constructor The default constructor. public ColdAttribute() See Also class ColdAttribute namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"ColdAttribute"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.ColdAttribute/ColdAttribute/#monitorstatecoldattribute-constructor","text":"The default constructor. public ColdAttribute()","title":"Monitor.State.ColdAttribute constructor"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.ColdAttribute/ColdAttribute/#see-also","text":"class ColdAttribute namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.HotAttribute/HotAttribute/","text":"Monitor.State.HotAttribute constructor The default constructor. public HotAttribute() See Also class HotAttribute namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"HotAttribute"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.HotAttribute/HotAttribute/#monitorstatehotattribute-constructor","text":"The default constructor. public HotAttribute()","title":"Monitor.State.HotAttribute constructor"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.HotAttribute/HotAttribute/#see-also","text":"class HotAttribute namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.IgnoreEventsAttribute/IgnoreEventsAttribute/","text":"Monitor.State.IgnoreEventsAttribute constructor Initializes a new instance of the IgnoreEventsAttribute class. public IgnoreEventsAttribute(params Type[] eventTypes) parameter description eventTypes Event types. See Also class IgnoreEventsAttribute namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"IgnoreEventsAttribute"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.IgnoreEventsAttribute/IgnoreEventsAttribute/#monitorstateignoreeventsattribute-constructor","text":"Initializes a new instance of the IgnoreEventsAttribute class. public IgnoreEventsAttribute(params Type[] eventTypes) parameter description eventTypes Event types.","title":"Monitor.State.IgnoreEventsAttribute constructor"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.IgnoreEventsAttribute/IgnoreEventsAttribute/#see-also","text":"class IgnoreEventsAttribute namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.OnEntryAttribute/OnEntryAttribute/","text":"Monitor.State.OnEntryAttribute constructor Initializes a new instance of the OnEntryAttribute class. public OnEntryAttribute(string actionName) parameter description actionName Action name. See Also class OnEntryAttribute namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"OnEntryAttribute"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.OnEntryAttribute/OnEntryAttribute/#monitorstateonentryattribute-constructor","text":"Initializes a new instance of the OnEntryAttribute class. public OnEntryAttribute(string actionName) parameter description actionName Action name.","title":"Monitor.State.OnEntryAttribute constructor"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.OnEntryAttribute/OnEntryAttribute/#see-also","text":"class OnEntryAttribute namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.OnEventDoActionAttribute/OnEventDoActionAttribute/","text":"Monitor.State.OnEventDoActionAttribute constructor Initializes a new instance of the OnEventDoActionAttribute class. public OnEventDoActionAttribute(Type eventType, string actionName) parameter description eventType Event type. actionName Action name. See Also class OnEventDoActionAttribute namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"OnEventDoActionAttribute"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.OnEventDoActionAttribute/OnEventDoActionAttribute/#monitorstateoneventdoactionattribute-constructor","text":"Initializes a new instance of the OnEventDoActionAttribute class. public OnEventDoActionAttribute(Type eventType, string actionName) parameter description eventType Event type. actionName Action name.","title":"Monitor.State.OnEventDoActionAttribute constructor"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.OnEventDoActionAttribute/OnEventDoActionAttribute/#see-also","text":"class OnEventDoActionAttribute namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.OnEventGotoStateAttribute/OnEventGotoStateAttribute/","text":"Monitor.State.OnEventGotoStateAttribute constructor (1 of 2) Initializes a new instance of the OnEventGotoStateAttribute class. public OnEventGotoStateAttribute(Type eventType, Type stateType) parameter description eventType Event type. stateType State type. See Also class OnEventGotoStateAttribute namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote Monitor.State.OnEventGotoStateAttribute constructor (2 of 2) Initializes a new instance of the OnEventGotoStateAttribute class. public OnEventGotoStateAttribute(Type eventType, Type stateType, string actionName) parameter description eventType Event type. stateType State type. actionName Name of action to perform on exit. See Also class OnEventGotoStateAttribute namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"OnEventGotoStateAttribute"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.OnEventGotoStateAttribute/OnEventGotoStateAttribute/#monitorstateoneventgotostateattribute-constructor-1-of-2","text":"Initializes a new instance of the OnEventGotoStateAttribute class. public OnEventGotoStateAttribute(Type eventType, Type stateType) parameter description eventType Event type. stateType State type.","title":"Monitor.State.OnEventGotoStateAttribute constructor (1 of 2)"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.OnEventGotoStateAttribute/OnEventGotoStateAttribute/#see-also","text":"class OnEventGotoStateAttribute namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.OnEventGotoStateAttribute/OnEventGotoStateAttribute/#monitorstateoneventgotostateattribute-constructor-2-of-2","text":"Initializes a new instance of the OnEventGotoStateAttribute class. public OnEventGotoStateAttribute(Type eventType, Type stateType, string actionName) parameter description eventType Event type. stateType State type. actionName Name of action to perform on exit.","title":"Monitor.State.OnEventGotoStateAttribute constructor (2 of 2)"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.OnEventGotoStateAttribute/OnEventGotoStateAttribute/#see-also_1","text":"class OnEventGotoStateAttribute namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.OnExitAttribute/OnExitAttribute/","text":"Monitor.State.OnExitAttribute constructor Initializes a new instance of the OnExitAttribute class. public OnExitAttribute(string actionName) parameter description actionName Action name. See Also class OnExitAttribute namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"OnExitAttribute"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.OnExitAttribute/OnExitAttribute/#monitorstateonexitattribute-constructor","text":"Initializes a new instance of the OnExitAttribute class. public OnExitAttribute(string actionName) parameter description actionName Action name.","title":"Monitor.State.OnExitAttribute constructor"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.OnExitAttribute/OnExitAttribute/#see-also","text":"class OnExitAttribute namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.StartAttribute/StartAttribute/","text":"Monitor.State.StartAttribute constructor The default constructor. public StartAttribute() See Also class StartAttribute namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"StartAttribute"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.StartAttribute/StartAttribute/#monitorstatestartattribute-constructor","text":"The default constructor. public StartAttribute()","title":"Monitor.State.StartAttribute constructor"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.State.StartAttribute/StartAttribute/#see-also","text":"class StartAttribute namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.StateGroup/StateGroup/","text":"Monitor.StateGroup constructor The default constructor. protected StateGroup() See Also class StateGroup namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"StateGroup"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.StateGroup/StateGroup/#monitorstategroup-constructor","text":"The default constructor. protected StateGroup()","title":"Monitor.StateGroup constructor"},{"location":"ref/Microsoft.Coyote.Specifications/Monitor.StateGroup/StateGroup/#see-also","text":"class StateGroup namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Specification/Assert/","text":"Specification.Assert method (1 of 4) Checks if the predicate holds, and if not, throws an exception. public static void Assert(bool predicate, string s, object arg0) See Also class Specification namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote Specification.Assert method (2 of 4) Checks if the predicate holds, and if not, throws an exception. public static void Assert(bool predicate, string s, params object[] args) See Also class Specification namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote Specification.Assert method (3 of 4) Checks if the predicate holds, and if not, throws an exception. public static void Assert(bool predicate, string s, object arg0, object arg1) See Also class Specification namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote Specification.Assert method (4 of 4) Checks if the predicate holds, and if not, throws an exception. public static void Assert(bool predicate, string s, object arg0, object arg1, object arg2) See Also class Specification namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"Assert"},{"location":"ref/Microsoft.Coyote.Specifications/Specification/Assert/#specificationassert-method-1-of-4","text":"Checks if the predicate holds, and if not, throws an exception. public static void Assert(bool predicate, string s, object arg0)","title":"Specification.Assert method (1 of 4)"},{"location":"ref/Microsoft.Coyote.Specifications/Specification/Assert/#see-also","text":"class Specification namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Specification/Assert/#specificationassert-method-2-of-4","text":"Checks if the predicate holds, and if not, throws an exception. public static void Assert(bool predicate, string s, params object[] args)","title":"Specification.Assert method (2 of 4)"},{"location":"ref/Microsoft.Coyote.Specifications/Specification/Assert/#see-also_1","text":"class Specification namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Specification/Assert/#specificationassert-method-3-of-4","text":"Checks if the predicate holds, and if not, throws an exception. public static void Assert(bool predicate, string s, object arg0, object arg1)","title":"Specification.Assert method (3 of 4)"},{"location":"ref/Microsoft.Coyote.Specifications/Specification/Assert/#see-also_2","text":"class Specification namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Specification/Assert/#specificationassert-method-4-of-4","text":"Checks if the predicate holds, and if not, throws an exception. public static void Assert(bool predicate, string s, object arg0, object arg1, object arg2)","title":"Specification.Assert method (4 of 4)"},{"location":"ref/Microsoft.Coyote.Specifications/Specification/Assert/#see-also_3","text":"class Specification namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Specification/IsEventuallyCompletedSuccessfully/","text":"Specification.IsEventuallyCompletedSuccessfully method Creates a monitor that checks if the specified task eventually completes its execution successfully, and if not, fails with a liveness property violation. public static void IsEventuallyCompletedSuccessfully(Task task) parameter description task The task to monitor. Remarks The liveness property is only checked during systematic testing. See Also class Specification namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"IsEventuallyCompletedSuccessfully"},{"location":"ref/Microsoft.Coyote.Specifications/Specification/IsEventuallyCompletedSuccessfully/#specificationiseventuallycompletedsuccessfully-method","text":"Creates a monitor that checks if the specified task eventually completes its execution successfully, and if not, fails with a liveness property violation. public static void IsEventuallyCompletedSuccessfully(Task task) parameter description task The task to monitor.","title":"Specification.IsEventuallyCompletedSuccessfully method"},{"location":"ref/Microsoft.Coyote.Specifications/Specification/IsEventuallyCompletedSuccessfully/#remarks","text":"The liveness property is only checked during systematic testing.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Specifications/Specification/IsEventuallyCompletedSuccessfully/#see-also","text":"class Specification namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Specification/Monitor/","text":"Specification.Monitor<T> method Invokes the specified monitor with the given event. public static void Monitor<T>(Event e) where T : Monitor parameter description T Type of the monitor. e Event to send to the monitor. See Also class Event class Monitor class Specification namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"Monitor"},{"location":"ref/Microsoft.Coyote.Specifications/Specification/Monitor/#specificationmonitort-method","text":"Invokes the specified monitor with the given event. public static void Monitor<T>(Event e) where T : Monitor parameter description T Type of the monitor. e Event to send to the monitor.","title":"Specification.Monitor&lt;T&gt; method"},{"location":"ref/Microsoft.Coyote.Specifications/Specification/Monitor/#see-also","text":"class Event class Monitor class Specification namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Specifications/Specification/RegisterMonitor/","text":"Specification.RegisterMonitor<T> method Registers a new safety or liveness monitor. public static void RegisterMonitor<T>() where T : Monitor parameter description T Type of the monitor. See Also class Monitor class Specification namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"RegisterMonitor"},{"location":"ref/Microsoft.Coyote.Specifications/Specification/RegisterMonitor/#specificationregistermonitort-method","text":"Registers a new safety or liveness monitor. public static void RegisterMonitor<T>() where T : Monitor parameter description T Type of the monitor.","title":"Specification.RegisterMonitor&lt;T&gt; method"},{"location":"ref/Microsoft.Coyote.Specifications/Specification/RegisterMonitor/#see-also","text":"class Monitor class Specification namespace Microsoft.Coyote.Specifications assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestAttribute/","text":"TestAttribute class Attribute for declaring the entry point to a Coyote test. [AttributeUsage(AttributeTargets.Method)] public sealed class TestAttribute : Attribute Public Members name description TestAttribute () The default constructor. See Also namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"Overview"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestAttribute/#testattribute-class","text":"Attribute for declaring the entry point to a Coyote test. [AttributeUsage(AttributeTargets.Method)] public sealed class TestAttribute : Attribute","title":"TestAttribute class"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestAttribute/#public-members","text":"name description TestAttribute () The default constructor.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestAttribute/#see-also","text":"namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestDisposeAttribute/","text":"TestDisposeAttribute class Attribute for declaring a cleanup method to be called when all test iterations terminate. [AttributeUsage(AttributeTargets.Method)] public sealed class TestDisposeAttribute : Attribute Public Members name description TestDisposeAttribute () The default constructor. See Also namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"Overview"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestDisposeAttribute/#testdisposeattribute-class","text":"Attribute for declaring a cleanup method to be called when all test iterations terminate. [AttributeUsage(AttributeTargets.Method)] public sealed class TestDisposeAttribute : Attribute","title":"TestDisposeAttribute class"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestDisposeAttribute/#public-members","text":"name description TestDisposeAttribute () The default constructor.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestDisposeAttribute/#see-also","text":"namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestInitAttribute/","text":"TestInitAttribute class Attribute for declaring the initialization method to be called before testing starts. [AttributeUsage(AttributeTargets.Method)] public sealed class TestInitAttribute : Attribute Public Members name description TestInitAttribute () The default constructor. See Also namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"Overview"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestInitAttribute/#testinitattribute-class","text":"Attribute for declaring the initialization method to be called before testing starts. [AttributeUsage(AttributeTargets.Method)] public sealed class TestInitAttribute : Attribute","title":"TestInitAttribute class"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestInitAttribute/#public-members","text":"name description TestInitAttribute () The default constructor.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestInitAttribute/#see-also","text":"namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestIterationDisposeAttribute/","text":"TestIterationDisposeAttribute class Attribute for declaring a cleanup method to be called when each test iteration terminates. [AttributeUsage(AttributeTargets.Method)] public sealed class TestIterationDisposeAttribute : Attribute Public Members name description TestIterationDisposeAttribute () The default constructor. See Also namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"Overview"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestIterationDisposeAttribute/#testiterationdisposeattribute-class","text":"Attribute for declaring a cleanup method to be called when each test iteration terminates. [AttributeUsage(AttributeTargets.Method)] public sealed class TestIterationDisposeAttribute : Attribute","title":"TestIterationDisposeAttribute class"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestIterationDisposeAttribute/#public-members","text":"name description TestIterationDisposeAttribute () The default constructor.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestIterationDisposeAttribute/#see-also","text":"namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/","text":"TestReport class Class implementing the Coyote test report. public class TestReport Public Members name description TestReport (\u2026) Initializes a new instance of the TestReport class. BugReports { get; } Set of unique bug reports. Configuration { get; } Configuration of the program-under-test. CoverageInfo { get; } Information regarding code coverage. InternalErrors { get; } Set of internal errors. If no internal errors occurred, then this set is empty. MaxExploredFairSteps { get; } The max explored scheduling steps in average, in fair tests. MaxFairStepsHitInFairTests { get; } Number of times the fair max steps bound was hit, in fair tests. MaxUnfairStepsHitInFairTests { get; } Number of times the unfair max steps bound was hit, in fair tests. MaxUnfairStepsHitInUnfairTests { get; } Number of times the unfair max steps bound was hit, in unfair tests. MinExploredFairSteps { get; } The min explored scheduling steps in average, in fair tests. NumOfExploredFairSchedules { get; } Number of explored fair schedules. NumOfExploredUnfairSchedules { get; } Number of explored unfair schedules. NumOfFoundBugs { get; } Number of found bugs. TotalExploredFairSteps { get; } The total explored scheduling steps (across all testing iterations), in fair tests. Clone () Clones the test report. GetText (\u2026) Returns the testing report as a string, given a configuration and an optional prefix. Merge (\u2026) Merges the information from the specified test report. See Also namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"Overview"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/#testreport-class","text":"Class implementing the Coyote test report. public class TestReport","title":"TestReport class"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/#public-members","text":"name description TestReport (\u2026) Initializes a new instance of the TestReport class. BugReports { get; } Set of unique bug reports. Configuration { get; } Configuration of the program-under-test. CoverageInfo { get; } Information regarding code coverage. InternalErrors { get; } Set of internal errors. If no internal errors occurred, then this set is empty. MaxExploredFairSteps { get; } The max explored scheduling steps in average, in fair tests. MaxFairStepsHitInFairTests { get; } Number of times the fair max steps bound was hit, in fair tests. MaxUnfairStepsHitInFairTests { get; } Number of times the unfair max steps bound was hit, in fair tests. MaxUnfairStepsHitInUnfairTests { get; } Number of times the unfair max steps bound was hit, in unfair tests. MinExploredFairSteps { get; } The min explored scheduling steps in average, in fair tests. NumOfExploredFairSchedules { get; } Number of explored fair schedules. NumOfExploredUnfairSchedules { get; } Number of explored unfair schedules. NumOfFoundBugs { get; } Number of found bugs. TotalExploredFairSteps { get; } The total explored scheduling steps (across all testing iterations), in fair tests. Clone () Clones the test report. GetText (\u2026) Returns the testing report as a string, given a configuration and an optional prefix. Merge (\u2026) Merges the information from the specified test report.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/#see-also","text":"namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/","text":"TestingEngine class Testing engine that can run a controlled concurrency test using a specified configuration. public sealed class TestingEngine Public Members name description static Create (\u2026) Creates a new systematic testing engine. (10 methods) Logger { get; set; } Get or set the ILogger used to log messages during testing. ReadableTrace { get; } The readable trace, if any. ReproducibleTrace { get; } The reproducable trace, if any. TestReport { get; set; } Data structure containing information gathered during testing. GetReport () Returns a report with the testing results. IsTestRewritten () Checks if the test executed by the testing engine has been rewritten. RegisterPerIterationCallBack (\u2026) Registers a callback to invoke at the end of each iteration. The callback takes as a parameter an integer representing the current iteration. Run () Runs the testing engine. Stop () Stops the testing engine. ThrowIfBugFound () Throws either an AssertionFailureException, if a bug was found, or an unhandled Exception, if one was thrown. TryEmitTraces (\u2026) Tries to emit the testing traces, if any. See Also namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"Overview"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/#testingengine-class","text":"Testing engine that can run a controlled concurrency test using a specified configuration. public sealed class TestingEngine","title":"TestingEngine class"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/#public-members","text":"name description static Create (\u2026) Creates a new systematic testing engine. (10 methods) Logger { get; set; } Get or set the ILogger used to log messages during testing. ReadableTrace { get; } The readable trace, if any. ReproducibleTrace { get; } The reproducable trace, if any. TestReport { get; set; } Data structure containing information gathered during testing. GetReport () Returns a report with the testing results. IsTestRewritten () Checks if the test executed by the testing engine has been rewritten. RegisterPerIterationCallBack (\u2026) Registers a callback to invoke at the end of each iteration. The callback takes as a parameter an integer representing the current iteration. Run () Runs the testing engine. Stop () Stops the testing engine. ThrowIfBugFound () Throws either an AssertionFailureException, if a bug was found, or an unhandled Exception, if one was thrown. TryEmitTraces (\u2026) Tries to emit the testing traces, if any.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/#see-also","text":"namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestAttribute/TestAttribute/","text":"TestAttribute constructor The default constructor. public TestAttribute() See Also class TestAttribute namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"TestAttribute"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestAttribute/TestAttribute/#testattribute-constructor","text":"The default constructor. public TestAttribute()","title":"TestAttribute constructor"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestAttribute/TestAttribute/#see-also","text":"class TestAttribute namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestDisposeAttribute/TestDisposeAttribute/","text":"TestDisposeAttribute constructor The default constructor. public TestDisposeAttribute() See Also class TestDisposeAttribute namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"TestDisposeAttribute"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestDisposeAttribute/TestDisposeAttribute/#testdisposeattribute-constructor","text":"The default constructor. public TestDisposeAttribute()","title":"TestDisposeAttribute constructor"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestDisposeAttribute/TestDisposeAttribute/#see-also","text":"class TestDisposeAttribute namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestInitAttribute/TestInitAttribute/","text":"TestInitAttribute constructor The default constructor. public TestInitAttribute() See Also class TestInitAttribute namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"TestInitAttribute"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestInitAttribute/TestInitAttribute/#testinitattribute-constructor","text":"The default constructor. public TestInitAttribute()","title":"TestInitAttribute constructor"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestInitAttribute/TestInitAttribute/#see-also","text":"class TestInitAttribute namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestIterationDisposeAttribute/TestIterationDisposeAttribute/","text":"TestIterationDisposeAttribute constructor The default constructor. public TestIterationDisposeAttribute() See Also class TestIterationDisposeAttribute namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"TestIterationDisposeAttribute"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestIterationDisposeAttribute/TestIterationDisposeAttribute/#testiterationdisposeattribute-constructor","text":"The default constructor. public TestIterationDisposeAttribute()","title":"TestIterationDisposeAttribute constructor"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestIterationDisposeAttribute/TestIterationDisposeAttribute/#see-also","text":"class TestIterationDisposeAttribute namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/BugReports/","text":"TestReport.BugReports property Set of unique bug reports. public HashSet<string> BugReports { get; } See Also class TestReport namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"BugReports"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/BugReports/#testreportbugreports-property","text":"Set of unique bug reports. public HashSet<string> BugReports { get; }","title":"TestReport.BugReports property"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/BugReports/#see-also","text":"class TestReport namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/Clone/","text":"TestReport.Clone method Clones the test report. public TestReport Clone() See Also class TestReport namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"Clone"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/Clone/#testreportclone-method","text":"Clones the test report. public TestReport Clone()","title":"TestReport.Clone method"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/Clone/#see-also","text":"class TestReport namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/Configuration/","text":"TestReport.Configuration property Configuration of the program-under-test. public Configuration Configuration { get; } See Also class TestReport namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"Configuration"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/Configuration/#testreportconfiguration-property","text":"Configuration of the program-under-test. public Configuration Configuration { get; }","title":"TestReport.Configuration property"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/Configuration/#see-also","text":"class TestReport namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/CoverageInfo/","text":"TestReport.CoverageInfo property Information regarding code coverage. public CoverageInfo CoverageInfo { get; } See Also class TestReport namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"CoverageInfo"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/CoverageInfo/#testreportcoverageinfo-property","text":"Information regarding code coverage. public CoverageInfo CoverageInfo { get; }","title":"TestReport.CoverageInfo property"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/CoverageInfo/#see-also","text":"class TestReport namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/GetText/","text":"TestReport.GetText method Returns the testing report as a string, given a configuration and an optional prefix. public string GetText(Configuration configuration, string prefix = \"\") See Also class TestReport namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"GetText"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/GetText/#testreportgettext-method","text":"Returns the testing report as a string, given a configuration and an optional prefix. public string GetText(Configuration configuration, string prefix = \"\")","title":"TestReport.GetText method"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/GetText/#see-also","text":"class TestReport namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/InternalErrors/","text":"TestReport.InternalErrors property Set of internal errors. If no internal errors occurred, then this set is empty. public HashSet<string> InternalErrors { get; } See Also class TestReport namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"InternalErrors"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/InternalErrors/#testreportinternalerrors-property","text":"Set of internal errors. If no internal errors occurred, then this set is empty. public HashSet<string> InternalErrors { get; }","title":"TestReport.InternalErrors property"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/InternalErrors/#see-also","text":"class TestReport namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/MaxExploredFairSteps/","text":"TestReport.MaxExploredFairSteps property The max explored scheduling steps in average, in fair tests. public int MaxExploredFairSteps { get; } See Also class TestReport namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"MaxExploredFairSteps"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/MaxExploredFairSteps/#testreportmaxexploredfairsteps-property","text":"The max explored scheduling steps in average, in fair tests. public int MaxExploredFairSteps { get; }","title":"TestReport.MaxExploredFairSteps property"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/MaxExploredFairSteps/#see-also","text":"class TestReport namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/MaxFairStepsHitInFairTests/","text":"TestReport.MaxFairStepsHitInFairTests property Number of times the fair max steps bound was hit, in fair tests. public int MaxFairStepsHitInFairTests { get; } See Also class TestReport namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"MaxFairStepsHitInFairTests"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/MaxFairStepsHitInFairTests/#testreportmaxfairstepshitinfairtests-property","text":"Number of times the fair max steps bound was hit, in fair tests. public int MaxFairStepsHitInFairTests { get; }","title":"TestReport.MaxFairStepsHitInFairTests property"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/MaxFairStepsHitInFairTests/#see-also","text":"class TestReport namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/MaxUnfairStepsHitInFairTests/","text":"TestReport.MaxUnfairStepsHitInFairTests property Number of times the unfair max steps bound was hit, in fair tests. public int MaxUnfairStepsHitInFairTests { get; } See Also class TestReport namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"MaxUnfairStepsHitInFairTests"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/MaxUnfairStepsHitInFairTests/#testreportmaxunfairstepshitinfairtests-property","text":"Number of times the unfair max steps bound was hit, in fair tests. public int MaxUnfairStepsHitInFairTests { get; }","title":"TestReport.MaxUnfairStepsHitInFairTests property"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/MaxUnfairStepsHitInFairTests/#see-also","text":"class TestReport namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/MaxUnfairStepsHitInUnfairTests/","text":"TestReport.MaxUnfairStepsHitInUnfairTests property Number of times the unfair max steps bound was hit, in unfair tests. public int MaxUnfairStepsHitInUnfairTests { get; } See Also class TestReport namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"MaxUnfairStepsHitInUnfairTests"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/MaxUnfairStepsHitInUnfairTests/#testreportmaxunfairstepshitinunfairtests-property","text":"Number of times the unfair max steps bound was hit, in unfair tests. public int MaxUnfairStepsHitInUnfairTests { get; }","title":"TestReport.MaxUnfairStepsHitInUnfairTests property"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/MaxUnfairStepsHitInUnfairTests/#see-also","text":"class TestReport namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/Merge/","text":"TestReport.Merge method Merges the information from the specified test report. public bool Merge(TestReport testReport) Return Value True if merged successfully. See Also class TestReport namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"Merge"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/Merge/#testreportmerge-method","text":"Merges the information from the specified test report. public bool Merge(TestReport testReport)","title":"TestReport.Merge method"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/Merge/#return-value","text":"True if merged successfully.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/Merge/#see-also","text":"class TestReport namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/MinExploredFairSteps/","text":"TestReport.MinExploredFairSteps property The min explored scheduling steps in average, in fair tests. public int MinExploredFairSteps { get; } See Also class TestReport namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"MinExploredFairSteps"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/MinExploredFairSteps/#testreportminexploredfairsteps-property","text":"The min explored scheduling steps in average, in fair tests. public int MinExploredFairSteps { get; }","title":"TestReport.MinExploredFairSteps property"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/MinExploredFairSteps/#see-also","text":"class TestReport namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/NumOfExploredFairSchedules/","text":"TestReport.NumOfExploredFairSchedules property Number of explored fair schedules. public int NumOfExploredFairSchedules { get; } See Also class TestReport namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"NumOfExploredFairSchedules"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/NumOfExploredFairSchedules/#testreportnumofexploredfairschedules-property","text":"Number of explored fair schedules. public int NumOfExploredFairSchedules { get; }","title":"TestReport.NumOfExploredFairSchedules property"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/NumOfExploredFairSchedules/#see-also","text":"class TestReport namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/NumOfExploredUnfairSchedules/","text":"TestReport.NumOfExploredUnfairSchedules property Number of explored unfair schedules. public int NumOfExploredUnfairSchedules { get; } See Also class TestReport namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"NumOfExploredUnfairSchedules"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/NumOfExploredUnfairSchedules/#testreportnumofexploredunfairschedules-property","text":"Number of explored unfair schedules. public int NumOfExploredUnfairSchedules { get; }","title":"TestReport.NumOfExploredUnfairSchedules property"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/NumOfExploredUnfairSchedules/#see-also","text":"class TestReport namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/NumOfFoundBugs/","text":"TestReport.NumOfFoundBugs property Number of found bugs. public int NumOfFoundBugs { get; } See Also class TestReport namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"NumOfFoundBugs"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/NumOfFoundBugs/#testreportnumoffoundbugs-property","text":"Number of found bugs. public int NumOfFoundBugs { get; }","title":"TestReport.NumOfFoundBugs property"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/NumOfFoundBugs/#see-also","text":"class TestReport namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/TestReport/","text":"TestReport constructor Initializes a new instance of the TestReport class. public TestReport(Configuration configuration) See Also class TestReport namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"TestReport"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/TestReport/#testreport-constructor","text":"Initializes a new instance of the TestReport class. public TestReport(Configuration configuration)","title":"TestReport constructor"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/TestReport/#see-also","text":"class TestReport namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/TotalExploredFairSteps/","text":"TestReport.TotalExploredFairSteps property The total explored scheduling steps (across all testing iterations), in fair tests. public int TotalExploredFairSteps { get; } See Also class TestReport namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"TotalExploredFairSteps"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/TotalExploredFairSteps/#testreporttotalexploredfairsteps-property","text":"The total explored scheduling steps (across all testing iterations), in fair tests. public int TotalExploredFairSteps { get; }","title":"TestReport.TotalExploredFairSteps property"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestReport/TotalExploredFairSteps/#see-also","text":"class TestReport namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/Create/","text":"TestingEngine.Create method (1 of 10) Creates a new systematic testing engine. public static TestingEngine Create(Configuration configuration) See Also class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test TestingEngine.Create method (2 of 10) Creates a new systematic testing engine. public static TestingEngine Create(Configuration configuration, Action test) See Also class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test TestingEngine.Create method (3 of 10) Creates a new systematic testing engine. public static TestingEngine Create(Configuration configuration, Action<IActorRuntime> test) See Also class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test TestingEngine.Create method (4 of 10) Creates a new systematic testing engine. public static TestingEngine Create(Configuration configuration, Action<ICoyoteRuntime> test) See Also class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test TestingEngine.Create method (5 of 10) Creates a new systematic testing engine. public static TestingEngine Create(Configuration configuration, Func<IActorRuntime, Task> test) See Also class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test TestingEngine.Create method (6 of 10) Creates a new systematic testing engine. public static TestingEngine Create(Configuration configuration, Func<IActorRuntime, Task> test) See Also class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test TestingEngine.Create method (7 of 10) Creates a new systematic testing engine. public static TestingEngine Create(Configuration configuration, Func<ICoyoteRuntime, Task> test) See Also class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test TestingEngine.Create method (8 of 10) Creates a new systematic testing engine. public static TestingEngine Create(Configuration configuration, Func<ICoyoteRuntime, Task> test) See Also class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test TestingEngine.Create method (9 of 10) Creates a new systematic testing engine. public static TestingEngine Create(Configuration configuration, Func<Task> test) See Also class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test TestingEngine.Create method (10 of 10) Creates a new systematic testing engine. public static TestingEngine Create(Configuration configuration, Func<Task> test) See Also class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"Create"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/Create/#testingenginecreate-method-1-of-10","text":"Creates a new systematic testing engine. public static TestingEngine Create(Configuration configuration)","title":"TestingEngine.Create method (1 of 10)"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/Create/#see-also","text":"class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/Create/#testingenginecreate-method-2-of-10","text":"Creates a new systematic testing engine. public static TestingEngine Create(Configuration configuration, Action test)","title":"TestingEngine.Create method (2 of 10)"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/Create/#see-also_1","text":"class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/Create/#testingenginecreate-method-3-of-10","text":"Creates a new systematic testing engine. public static TestingEngine Create(Configuration configuration, Action<IActorRuntime> test)","title":"TestingEngine.Create method (3 of 10)"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/Create/#see-also_2","text":"class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/Create/#testingenginecreate-method-4-of-10","text":"Creates a new systematic testing engine. public static TestingEngine Create(Configuration configuration, Action<ICoyoteRuntime> test)","title":"TestingEngine.Create method (4 of 10)"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/Create/#see-also_3","text":"class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/Create/#testingenginecreate-method-5-of-10","text":"Creates a new systematic testing engine. public static TestingEngine Create(Configuration configuration, Func<IActorRuntime, Task> test)","title":"TestingEngine.Create method (5 of 10)"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/Create/#see-also_4","text":"class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/Create/#testingenginecreate-method-6-of-10","text":"Creates a new systematic testing engine. public static TestingEngine Create(Configuration configuration, Func<IActorRuntime, Task> test)","title":"TestingEngine.Create method (6 of 10)"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/Create/#see-also_5","text":"class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/Create/#testingenginecreate-method-7-of-10","text":"Creates a new systematic testing engine. public static TestingEngine Create(Configuration configuration, Func<ICoyoteRuntime, Task> test)","title":"TestingEngine.Create method (7 of 10)"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/Create/#see-also_6","text":"class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/Create/#testingenginecreate-method-8-of-10","text":"Creates a new systematic testing engine. public static TestingEngine Create(Configuration configuration, Func<ICoyoteRuntime, Task> test)","title":"TestingEngine.Create method (8 of 10)"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/Create/#see-also_7","text":"class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/Create/#testingenginecreate-method-9-of-10","text":"Creates a new systematic testing engine. public static TestingEngine Create(Configuration configuration, Func<Task> test)","title":"TestingEngine.Create method (9 of 10)"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/Create/#see-also_8","text":"class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/Create/#testingenginecreate-method-10-of-10","text":"Creates a new systematic testing engine. public static TestingEngine Create(Configuration configuration, Func<Task> test)","title":"TestingEngine.Create method (10 of 10)"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/Create/#see-also_9","text":"class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/GetReport/","text":"TestingEngine.GetReport method Returns a report with the testing results. public string GetReport() See Also class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"GetReport"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/GetReport/#testingenginegetreport-method","text":"Returns a report with the testing results. public string GetReport()","title":"TestingEngine.GetReport method"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/GetReport/#see-also","text":"class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/IsTestRewritten/","text":"TestingEngine.IsTestRewritten method Checks if the test executed by the testing engine has been rewritten. public bool IsTestRewritten() Return Value True if the test has been rewritten, else false. See Also class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"IsTestRewritten"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/IsTestRewritten/#testingengineistestrewritten-method","text":"Checks if the test executed by the testing engine has been rewritten. public bool IsTestRewritten()","title":"TestingEngine.IsTestRewritten method"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/IsTestRewritten/#return-value","text":"True if the test has been rewritten, else false.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/IsTestRewritten/#see-also","text":"class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/Logger/","text":"TestingEngine.Logger property Get or set the ILogger used to log messages during testing. public ILogger Logger { get; set; } Remarks See Logging for more information. See Also class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"Logger"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/Logger/#testingenginelogger-property","text":"Get or set the ILogger used to log messages during testing. public ILogger Logger { get; set; }","title":"TestingEngine.Logger property"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/Logger/#remarks","text":"See Logging for more information.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/Logger/#see-also","text":"class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/ReadableTrace/","text":"TestingEngine.ReadableTrace property The readable trace, if any. public string ReadableTrace { get; } See Also class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"ReadableTrace"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/ReadableTrace/#testingenginereadabletrace-property","text":"The readable trace, if any. public string ReadableTrace { get; }","title":"TestingEngine.ReadableTrace property"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/ReadableTrace/#see-also","text":"class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/RegisterPerIterationCallBack/","text":"TestingEngine.RegisterPerIterationCallBack method Registers a callback to invoke at the end of each iteration. The callback takes as a parameter an integer representing the current iteration. public void RegisterPerIterationCallBack(Action<uint> callback) See Also class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"RegisterPerIterationCallBack"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/RegisterPerIterationCallBack/#testingengineregisterperiterationcallback-method","text":"Registers a callback to invoke at the end of each iteration. The callback takes as a parameter an integer representing the current iteration. public void RegisterPerIterationCallBack(Action<uint> callback)","title":"TestingEngine.RegisterPerIterationCallBack method"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/RegisterPerIterationCallBack/#see-also","text":"class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/ReproducibleTrace/","text":"TestingEngine.ReproducibleTrace property The reproducable trace, if any. public string ReproducibleTrace { get; } See Also class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"ReproducibleTrace"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/ReproducibleTrace/#testingenginereproducibletrace-property","text":"The reproducable trace, if any. public string ReproducibleTrace { get; }","title":"TestingEngine.ReproducibleTrace property"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/ReproducibleTrace/#see-also","text":"class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/Run/","text":"TestingEngine.Run method Runs the testing engine. public void Run() See Also class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"Run"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/Run/#testingenginerun-method","text":"Runs the testing engine. public void Run()","title":"TestingEngine.Run method"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/Run/#see-also","text":"class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/Stop/","text":"TestingEngine.Stop method Stops the testing engine. public void Stop() See Also class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"Stop"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/Stop/#testingenginestop-method","text":"Stops the testing engine. public void Stop()","title":"TestingEngine.Stop method"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/Stop/#see-also","text":"class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/TestReport/","text":"TestingEngine.TestReport property Data structure containing information gathered during testing. public TestReport TestReport { get; set; } See Also class TestReport class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"TestReport"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/TestReport/#testingenginetestreport-property","text":"Data structure containing information gathered during testing. public TestReport TestReport { get; set; }","title":"TestingEngine.TestReport property"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/TestReport/#see-also","text":"class TestReport class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/ThrowIfBugFound/","text":"TestingEngine.ThrowIfBugFound method Throws either an AssertionFailureException, if a bug was found, or an unhandled Exception, if one was thrown. public void ThrowIfBugFound() See Also class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"ThrowIfBugFound"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/ThrowIfBugFound/#testingenginethrowifbugfound-method","text":"Throws either an AssertionFailureException, if a bug was found, or an unhandled Exception, if one was thrown. public void ThrowIfBugFound()","title":"TestingEngine.ThrowIfBugFound method"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/ThrowIfBugFound/#see-also","text":"class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/TryEmitTraces/","text":"TestingEngine.TryEmitTraces method Tries to emit the testing traces, if any. public IEnumerable<string> TryEmitTraces(string directory, string file) See Also class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"TryEmitTraces"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/TryEmitTraces/#testingenginetryemittraces-method","text":"Tries to emit the testing traces, if any. public IEnumerable<string> TryEmitTraces(string directory, string file)","title":"TestingEngine.TryEmitTraces method"},{"location":"ref/Microsoft.Coyote.SystematicTesting/TestingEngine/TryEmitTraces/#see-also","text":"class TestingEngine namespace Microsoft.Coyote.SystematicTesting assembly Microsoft.Coyote.Test","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/AsyncLock.Releaser/","text":"AsyncLock.Releaser structure Releases the acquired AsyncLock when disposed. public struct Releaser : IDisposable Public Members name description Dispose () Releases the acquired lock. See Also class AsyncLock namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Tasks/AsyncLock.Releaser/#asynclockreleaser-structure","text":"Releases the acquired AsyncLock when disposed. public struct Releaser : IDisposable","title":"AsyncLock.Releaser structure"},{"location":"ref/Microsoft.Coyote.Tasks/AsyncLock.Releaser/#public-members","text":"name description Dispose () Releases the acquired lock.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Tasks/AsyncLock.Releaser/#see-also","text":"class AsyncLock namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/AsyncLock/","text":"AsyncLock class A non-reentrant mutual exclusion lock that can be acquired asynchronously in a first-in first-out order. During testing, the lock is automatically replaced with a controlled mocked version. public class AsyncLock Public Members name description static Create () Creates a new mutual exclusion lock. virtual AcquireAsync () Tries to acquire the lock asynchronously, and returns a task that completes when the lock has been acquired. The returned task contains a releaser that releases the lock when disposed. This is not a reentrant operation. struct Releaser Releases the acquired AsyncLock when disposed. Protected Members name description AsyncLock () Initializes a new instance of the AsyncLock class. IsAcquired { get; set; } True if the lock has been acquired, else false. readonly Awaiters Queue of tasks awaiting to acquire the lock. virtual Release () Releases the lock. See Also namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Tasks/AsyncLock/#asynclock-class","text":"A non-reentrant mutual exclusion lock that can be acquired asynchronously in a first-in first-out order. During testing, the lock is automatically replaced with a controlled mocked version. public class AsyncLock","title":"AsyncLock class"},{"location":"ref/Microsoft.Coyote.Tasks/AsyncLock/#public-members","text":"name description static Create () Creates a new mutual exclusion lock. virtual AcquireAsync () Tries to acquire the lock asynchronously, and returns a task that completes when the lock has been acquired. The returned task contains a releaser that releases the lock when disposed. This is not a reentrant operation. struct Releaser Releases the acquired AsyncLock when disposed.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Tasks/AsyncLock/#protected-members","text":"name description AsyncLock () Initializes a new instance of the AsyncLock class. IsAcquired { get; set; } True if the lock has been acquired, else false. readonly Awaiters Queue of tasks awaiting to acquire the lock. virtual Release () Releases the lock.","title":"Protected Members"},{"location":"ref/Microsoft.Coyote.Tasks/AsyncLock/#see-also","text":"namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/","text":"Semaphore class A semaphore that limits the number of tasks that can access a resource. During testing, the semaphore is automatically replaced with a controlled mocked version. public class Semaphore : IDisposable Public Members name description static Create (\u2026) Creates a new semaphore. virtual CurrentCount { get; } Number of remaining tasks that can enter the semaphore. Dispose () Releases resources used by the semaphore. virtual Release () Releases the semaphore. virtual Wait () Blocks the current task until it can enter the semaphore. virtual Wait (\u2026) Blocks the current task until it can enter the semaphore, using a TimeSpan that specifies the timeout. (5 methods) virtual WaitAsync () Asynchronously waits to enter the semaphore. virtual WaitAsync (\u2026) Asynchronously waits to enter the semaphore, using a TimeSpan that specifies the timeout. (5 methods) Protected Members name description Semaphore (\u2026) Initializes a new instance of the Semaphore class. See Also namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/#semaphore-class","text":"A semaphore that limits the number of tasks that can access a resource. During testing, the semaphore is automatically replaced with a controlled mocked version. public class Semaphore : IDisposable","title":"Semaphore class"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/#public-members","text":"name description static Create (\u2026) Creates a new semaphore. virtual CurrentCount { get; } Number of remaining tasks that can enter the semaphore. Dispose () Releases resources used by the semaphore. virtual Release () Releases the semaphore. virtual Wait () Blocks the current task until it can enter the semaphore. virtual Wait (\u2026) Blocks the current task until it can enter the semaphore, using a TimeSpan that specifies the timeout. (5 methods) virtual WaitAsync () Asynchronously waits to enter the semaphore. virtual WaitAsync (\u2026) Asynchronously waits to enter the semaphore, using a TimeSpan that specifies the timeout. (5 methods)","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/#protected-members","text":"name description Semaphore (\u2026) Initializes a new instance of the Semaphore class.","title":"Protected Members"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/#see-also","text":"namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/","text":"SynchronizedBlock class Provides a mechanism that synchronizes access to objects. It is implemented as a thin wrapper on Monitor. During testing, the implementation is automatically replaced with a controlled mocked version. It can be used as a replacement of the lock keyword to allow systematic testing. public class SynchronizedBlock : IDisposable Public Members name description static Lock (\u2026) Creates a new SynchronizedBlock for synchronizing access to the specified object and enters the lock. Dispose () Releases resources used by the synchronized block. virtual Pulse () Notifies a thread in the waiting queue of a change in the locked object\u2019s state. virtual PulseAll () Notifies all waiting threads of a change in the object\u2019s state. virtual Wait () Releases the lock on an object and blocks the current thread until it reacquires the lock. virtual Wait (\u2026) Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. (2 methods) Protected Members name description SynchronizedBlock (\u2026) Initializes a new instance of the SynchronizedBlock class. readonly SyncObject The object used for synchronization. virtual Dispose (\u2026) Releases resources used by the synchronized block. virtual EnterLock () Enters the lock. See Also namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/#synchronizedblock-class","text":"Provides a mechanism that synchronizes access to objects. It is implemented as a thin wrapper on Monitor. During testing, the implementation is automatically replaced with a controlled mocked version. It can be used as a replacement of the lock keyword to allow systematic testing. public class SynchronizedBlock : IDisposable","title":"SynchronizedBlock class"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/#public-members","text":"name description static Lock (\u2026) Creates a new SynchronizedBlock for synchronizing access to the specified object and enters the lock. Dispose () Releases resources used by the synchronized block. virtual Pulse () Notifies a thread in the waiting queue of a change in the locked object\u2019s state. virtual PulseAll () Notifies all waiting threads of a change in the object\u2019s state. virtual Wait () Releases the lock on an object and blocks the current thread until it reacquires the lock. virtual Wait (\u2026) Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. (2 methods)","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/#protected-members","text":"name description SynchronizedBlock (\u2026) Initializes a new instance of the SynchronizedBlock class. readonly SyncObject The object used for synchronization. virtual Dispose (\u2026) Releases resources used by the synchronized block. virtual EnterLock () Enters the lock.","title":"Protected Members"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/#see-also","text":"namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task-1/","text":"Task<TResult> class Represents an asynchronous operation that can return a value. Each Task is a thin wrapper over Task and each call simply invokes the wrapped task. During testing, a Task is controlled by the runtime and systematically interleaved with other asynchronous operations to find bugs. public class Task<TResult> : Task parameter description TResult The type of the produced result. Public Members name description Result { get; } Gets the result value of this task. UncontrolledTask { get; } The uncontrolled Task that is wrapped inside this controlled Task . ConfigureAwait (\u2026) Configures an awaiter used to await this task. GetAwaiter () Gets an awaiter for this awaitable. See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Tasks/Task-1/#tasktresult-class","text":"Represents an asynchronous operation that can return a value. Each Task is a thin wrapper over Task and each call simply invokes the wrapped task. During testing, a Task is controlled by the runtime and systematically interleaved with other asynchronous operations to find bugs. public class Task<TResult> : Task parameter description TResult The type of the produced result.","title":"Task&lt;TResult&gt; class"},{"location":"ref/Microsoft.Coyote.Tasks/Task-1/#public-members","text":"name description Result { get; } Gets the result value of this task. UncontrolledTask { get; } The uncontrolled Task that is wrapped inside this controlled Task . ConfigureAwait (\u2026) Configures an awaiter used to await this task. GetAwaiter () Gets an awaiter for this awaitable.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Tasks/Task-1/#see-also","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/","text":"Task class Represents an asynchronous operation. Each Task is a thin wrapper over Task and each call simply invokes the wrapped task. During testing, a Task is controlled by the runtime and systematically interleaved with other asynchronous operations to find bugs. public class Task : IDisposable Public Members name description static CompletedTask { get; } A Task that has completed successfully. static Delay (\u2026) Creates a Task that completes after a time delay. (4 methods) static FromCanceled (\u2026) Creates a Task that is completed due to cancellation with a specified cancellation token. static FromException (\u2026) Creates a Task that is completed with a specified exception. static Run (\u2026) Queues the specified work to run on the thread pool and returns a Task object that represents that work. A cancellation token allows the work to be cancelled. (4 methods) static WhenAll (\u2026) Creates a Task that will complete when all tasks in the specified array have completed. (2 methods) Exception { get; } Gets the AggregateException that caused the task to end prematurely. If the task completed successfully or has not yet thrown any exceptions, this will return null. Id { get; } The id of this task. IsCanceled { get; } Value that indicates whether the task completed execution due to being canceled. IsCompleted { get; } Value that indicates whether the task has completed. IsFaulted { get; } Value that indicates whether the task completed due to an unhandled exception. Status { get; } The status of this task. UncontrolledTask { get; } The uncontrolled Task that is wrapped inside this controlled Task . ConfigureAwait (\u2026) Configures an awaiter used to await this task. Dispose () Disposes the Task , releasing all of its unmanaged resources. GetAwaiter () Gets an awaiter for this awaitable. Wait () Waits for the task to complete execution. Wait (\u2026) Waits for the task to complete execution within a specified time interval. (4 methods) static CurrentId { get; } Returns the id of the currently executing Task . static ExploreContextSwitch () Injects a context switch point that can be systematically explored during testing. static FromCanceled<TResult> (\u2026) Creates a Task that is completed due to cancellation with a specified cancellation token. static FromException<TResult> (\u2026) Creates a Task that is completed with a specified exception. static FromResult<TResult> (\u2026) Creates a Task that is completed successfully with the specified result. static Run<TResult> (\u2026) Queues the specified work to run on the thread pool and returns a proxy for the Task returned by the function. (4 methods) static WaitAll (\u2026) Waits for all of the provided Task objects to complete execution. (5 methods) static WaitAny (\u2026) Waits for any of the provided Task objects to complete execution. (5 methods) static WhenAll<TResult> (\u2026) Creates a Task that will complete when all tasks in the specified array have completed. (2 methods) static WhenAny (\u2026) Creates a Task that will complete when any task in the specified array have completed. (2 methods) static WhenAny<TResult> (\u2026) Creates a Task that will complete when any task in the specified array have completed. (2 methods) static Yield () Creates an awaitable that asynchronously yields back to the current context when awaited. Protected Members name description virtual Dispose (\u2026) Disposes the Task , releasing all of its unmanaged resources. Remarks See Programming model: asynchronous tasks for more information. See Also namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Tasks/Task/#task-class","text":"Represents an asynchronous operation. Each Task is a thin wrapper over Task and each call simply invokes the wrapped task. During testing, a Task is controlled by the runtime and systematically interleaved with other asynchronous operations to find bugs. public class Task : IDisposable","title":"Task class"},{"location":"ref/Microsoft.Coyote.Tasks/Task/#public-members","text":"name description static CompletedTask { get; } A Task that has completed successfully. static Delay (\u2026) Creates a Task that completes after a time delay. (4 methods) static FromCanceled (\u2026) Creates a Task that is completed due to cancellation with a specified cancellation token. static FromException (\u2026) Creates a Task that is completed with a specified exception. static Run (\u2026) Queues the specified work to run on the thread pool and returns a Task object that represents that work. A cancellation token allows the work to be cancelled. (4 methods) static WhenAll (\u2026) Creates a Task that will complete when all tasks in the specified array have completed. (2 methods) Exception { get; } Gets the AggregateException that caused the task to end prematurely. If the task completed successfully or has not yet thrown any exceptions, this will return null. Id { get; } The id of this task. IsCanceled { get; } Value that indicates whether the task completed execution due to being canceled. IsCompleted { get; } Value that indicates whether the task has completed. IsFaulted { get; } Value that indicates whether the task completed due to an unhandled exception. Status { get; } The status of this task. UncontrolledTask { get; } The uncontrolled Task that is wrapped inside this controlled Task . ConfigureAwait (\u2026) Configures an awaiter used to await this task. Dispose () Disposes the Task , releasing all of its unmanaged resources. GetAwaiter () Gets an awaiter for this awaitable. Wait () Waits for the task to complete execution. Wait (\u2026) Waits for the task to complete execution within a specified time interval. (4 methods) static CurrentId { get; } Returns the id of the currently executing Task . static ExploreContextSwitch () Injects a context switch point that can be systematically explored during testing. static FromCanceled<TResult> (\u2026) Creates a Task that is completed due to cancellation with a specified cancellation token. static FromException<TResult> (\u2026) Creates a Task that is completed with a specified exception. static FromResult<TResult> (\u2026) Creates a Task that is completed successfully with the specified result. static Run<TResult> (\u2026) Queues the specified work to run on the thread pool and returns a proxy for the Task returned by the function. (4 methods) static WaitAll (\u2026) Waits for all of the provided Task objects to complete execution. (5 methods) static WaitAny (\u2026) Waits for any of the provided Task objects to complete execution. (5 methods) static WhenAll<TResult> (\u2026) Creates a Task that will complete when all tasks in the specified array have completed. (2 methods) static WhenAny (\u2026) Creates a Task that will complete when any task in the specified array have completed. (2 methods) static WhenAny<TResult> (\u2026) Creates a Task that will complete when any task in the specified array have completed. (2 methods) static Yield () Creates an awaitable that asynchronously yields back to the current context when awaited.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Tasks/Task/#protected-members","text":"name description virtual Dispose (\u2026) Disposes the Task , releasing all of its unmanaged resources.","title":"Protected Members"},{"location":"ref/Microsoft.Coyote.Tasks/Task/#remarks","text":"See Programming model: asynchronous tasks for more information.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Tasks/Task/#see-also","text":"namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource-1/","text":"TaskCompletionSource<TResult> class Represents the producer side of a task unbound to a delegate, providing access to the consumer side through the Task property. public class TaskCompletionSource<TResult> parameter description TResult The type of the result value assocatied with this task completion source. Public Members name description virtual Task { get; } Gets the task created by this task completion source. virtual SetCanceled () Transitions the underlying task into the Canceled state. virtual SetException (\u2026) Transitions the underlying task into the Faulted state and binds it to the specified exception. virtual SetResult (\u2026) Transitions the underlying task into the RanToCompletion state. virtual TrySetCanceled () Attempts to transition the underlying task into the Canceled state. virtual TrySetException (\u2026) Attempts to transition the underlying task into the Faulted state and binds it to the specified exception. virtual TrySetResult (\u2026) Attempts to transition the underlying task into the RanToCompletion state. See Also namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource-1/#taskcompletionsourcetresult-class","text":"Represents the producer side of a task unbound to a delegate, providing access to the consumer side through the Task property. public class TaskCompletionSource<TResult> parameter description TResult The type of the result value assocatied with this task completion source.","title":"TaskCompletionSource&lt;TResult&gt; class"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource-1/#public-members","text":"name description virtual Task { get; } Gets the task created by this task completion source. virtual SetCanceled () Transitions the underlying task into the Canceled state. virtual SetException (\u2026) Transitions the underlying task into the Faulted state and binds it to the specified exception. virtual SetResult (\u2026) Transitions the underlying task into the RanToCompletion state. virtual TrySetCanceled () Attempts to transition the underlying task into the Canceled state. virtual TrySetException (\u2026) Attempts to transition the underlying task into the Faulted state and binds it to the specified exception. virtual TrySetResult (\u2026) Attempts to transition the underlying task into the RanToCompletion state.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource-1/#see-also","text":"namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource/","text":"TaskCompletionSource class Represents the producer side of a task unbound to a delegate, providing access to the consumer side through the Task property. public static class TaskCompletionSource Public Members name description static Create<TResult> () Creates a new TaskCompletionSource instance. See Also namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource/#taskcompletionsource-class","text":"Represents the producer side of a task unbound to a delegate, providing access to the consumer side through the Task property. public static class TaskCompletionSource","title":"TaskCompletionSource class"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource/#public-members","text":"name description static Create<TResult> () Creates a new TaskCompletionSource instance.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource/#see-also","text":"namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/TaskExtensions/","text":"TaskExtensions class Extension methods for Task and Task objects. public static class TaskExtensions Public Members name description static WrapInControlledTask (\u2026) Returns a dummy controlled Task that wraps this uncontrolled Task. static WrapInControlledTask<TResult> (\u2026) Returns a dummy controlled Task that wraps this uncontrolled Task. See Also namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"Overview"},{"location":"ref/Microsoft.Coyote.Tasks/TaskExtensions/#taskextensions-class","text":"Extension methods for Task and Task objects. public static class TaskExtensions","title":"TaskExtensions class"},{"location":"ref/Microsoft.Coyote.Tasks/TaskExtensions/#public-members","text":"name description static WrapInControlledTask (\u2026) Returns a dummy controlled Task that wraps this uncontrolled Task. static WrapInControlledTask<TResult> (\u2026) Returns a dummy controlled Task that wraps this uncontrolled Task.","title":"Public Members"},{"location":"ref/Microsoft.Coyote.Tasks/TaskExtensions/#see-also","text":"namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/AsyncLock/AcquireAsync/","text":"AsyncLock.AcquireAsync method Tries to acquire the lock asynchronously, and returns a task that completes when the lock has been acquired. The returned task contains a releaser that releases the lock when disposed. This is not a reentrant operation. public virtual Task<Releaser> AcquireAsync() See Also class Task<TResult> struct Releaser class AsyncLock namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"AcquireAsync"},{"location":"ref/Microsoft.Coyote.Tasks/AsyncLock/AcquireAsync/#asynclockacquireasync-method","text":"Tries to acquire the lock asynchronously, and returns a task that completes when the lock has been acquired. The returned task contains a releaser that releases the lock when disposed. This is not a reentrant operation. public virtual Task<Releaser> AcquireAsync()","title":"AsyncLock.AcquireAsync method"},{"location":"ref/Microsoft.Coyote.Tasks/AsyncLock/AcquireAsync/#see-also","text":"class Task<TResult> struct Releaser class AsyncLock namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/AsyncLock/AsyncLock/","text":"AsyncLock constructor Initializes a new instance of the AsyncLock class. protected AsyncLock() See Also class AsyncLock namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"AsyncLock"},{"location":"ref/Microsoft.Coyote.Tasks/AsyncLock/AsyncLock/#asynclock-constructor","text":"Initializes a new instance of the AsyncLock class. protected AsyncLock()","title":"AsyncLock constructor"},{"location":"ref/Microsoft.Coyote.Tasks/AsyncLock/AsyncLock/#see-also","text":"class AsyncLock namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/AsyncLock/Awaiters/","text":"AsyncLock.Awaiters field Queue of tasks awaiting to acquire the lock. protected readonly Queue<TaskCompletionSource<object>> Awaiters; See Also class AsyncLock namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"Awaiters"},{"location":"ref/Microsoft.Coyote.Tasks/AsyncLock/Awaiters/#asynclockawaiters-field","text":"Queue of tasks awaiting to acquire the lock. protected readonly Queue<TaskCompletionSource<object>> Awaiters;","title":"AsyncLock.Awaiters field"},{"location":"ref/Microsoft.Coyote.Tasks/AsyncLock/Awaiters/#see-also","text":"class AsyncLock namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/AsyncLock/Create/","text":"AsyncLock.Create method Creates a new mutual exclusion lock. public static AsyncLock Create() Return Value The asynchronous mutual exclusion lock. See Also class AsyncLock namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"Create"},{"location":"ref/Microsoft.Coyote.Tasks/AsyncLock/Create/#asynclockcreate-method","text":"Creates a new mutual exclusion lock. public static AsyncLock Create()","title":"AsyncLock.Create method"},{"location":"ref/Microsoft.Coyote.Tasks/AsyncLock/Create/#return-value","text":"The asynchronous mutual exclusion lock.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/AsyncLock/Create/#see-also","text":"class AsyncLock namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/AsyncLock/IsAcquired/","text":"AsyncLock.IsAcquired property True if the lock has been acquired, else false. protected internal bool IsAcquired { get; set; } See Also class AsyncLock namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"IsAcquired"},{"location":"ref/Microsoft.Coyote.Tasks/AsyncLock/IsAcquired/#asynclockisacquired-property","text":"True if the lock has been acquired, else false. protected internal bool IsAcquired { get; set; }","title":"AsyncLock.IsAcquired property"},{"location":"ref/Microsoft.Coyote.Tasks/AsyncLock/IsAcquired/#see-also","text":"class AsyncLock namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/AsyncLock/Release/","text":"AsyncLock.Release method Releases the lock. protected virtual void Release() See Also class AsyncLock namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"Release"},{"location":"ref/Microsoft.Coyote.Tasks/AsyncLock/Release/#asynclockrelease-method","text":"Releases the lock. protected virtual void Release()","title":"AsyncLock.Release method"},{"location":"ref/Microsoft.Coyote.Tasks/AsyncLock/Release/#see-also","text":"class AsyncLock namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/AsyncLock.Releaser/Dispose/","text":"AsyncLock.Releaser.Dispose method Releases the acquired lock. public void Dispose() See Also struct Releaser namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"Dispose"},{"location":"ref/Microsoft.Coyote.Tasks/AsyncLock.Releaser/Dispose/#asynclockreleaserdispose-method","text":"Releases the acquired lock. public void Dispose()","title":"AsyncLock.Releaser.Dispose method"},{"location":"ref/Microsoft.Coyote.Tasks/AsyncLock.Releaser/Dispose/#see-also","text":"struct Releaser namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/Create/","text":"Semaphore.Create method Creates a new semaphore. public static Semaphore Create(int initialCount, int maxCount) Return Value The semaphore. See Also class Semaphore namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"Create"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/Create/#semaphorecreate-method","text":"Creates a new semaphore. public static Semaphore Create(int initialCount, int maxCount)","title":"Semaphore.Create method"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/Create/#return-value","text":"The semaphore.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/Create/#see-also","text":"class Semaphore namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/CurrentCount/","text":"Semaphore.CurrentCount property Number of remaining tasks that can enter the semaphore. public virtual int CurrentCount { get; } See Also class Semaphore namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"CurrentCount"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/CurrentCount/#semaphorecurrentcount-property","text":"Number of remaining tasks that can enter the semaphore. public virtual int CurrentCount { get; }","title":"Semaphore.CurrentCount property"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/CurrentCount/#see-also","text":"class Semaphore namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/Dispose/","text":"Semaphore.Dispose method Releases resources used by the semaphore. public void Dispose() See Also class Semaphore namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"Dispose"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/Dispose/#semaphoredispose-method","text":"Releases resources used by the semaphore. public void Dispose()","title":"Semaphore.Dispose method"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/Dispose/#see-also","text":"class Semaphore namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/Release/","text":"Semaphore.Release method Releases the semaphore. public virtual void Release() See Also class Semaphore namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"Release"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/Release/#semaphorerelease-method","text":"Releases the semaphore. public virtual void Release()","title":"Semaphore.Release method"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/Release/#see-also","text":"class Semaphore namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/Semaphore/","text":"Semaphore constructor Initializes a new instance of the Semaphore class. protected Semaphore(SemaphoreSlim semaphore) See Also class Semaphore namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"Semaphore"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/Semaphore/#semaphore-constructor","text":"Initializes a new instance of the Semaphore class. protected Semaphore(SemaphoreSlim semaphore)","title":"Semaphore constructor"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/Semaphore/#see-also","text":"class Semaphore namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/Wait/","text":"Semaphore.Wait method (1 of 6) Blocks the current task until it can enter the semaphore. public virtual void Wait() See Also class Semaphore namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Semaphore.Wait method (2 of 6) Blocks the current task until it can enter the semaphore, while observing a CancellationToken. public virtual void Wait(CancellationToken cancellationToken) parameter description cancellationToken The CancellationToken to observe. See Also class Semaphore namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Semaphore.Wait method (3 of 6) Blocks the current task until it can enter the semaphore, using a 32-bit signed integer that specifies the timeout. public virtual bool Wait(int millisecondsTimeout) parameter description millisecondsTimeout The number of milliseconds to wait, Infinite (-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately. Return Value True if the current task successfully entered the semaphore, else false. See Also class Semaphore namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Semaphore.Wait method (4 of 6) Blocks the current task until it can enter the semaphore, using a TimeSpan that specifies the timeout. public virtual bool Wait(TimeSpan timeout) parameter description timeout A TimeSpan that represents the number of milliseconds to wait, a TimeSpan that represents -1 milliseconds to wait indefinitely, or a TimeSpan that represents 0 milliseconds to test the wait handle and return immediately. Return Value True if the current task successfully entered the semaphore, else false. See Also class Semaphore namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Semaphore.Wait method (5 of 6) Blocks the current task until it can enter the semaphore, using a 32-bit signed integer that specifies the timeout, while observing a CancellationToken. public virtual bool Wait(int millisecondsTimeout, CancellationToken cancellationToken) parameter description millisecondsTimeout The number of milliseconds to wait, Infinite (-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately. cancellationToken The CancellationToken to observe. Return Value True if the current task successfully entered the semaphore, else false. See Also class Semaphore namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Semaphore.Wait method (6 of 6) Blocks the current task until it can enter the semaphore, using a TimeSpan that specifies the timeout, while observing a CancellationToken. public virtual bool Wait(TimeSpan timeout, CancellationToken cancellationToken) parameter description timeout A TimeSpan that represents the number of milliseconds to wait, a TimeSpan that represents -1 milliseconds to wait indefinitely, or a TimeSpan that represents 0 milliseconds to test the wait handle and return immediately. cancellationToken The CancellationToken to observe. Return Value True if the current task successfully entered the semaphore, else false. See Also class Semaphore namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"Wait"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/Wait/#semaphorewait-method-1-of-6","text":"Blocks the current task until it can enter the semaphore. public virtual void Wait()","title":"Semaphore.Wait method (1 of 6)"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/Wait/#see-also","text":"class Semaphore namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/Wait/#semaphorewait-method-2-of-6","text":"Blocks the current task until it can enter the semaphore, while observing a CancellationToken. public virtual void Wait(CancellationToken cancellationToken) parameter description cancellationToken The CancellationToken to observe.","title":"Semaphore.Wait method (2 of 6)"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/Wait/#see-also_1","text":"class Semaphore namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/Wait/#semaphorewait-method-3-of-6","text":"Blocks the current task until it can enter the semaphore, using a 32-bit signed integer that specifies the timeout. public virtual bool Wait(int millisecondsTimeout) parameter description millisecondsTimeout The number of milliseconds to wait, Infinite (-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.","title":"Semaphore.Wait method (3 of 6)"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/Wait/#return-value","text":"True if the current task successfully entered the semaphore, else false.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/Wait/#see-also_2","text":"class Semaphore namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/Wait/#semaphorewait-method-4-of-6","text":"Blocks the current task until it can enter the semaphore, using a TimeSpan that specifies the timeout. public virtual bool Wait(TimeSpan timeout) parameter description timeout A TimeSpan that represents the number of milliseconds to wait, a TimeSpan that represents -1 milliseconds to wait indefinitely, or a TimeSpan that represents 0 milliseconds to test the wait handle and return immediately.","title":"Semaphore.Wait method (4 of 6)"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/Wait/#return-value_1","text":"True if the current task successfully entered the semaphore, else false.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/Wait/#see-also_3","text":"class Semaphore namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/Wait/#semaphorewait-method-5-of-6","text":"Blocks the current task until it can enter the semaphore, using a 32-bit signed integer that specifies the timeout, while observing a CancellationToken. public virtual bool Wait(int millisecondsTimeout, CancellationToken cancellationToken) parameter description millisecondsTimeout The number of milliseconds to wait, Infinite (-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately. cancellationToken The CancellationToken to observe.","title":"Semaphore.Wait method (5 of 6)"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/Wait/#return-value_2","text":"True if the current task successfully entered the semaphore, else false.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/Wait/#see-also_4","text":"class Semaphore namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/Wait/#semaphorewait-method-6-of-6","text":"Blocks the current task until it can enter the semaphore, using a TimeSpan that specifies the timeout, while observing a CancellationToken. public virtual bool Wait(TimeSpan timeout, CancellationToken cancellationToken) parameter description timeout A TimeSpan that represents the number of milliseconds to wait, a TimeSpan that represents -1 milliseconds to wait indefinitely, or a TimeSpan that represents 0 milliseconds to test the wait handle and return immediately. cancellationToken The CancellationToken to observe.","title":"Semaphore.Wait method (6 of 6)"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/Wait/#return-value_3","text":"True if the current task successfully entered the semaphore, else false.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/Wait/#see-also_5","text":"class Semaphore namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/WaitAsync/","text":"Semaphore.WaitAsync method (1 of 6) Asynchronously waits to enter the semaphore. public virtual Task WaitAsync() Return Value A task that will complete when the semaphore has been entered. See Also class Task class Semaphore namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Semaphore.WaitAsync method (2 of 6) Asynchronously waits to enter the semaphore, while observing a CancellationToken. public virtual Task WaitAsync(CancellationToken cancellationToken) parameter description cancellationToken The CancellationToken to observe. Return Value A task that will complete when the semaphore has been entered. See Also class Task class Semaphore namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Semaphore.WaitAsync method (3 of 6) Asynchronously waits to enter the semaphore, using a 32-bit signed integer that specifies the timeout. public virtual Task<bool> WaitAsync(int millisecondsTimeout) parameter description millisecondsTimeout The number of milliseconds to wait, Infinite (-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately. Return Value A task that will complete with a result of true if the current thread successfully entered the semaphore, otherwise with a result of false. See Also class Task<TResult> class Semaphore namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Semaphore.WaitAsync method (4 of 6) Asynchronously waits to enter the semaphore, using a TimeSpan that specifies the timeout. public virtual Task<bool> WaitAsync(TimeSpan timeout) parameter description timeout A TimeSpan that represents the number of milliseconds to wait, a TimeSpan that represents -1 milliseconds to wait indefinitely, or a TimeSpan that represents 0 milliseconds to test the wait handle and return immediately. Return Value A task that will complete with a result of true if the current thread successfully entered the semaphore, otherwise with a result of false. See Also class Task<TResult> class Semaphore namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Semaphore.WaitAsync method (5 of 6) Asynchronously waits to enter the semaphore, using a 32-bit signed integer that specifies the timeout, while observing a CancellationToken. public virtual Task<bool> WaitAsync(int millisecondsTimeout, CancellationToken cancellationToken) parameter description millisecondsTimeout The number of milliseconds to wait, Infinite (-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately. cancellationToken The CancellationToken to observe. Return Value A task that will complete with a result of true if the current thread successfully entered the semaphore, otherwise with a result of false. See Also class Task<TResult> class Semaphore namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Semaphore.WaitAsync method (6 of 6) Asynchronously waits to enter the semaphore, using a TimeSpan that specifies the timeout, while observing a CancellationToken. public virtual Task<bool> WaitAsync(TimeSpan timeout, CancellationToken cancellationToken) parameter description timeout A TimeSpan that represents the number of milliseconds to wait, a TimeSpan that represents -1 milliseconds to wait indefinitely, or a TimeSpan that represents 0 milliseconds to test the wait handle and return immediately. cancellationToken The CancellationToken to observe. Return Value A task that will complete with a result of true if the current thread successfully entered the semaphore, otherwise with a result of false. See Also class Task<TResult> class Semaphore namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"WaitAsync"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/WaitAsync/#semaphorewaitasync-method-1-of-6","text":"Asynchronously waits to enter the semaphore. public virtual Task WaitAsync()","title":"Semaphore.WaitAsync method (1 of 6)"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/WaitAsync/#return-value","text":"A task that will complete when the semaphore has been entered.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/WaitAsync/#see-also","text":"class Task class Semaphore namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/WaitAsync/#semaphorewaitasync-method-2-of-6","text":"Asynchronously waits to enter the semaphore, while observing a CancellationToken. public virtual Task WaitAsync(CancellationToken cancellationToken) parameter description cancellationToken The CancellationToken to observe.","title":"Semaphore.WaitAsync method (2 of 6)"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/WaitAsync/#return-value_1","text":"A task that will complete when the semaphore has been entered.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/WaitAsync/#see-also_1","text":"class Task class Semaphore namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/WaitAsync/#semaphorewaitasync-method-3-of-6","text":"Asynchronously waits to enter the semaphore, using a 32-bit signed integer that specifies the timeout. public virtual Task<bool> WaitAsync(int millisecondsTimeout) parameter description millisecondsTimeout The number of milliseconds to wait, Infinite (-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.","title":"Semaphore.WaitAsync method (3 of 6)"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/WaitAsync/#return-value_2","text":"A task that will complete with a result of true if the current thread successfully entered the semaphore, otherwise with a result of false.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/WaitAsync/#see-also_2","text":"class Task<TResult> class Semaphore namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/WaitAsync/#semaphorewaitasync-method-4-of-6","text":"Asynchronously waits to enter the semaphore, using a TimeSpan that specifies the timeout. public virtual Task<bool> WaitAsync(TimeSpan timeout) parameter description timeout A TimeSpan that represents the number of milliseconds to wait, a TimeSpan that represents -1 milliseconds to wait indefinitely, or a TimeSpan that represents 0 milliseconds to test the wait handle and return immediately.","title":"Semaphore.WaitAsync method (4 of 6)"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/WaitAsync/#return-value_3","text":"A task that will complete with a result of true if the current thread successfully entered the semaphore, otherwise with a result of false.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/WaitAsync/#see-also_3","text":"class Task<TResult> class Semaphore namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/WaitAsync/#semaphorewaitasync-method-5-of-6","text":"Asynchronously waits to enter the semaphore, using a 32-bit signed integer that specifies the timeout, while observing a CancellationToken. public virtual Task<bool> WaitAsync(int millisecondsTimeout, CancellationToken cancellationToken) parameter description millisecondsTimeout The number of milliseconds to wait, Infinite (-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately. cancellationToken The CancellationToken to observe.","title":"Semaphore.WaitAsync method (5 of 6)"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/WaitAsync/#return-value_4","text":"A task that will complete with a result of true if the current thread successfully entered the semaphore, otherwise with a result of false.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/WaitAsync/#see-also_4","text":"class Task<TResult> class Semaphore namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/WaitAsync/#semaphorewaitasync-method-6-of-6","text":"Asynchronously waits to enter the semaphore, using a TimeSpan that specifies the timeout, while observing a CancellationToken. public virtual Task<bool> WaitAsync(TimeSpan timeout, CancellationToken cancellationToken) parameter description timeout A TimeSpan that represents the number of milliseconds to wait, a TimeSpan that represents -1 milliseconds to wait indefinitely, or a TimeSpan that represents 0 milliseconds to test the wait handle and return immediately. cancellationToken The CancellationToken to observe.","title":"Semaphore.WaitAsync method (6 of 6)"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/WaitAsync/#return-value_5","text":"A task that will complete with a result of true if the current thread successfully entered the semaphore, otherwise with a result of false.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Semaphore/WaitAsync/#see-also_5","text":"class Task<TResult> class Semaphore namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/Dispose/","text":"SynchronizedBlock.Dispose method (1 of 2) Releases resources used by the synchronized block. public void Dispose() See Also class SynchronizedBlock namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote SynchronizedBlock.Dispose method (2 of 2) Releases resources used by the synchronized block. protected virtual void Dispose(bool disposing) See Also class SynchronizedBlock namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"Dispose"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/Dispose/#synchronizedblockdispose-method-1-of-2","text":"Releases resources used by the synchronized block. public void Dispose()","title":"SynchronizedBlock.Dispose method (1 of 2)"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/Dispose/#see-also","text":"class SynchronizedBlock namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/Dispose/#synchronizedblockdispose-method-2-of-2","text":"Releases resources used by the synchronized block. protected virtual void Dispose(bool disposing)","title":"SynchronizedBlock.Dispose method (2 of 2)"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/Dispose/#see-also_1","text":"class SynchronizedBlock namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/EnterLock/","text":"SynchronizedBlock.EnterLock method Enters the lock. protected virtual SynchronizedBlock EnterLock() Return Value The synchronized block. See Also class SynchronizedBlock namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"EnterLock"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/EnterLock/#synchronizedblockenterlock-method","text":"Enters the lock. protected virtual SynchronizedBlock EnterLock()","title":"SynchronizedBlock.EnterLock method"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/EnterLock/#return-value","text":"The synchronized block.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/EnterLock/#see-also","text":"class SynchronizedBlock namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/Lock/","text":"SynchronizedBlock.Lock method Creates a new SynchronizedBlock for synchronizing access to the specified object and enters the lock. public static SynchronizedBlock Lock(object syncObject) Return Value The synchronized block. See Also class SynchronizedBlock namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"Lock"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/Lock/#synchronizedblocklock-method","text":"Creates a new SynchronizedBlock for synchronizing access to the specified object and enters the lock. public static SynchronizedBlock Lock(object syncObject)","title":"SynchronizedBlock.Lock method"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/Lock/#return-value","text":"The synchronized block.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/Lock/#see-also","text":"class SynchronizedBlock namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/Pulse/","text":"SynchronizedBlock.Pulse method Notifies a thread in the waiting queue of a change in the locked object\u2019s state. public virtual void Pulse() See Also class SynchronizedBlock namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"Pulse"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/Pulse/#synchronizedblockpulse-method","text":"Notifies a thread in the waiting queue of a change in the locked object\u2019s state. public virtual void Pulse()","title":"SynchronizedBlock.Pulse method"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/Pulse/#see-also","text":"class SynchronizedBlock namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/PulseAll/","text":"SynchronizedBlock.PulseAll method Notifies all waiting threads of a change in the object\u2019s state. public virtual void PulseAll() See Also class SynchronizedBlock namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"PulseAll"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/PulseAll/#synchronizedblockpulseall-method","text":"Notifies all waiting threads of a change in the object\u2019s state. public virtual void PulseAll()","title":"SynchronizedBlock.PulseAll method"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/PulseAll/#see-also","text":"class SynchronizedBlock namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/SyncObject/","text":"SynchronizedBlock.SyncObject field The object used for synchronization. protected readonly object SyncObject; See Also class SynchronizedBlock namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"SyncObject"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/SyncObject/#synchronizedblocksyncobject-field","text":"The object used for synchronization. protected readonly object SyncObject;","title":"SynchronizedBlock.SyncObject field"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/SyncObject/#see-also","text":"class SynchronizedBlock namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/SynchronizedBlock/","text":"SynchronizedBlock constructor Initializes a new instance of the SynchronizedBlock class. protected SynchronizedBlock(object syncObject) parameter description syncObject The sync object to serialize access to. See Also class SynchronizedBlock namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"SynchronizedBlock"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/SynchronizedBlock/#synchronizedblock-constructor","text":"Initializes a new instance of the SynchronizedBlock class. protected SynchronizedBlock(object syncObject) parameter description syncObject The sync object to serialize access to.","title":"SynchronizedBlock constructor"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/SynchronizedBlock/#see-also","text":"class SynchronizedBlock namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/Wait/","text":"SynchronizedBlock.Wait method (1 of 3) Releases the lock on an object and blocks the current thread until it reacquires the lock. public virtual bool Wait() Return Value True if the call returned because the caller reacquired the lock for the specified object. This method does not return if the lock is not reacquired. See Also class SynchronizedBlock namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote SynchronizedBlock.Wait method (2 of 3) Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. public virtual bool Wait(int millisecondsTimeout) parameter description millisecondsTimeout The number of milliseconds to wait before the thread enters the ready queue. Return Value True if the lock was reacquired before the specified time elapsed; false if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired. See Also class SynchronizedBlock namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote SynchronizedBlock.Wait method (3 of 3) Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. public virtual bool Wait(TimeSpan timeout) parameter description timeout A System.TimeSpan representing the amount of time to wait before the thread enters the ready queue. Return Value True if the lock was reacquired before the specified time elapsed; false if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired. See Also class SynchronizedBlock namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"Wait"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/Wait/#synchronizedblockwait-method-1-of-3","text":"Releases the lock on an object and blocks the current thread until it reacquires the lock. public virtual bool Wait()","title":"SynchronizedBlock.Wait method (1 of 3)"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/Wait/#return-value","text":"True if the call returned because the caller reacquired the lock for the specified object. This method does not return if the lock is not reacquired.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/Wait/#see-also","text":"class SynchronizedBlock namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/Wait/#synchronizedblockwait-method-2-of-3","text":"Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. public virtual bool Wait(int millisecondsTimeout) parameter description millisecondsTimeout The number of milliseconds to wait before the thread enters the ready queue.","title":"SynchronizedBlock.Wait method (2 of 3)"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/Wait/#return-value_1","text":"True if the lock was reacquired before the specified time elapsed; false if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/Wait/#see-also_1","text":"class SynchronizedBlock namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/Wait/#synchronizedblockwait-method-3-of-3","text":"Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. public virtual bool Wait(TimeSpan timeout) parameter description timeout A System.TimeSpan representing the amount of time to wait before the thread enters the ready queue.","title":"SynchronizedBlock.Wait method (3 of 3)"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/Wait/#return-value_2","text":"True if the lock was reacquired before the specified time elapsed; false if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/SynchronizedBlock/Wait/#see-also_2","text":"class SynchronizedBlock namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/CompletedTask/","text":"Task.CompletedTask property A Task that has completed successfully. public static Task CompletedTask { get; } See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"CompletedTask"},{"location":"ref/Microsoft.Coyote.Tasks/Task/CompletedTask/#taskcompletedtask-property","text":"A Task that has completed successfully. public static Task CompletedTask { get; }","title":"Task.CompletedTask property"},{"location":"ref/Microsoft.Coyote.Tasks/Task/CompletedTask/#see-also","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/ConfigureAwait/","text":"Task.ConfigureAwait method Configures an awaiter used to await this task. public ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext) parameter description continueOnCapturedContext True to attempt to marshal the continuation back to the original context captured; otherwise, false. See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"ConfigureAwait"},{"location":"ref/Microsoft.Coyote.Tasks/Task/ConfigureAwait/#taskconfigureawait-method","text":"Configures an awaiter used to await this task. public ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext) parameter description continueOnCapturedContext True to attempt to marshal the continuation back to the original context captured; otherwise, false.","title":"Task.ConfigureAwait method"},{"location":"ref/Microsoft.Coyote.Tasks/Task/ConfigureAwait/#see-also","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/CurrentId/","text":"Task.CurrentId property Returns the id of the currently executing Task . public static int? CurrentId { get; } See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"CurrentId"},{"location":"ref/Microsoft.Coyote.Tasks/Task/CurrentId/#taskcurrentid-property","text":"Returns the id of the currently executing Task . public static int? CurrentId { get; }","title":"Task.CurrentId property"},{"location":"ref/Microsoft.Coyote.Tasks/Task/CurrentId/#see-also","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Delay/","text":"Task.Delay method (1 of 4) Creates a Task that completes after a time delay. public static Task Delay(int millisecondsDelay) parameter description millisecondsDelay The number of milliseconds to wait before completing the returned task, or -1 to wait indefinitely. Return Value Task that represents the time delay. See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Task.Delay method (2 of 4) Creates a Task that completes after a specified time interval. public static Task Delay(TimeSpan delay) parameter description delay The time span to wait before completing the returned task, or TimeSpan.FromMilliseconds(-1) to wait indefinitely. Return Value Task that represents the time delay. See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Task.Delay method (3 of 4) Creates a Task that completes after a time delay. public static Task Delay(int millisecondsDelay, CancellationToken cancellationToken) parameter description millisecondsDelay The number of milliseconds to wait before completing the returned task, or -1 to wait indefinitely. cancellationToken Cancellation token that can be used to cancel the delay. Return Value Task that represents the time delay. See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Task.Delay method (4 of 4) Creates a Task that completes after a specified time interval. public static Task Delay(TimeSpan delay, CancellationToken cancellationToken) parameter description delay The time span to wait before completing the returned task, or TimeSpan.FromMilliseconds(-1) to wait indefinitely. cancellationToken Cancellation token that can be used to cancel the delay. Return Value Task that represents the time delay. See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"Delay"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Delay/#taskdelay-method-1-of-4","text":"Creates a Task that completes after a time delay. public static Task Delay(int millisecondsDelay) parameter description millisecondsDelay The number of milliseconds to wait before completing the returned task, or -1 to wait indefinitely.","title":"Task.Delay method (1 of 4)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Delay/#return-value","text":"Task that represents the time delay.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Delay/#see-also","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Delay/#taskdelay-method-2-of-4","text":"Creates a Task that completes after a specified time interval. public static Task Delay(TimeSpan delay) parameter description delay The time span to wait before completing the returned task, or TimeSpan.FromMilliseconds(-1) to wait indefinitely.","title":"Task.Delay method (2 of 4)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Delay/#return-value_1","text":"Task that represents the time delay.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Delay/#see-also_1","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Delay/#taskdelay-method-3-of-4","text":"Creates a Task that completes after a time delay. public static Task Delay(int millisecondsDelay, CancellationToken cancellationToken) parameter description millisecondsDelay The number of milliseconds to wait before completing the returned task, or -1 to wait indefinitely. cancellationToken Cancellation token that can be used to cancel the delay.","title":"Task.Delay method (3 of 4)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Delay/#return-value_2","text":"Task that represents the time delay.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Delay/#see-also_2","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Delay/#taskdelay-method-4-of-4","text":"Creates a Task that completes after a specified time interval. public static Task Delay(TimeSpan delay, CancellationToken cancellationToken) parameter description delay The time span to wait before completing the returned task, or TimeSpan.FromMilliseconds(-1) to wait indefinitely. cancellationToken Cancellation token that can be used to cancel the delay.","title":"Task.Delay method (4 of 4)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Delay/#return-value_3","text":"Task that represents the time delay.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Delay/#see-also_3","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Dispose/","text":"Task.Dispose method (1 of 2) Disposes the Task , releasing all of its unmanaged resources. public void Dispose() Remarks Unlike most of the members of Task , this method is not thread-safe. See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Task.Dispose method (2 of 2) Disposes the Task , releasing all of its unmanaged resources. protected virtual void Dispose(bool disposing) See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"Dispose"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Dispose/#taskdispose-method-1-of-2","text":"Disposes the Task , releasing all of its unmanaged resources. public void Dispose()","title":"Task.Dispose method (1 of 2)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Dispose/#remarks","text":"Unlike most of the members of Task , this method is not thread-safe.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Dispose/#see-also","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Dispose/#taskdispose-method-2-of-2","text":"Disposes the Task , releasing all of its unmanaged resources. protected virtual void Dispose(bool disposing)","title":"Task.Dispose method (2 of 2)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Dispose/#see-also_1","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Exception/","text":"Task.Exception property Gets the AggregateException that caused the task to end prematurely. If the task completed successfully or has not yet thrown any exceptions, this will return null. public AggregateException Exception { get; } See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"Exception"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Exception/#taskexception-property","text":"Gets the AggregateException that caused the task to end prematurely. If the task completed successfully or has not yet thrown any exceptions, this will return null. public AggregateException Exception { get; }","title":"Task.Exception property"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Exception/#see-also","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/ExploreContextSwitch/","text":"Task.ExploreContextSwitch method Injects a context switch point that can be systematically explored during testing. public static void ExploreContextSwitch() See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"ExploreContextSwitch"},{"location":"ref/Microsoft.Coyote.Tasks/Task/ExploreContextSwitch/#taskexplorecontextswitch-method","text":"Injects a context switch point that can be systematically explored during testing. public static void ExploreContextSwitch()","title":"Task.ExploreContextSwitch method"},{"location":"ref/Microsoft.Coyote.Tasks/Task/ExploreContextSwitch/#see-also","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/FromCanceled/","text":"Task.FromCanceled method (1 of 2) Creates a Task that is completed due to cancellation with a specified cancellation token. public static Task FromCanceled(CancellationToken cancellationToken) parameter description cancellationToken The cancellation token with which to complete the task. Return Value The canceled task. See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Task.FromCanceled<TResult> method (2 of 2) Creates a Task that is completed due to cancellation with a specified cancellation token. public static Task<TResult> FromCanceled<TResult>(CancellationToken cancellationToken) parameter description TResult The type of the result returned by the task. cancellationToken The cancellation token with which to complete the task. Return Value The canceled task. See Also class Task<TResult> class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"FromCanceled"},{"location":"ref/Microsoft.Coyote.Tasks/Task/FromCanceled/#taskfromcanceled-method-1-of-2","text":"Creates a Task that is completed due to cancellation with a specified cancellation token. public static Task FromCanceled(CancellationToken cancellationToken) parameter description cancellationToken The cancellation token with which to complete the task.","title":"Task.FromCanceled method (1 of 2)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/FromCanceled/#return-value","text":"The canceled task.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Task/FromCanceled/#see-also","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/FromCanceled/#taskfromcanceledtresult-method-2-of-2","text":"Creates a Task that is completed due to cancellation with a specified cancellation token. public static Task<TResult> FromCanceled<TResult>(CancellationToken cancellationToken) parameter description TResult The type of the result returned by the task. cancellationToken The cancellation token with which to complete the task.","title":"Task.FromCanceled&lt;TResult&gt; method (2 of 2)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/FromCanceled/#return-value_1","text":"The canceled task.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Task/FromCanceled/#see-also_1","text":"class Task<TResult> class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/FromException/","text":"Task.FromException method (1 of 2) Creates a Task that is completed with a specified exception. public static Task FromException(Exception exception) parameter description exception The exception with which to complete the task. Return Value The faulted task. See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Task.FromException<TResult> method (2 of 2) Creates a Task that is completed with a specified exception. public static Task<TResult> FromException<TResult>(Exception exception) parameter description TResult The type of the result returned by the task. exception The exception with which to complete the task. Return Value The faulted task. See Also class Task<TResult> class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"FromException"},{"location":"ref/Microsoft.Coyote.Tasks/Task/FromException/#taskfromexception-method-1-of-2","text":"Creates a Task that is completed with a specified exception. public static Task FromException(Exception exception) parameter description exception The exception with which to complete the task.","title":"Task.FromException method (1 of 2)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/FromException/#return-value","text":"The faulted task.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Task/FromException/#see-also","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/FromException/#taskfromexceptiontresult-method-2-of-2","text":"Creates a Task that is completed with a specified exception. public static Task<TResult> FromException<TResult>(Exception exception) parameter description TResult The type of the result returned by the task. exception The exception with which to complete the task.","title":"Task.FromException&lt;TResult&gt; method (2 of 2)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/FromException/#return-value_1","text":"The faulted task.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Task/FromException/#see-also_1","text":"class Task<TResult> class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/FromResult/","text":"Task.FromResult<TResult> method Creates a Task that is completed successfully with the specified result. public static Task<TResult> FromResult<TResult>(TResult result) parameter description TResult The type of the result returned by the task. result The result to store into the completed task. Return Value The successfully completed task. See Also class Task<TResult> class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"FromResult"},{"location":"ref/Microsoft.Coyote.Tasks/Task/FromResult/#taskfromresulttresult-method","text":"Creates a Task that is completed successfully with the specified result. public static Task<TResult> FromResult<TResult>(TResult result) parameter description TResult The type of the result returned by the task. result The result to store into the completed task.","title":"Task.FromResult&lt;TResult&gt; method"},{"location":"ref/Microsoft.Coyote.Tasks/Task/FromResult/#return-value","text":"The successfully completed task.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Task/FromResult/#see-also","text":"class Task<TResult> class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/GetAwaiter/","text":"Task.GetAwaiter method Gets an awaiter for this awaitable. public TaskAwaiter GetAwaiter() See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"GetAwaiter"},{"location":"ref/Microsoft.Coyote.Tasks/Task/GetAwaiter/#taskgetawaiter-method","text":"Gets an awaiter for this awaitable. public TaskAwaiter GetAwaiter()","title":"Task.GetAwaiter method"},{"location":"ref/Microsoft.Coyote.Tasks/Task/GetAwaiter/#see-also","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Id/","text":"Task.Id property The id of this task. public int Id { get; } See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"Id"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Id/#taskid-property","text":"The id of this task. public int Id { get; }","title":"Task.Id property"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Id/#see-also","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/IsCanceled/","text":"Task.IsCanceled property Value that indicates whether the task completed execution due to being canceled. public bool IsCanceled { get; } See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"IsCanceled"},{"location":"ref/Microsoft.Coyote.Tasks/Task/IsCanceled/#taskiscanceled-property","text":"Value that indicates whether the task completed execution due to being canceled. public bool IsCanceled { get; }","title":"Task.IsCanceled property"},{"location":"ref/Microsoft.Coyote.Tasks/Task/IsCanceled/#see-also","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/IsCompleted/","text":"Task.IsCompleted property Value that indicates whether the task has completed. public bool IsCompleted { get; } See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"IsCompleted"},{"location":"ref/Microsoft.Coyote.Tasks/Task/IsCompleted/#taskiscompleted-property","text":"Value that indicates whether the task has completed. public bool IsCompleted { get; }","title":"Task.IsCompleted property"},{"location":"ref/Microsoft.Coyote.Tasks/Task/IsCompleted/#see-also","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/IsFaulted/","text":"Task.IsFaulted property Value that indicates whether the task completed due to an unhandled exception. public bool IsFaulted { get; } See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"IsFaulted"},{"location":"ref/Microsoft.Coyote.Tasks/Task/IsFaulted/#taskisfaulted-property","text":"Value that indicates whether the task completed due to an unhandled exception. public bool IsFaulted { get; }","title":"Task.IsFaulted property"},{"location":"ref/Microsoft.Coyote.Tasks/Task/IsFaulted/#see-also","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Run/","text":"Task.Run method (1 of 8) Queues the specified work to run on the thread pool and returns a Task object that represents that work. A cancellation token allows the work to be cancelled. public static Task Run(Action action) parameter description action The work to execute asynchronously. Return Value Task that represents the work to run asynchronously. See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Task.Run method (2 of 8) Queues the specified work to run on the thread pool and returns a proxy for the Task returned by the function. public static Task Run(Func<Task> function) parameter description function The work to execute asynchronously. Return Value Task that represents the work to run asynchronously. See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Task.Run method (3 of 8) Queues the specified work to run on the thread pool and returns a Task object that represents that work. public static Task Run(Action action, CancellationToken cancellationToken) parameter description action The work to execute asynchronously. cancellationToken Cancellation token that can be used to cancel the work. Return Value Task that represents the work to run asynchronously. See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Task.Run method (4 of 8) Queues the specified work to run on the thread pool and returns a proxy for the Task returned by the function. A cancellation token allows the work to be cancelled. public static Task Run(Func<Task> function, CancellationToken cancellationToken) parameter description function The work to execute asynchronously. cancellationToken Cancellation token that can be used to cancel the work. Return Value Task that represents the work to run asynchronously. See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Task.Run<TResult> method (5 of 8) Queues the specified work to run on the thread pool and returns a proxy for the Task returned by the function. public static Task<TResult> Run<TResult>(Func<Task<TResult>> function) parameter description TResult The result type of the task. function The work to execute asynchronously. Return Value Task that represents the work to run asynchronously. See Also class Task<TResult> class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Task.Run<TResult> method (6 of 8) Queues the specified work to run on the thread pool and returns a Task object that represents that work. public static Task<TResult> Run<TResult>(Func<TResult> function) parameter description TResult The result type of the task. function The work to execute asynchronously. Return Value Task that represents the work to run asynchronously. See Also class Task<TResult> class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Task.Run<TResult> method (7 of 8) Queues the specified work to run on the thread pool and returns a proxy for the Task returned by the function. A cancellation token allows the work to be cancelled. public static Task<TResult> Run<TResult>(Func<Task<TResult>> function, CancellationToken cancellationToken) parameter description TResult The result type of the task. function The work to execute asynchronously. cancellationToken Cancellation token that can be used to cancel the work. Return Value Task that represents the work to run asynchronously. See Also class Task<TResult> class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Task.Run<TResult> method (8 of 8) Queues the specified work to run on the thread pool and returns a Task object that represents that work. A cancellation token allows the work to be cancelled. public static Task<TResult> Run<TResult>(Func<TResult> function, CancellationToken cancellationToken) parameter description TResult The result type of the task. function The work to execute asynchronously. cancellationToken Cancellation token that can be used to cancel the work. Return Value Task that represents the work to run asynchronously. See Also class Task<TResult> class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"Run"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Run/#taskrun-method-1-of-8","text":"Queues the specified work to run on the thread pool and returns a Task object that represents that work. A cancellation token allows the work to be cancelled. public static Task Run(Action action) parameter description action The work to execute asynchronously.","title":"Task.Run method (1 of 8)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Run/#return-value","text":"Task that represents the work to run asynchronously.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Run/#see-also","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Run/#taskrun-method-2-of-8","text":"Queues the specified work to run on the thread pool and returns a proxy for the Task returned by the function. public static Task Run(Func<Task> function) parameter description function The work to execute asynchronously.","title":"Task.Run method (2 of 8)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Run/#return-value_1","text":"Task that represents the work to run asynchronously.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Run/#see-also_1","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Run/#taskrun-method-3-of-8","text":"Queues the specified work to run on the thread pool and returns a Task object that represents that work. public static Task Run(Action action, CancellationToken cancellationToken) parameter description action The work to execute asynchronously. cancellationToken Cancellation token that can be used to cancel the work.","title":"Task.Run method (3 of 8)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Run/#return-value_2","text":"Task that represents the work to run asynchronously.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Run/#see-also_2","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Run/#taskrun-method-4-of-8","text":"Queues the specified work to run on the thread pool and returns a proxy for the Task returned by the function. A cancellation token allows the work to be cancelled. public static Task Run(Func<Task> function, CancellationToken cancellationToken) parameter description function The work to execute asynchronously. cancellationToken Cancellation token that can be used to cancel the work.","title":"Task.Run method (4 of 8)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Run/#return-value_3","text":"Task that represents the work to run asynchronously.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Run/#see-also_3","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Run/#taskruntresult-method-5-of-8","text":"Queues the specified work to run on the thread pool and returns a proxy for the Task returned by the function. public static Task<TResult> Run<TResult>(Func<Task<TResult>> function) parameter description TResult The result type of the task. function The work to execute asynchronously.","title":"Task.Run&lt;TResult&gt; method (5 of 8)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Run/#return-value_4","text":"Task that represents the work to run asynchronously.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Run/#see-also_4","text":"class Task<TResult> class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Run/#taskruntresult-method-6-of-8","text":"Queues the specified work to run on the thread pool and returns a Task object that represents that work. public static Task<TResult> Run<TResult>(Func<TResult> function) parameter description TResult The result type of the task. function The work to execute asynchronously.","title":"Task.Run&lt;TResult&gt; method (6 of 8)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Run/#return-value_5","text":"Task that represents the work to run asynchronously.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Run/#see-also_5","text":"class Task<TResult> class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Run/#taskruntresult-method-7-of-8","text":"Queues the specified work to run on the thread pool and returns a proxy for the Task returned by the function. A cancellation token allows the work to be cancelled. public static Task<TResult> Run<TResult>(Func<Task<TResult>> function, CancellationToken cancellationToken) parameter description TResult The result type of the task. function The work to execute asynchronously. cancellationToken Cancellation token that can be used to cancel the work.","title":"Task.Run&lt;TResult&gt; method (7 of 8)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Run/#return-value_6","text":"Task that represents the work to run asynchronously.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Run/#see-also_6","text":"class Task<TResult> class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Run/#taskruntresult-method-8-of-8","text":"Queues the specified work to run on the thread pool and returns a Task object that represents that work. A cancellation token allows the work to be cancelled. public static Task<TResult> Run<TResult>(Func<TResult> function, CancellationToken cancellationToken) parameter description TResult The result type of the task. function The work to execute asynchronously. cancellationToken Cancellation token that can be used to cancel the work.","title":"Task.Run&lt;TResult&gt; method (8 of 8)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Run/#return-value_7","text":"Task that represents the work to run asynchronously.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Run/#see-also_7","text":"class Task<TResult> class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Status/","text":"Task.Status property The status of this task. public TaskStatus Status { get; } See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"Status"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Status/#taskstatus-property","text":"The status of this task. public TaskStatus Status { get; }","title":"Task.Status property"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Status/#see-also","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/UncontrolledTask/","text":"Task.UncontrolledTask property The uncontrolled Task that is wrapped inside this controlled Task . public Task UncontrolledTask { get; } See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"UncontrolledTask"},{"location":"ref/Microsoft.Coyote.Tasks/Task/UncontrolledTask/#taskuncontrolledtask-property","text":"The uncontrolled Task that is wrapped inside this controlled Task . public Task UncontrolledTask { get; }","title":"Task.UncontrolledTask property"},{"location":"ref/Microsoft.Coyote.Tasks/Task/UncontrolledTask/#see-also","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Wait/","text":"Task.Wait method (1 of 5) Waits for the task to complete execution. public void Wait() See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Task.Wait method (2 of 5) Waits for the task to complete execution. The wait terminates if a cancellation token is canceled before the task completes. public void Wait(CancellationToken cancellationToken) parameter description cancellationToken A cancellation token to observe while waiting for the task to complete. See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Task.Wait method (3 of 5) Waits for the task to complete execution within a specified number of milliseconds. public bool Wait(int millisecondsTimeout) parameter description millisecondsTimeout The number of milliseconds to wait, or -1 to wait indefinitely. Return Value True if the task completed execution within the allotted time; otherwise, false. See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Task.Wait method (4 of 5) Waits for the task to complete execution within a specified time interval. public bool Wait(TimeSpan timeout) parameter description timeout A time span that represents the number of milliseconds to wait, or TimeSpan.FromMilliseconds(-1) to wait indefinitely. Return Value True if the task completed execution within the allotted time; otherwise, false. See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Task.Wait method (5 of 5) Waits for the task to complete execution. The wait terminates if a timeout interval elapses or a cancellation token is canceled before the task completes. public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken) parameter description millisecondsTimeout The number of milliseconds to wait, or -1 to wait indefinitely. cancellationToken A cancellation token to observe while waiting for the task to complete. Return Value True if the task completed execution within the allotted time; otherwise, false. See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"Wait"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Wait/#taskwait-method-1-of-5","text":"Waits for the task to complete execution. public void Wait()","title":"Task.Wait method (1 of 5)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Wait/#see-also","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Wait/#taskwait-method-2-of-5","text":"Waits for the task to complete execution. The wait terminates if a cancellation token is canceled before the task completes. public void Wait(CancellationToken cancellationToken) parameter description cancellationToken A cancellation token to observe while waiting for the task to complete.","title":"Task.Wait method (2 of 5)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Wait/#see-also_1","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Wait/#taskwait-method-3-of-5","text":"Waits for the task to complete execution within a specified number of milliseconds. public bool Wait(int millisecondsTimeout) parameter description millisecondsTimeout The number of milliseconds to wait, or -1 to wait indefinitely.","title":"Task.Wait method (3 of 5)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Wait/#return-value","text":"True if the task completed execution within the allotted time; otherwise, false.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Wait/#see-also_2","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Wait/#taskwait-method-4-of-5","text":"Waits for the task to complete execution within a specified time interval. public bool Wait(TimeSpan timeout) parameter description timeout A time span that represents the number of milliseconds to wait, or TimeSpan.FromMilliseconds(-1) to wait indefinitely.","title":"Task.Wait method (4 of 5)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Wait/#return-value_1","text":"True if the task completed execution within the allotted time; otherwise, false.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Wait/#see-also_3","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Wait/#taskwait-method-5-of-5","text":"Waits for the task to complete execution. The wait terminates if a timeout interval elapses or a cancellation token is canceled before the task completes. public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken) parameter description millisecondsTimeout The number of milliseconds to wait, or -1 to wait indefinitely. cancellationToken A cancellation token to observe while waiting for the task to complete.","title":"Task.Wait method (5 of 5)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Wait/#return-value_2","text":"True if the task completed execution within the allotted time; otherwise, false.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Wait/#see-also_4","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WaitAll/","text":"Task.WaitAll method (1 of 5) Waits for all of the provided Task objects to complete execution. public static void WaitAll(params Task[] tasks) parameter description tasks The tasks to wait for completion. See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Task.WaitAll method (2 of 5) Waits for all of the provided Task objects to complete execution unless the wait is cancelled. public static void WaitAll(Task[] tasks, CancellationToken cancellationToken) parameter description tasks The tasks to wait for completion. cancellationToken Cancellation token that can be used to cancel the wait. See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Task.WaitAll method (3 of 5) Waits for all of the provided Task objects to complete execution within a specified number of milliseconds. public static bool WaitAll(Task[] tasks, int millisecondsTimeout) parameter description tasks The tasks to wait for completion. millisecondsTimeout The number of milliseconds to wait, or -1 to wait indefinitely. Return Value True if all tasks completed execution within the allotted time; otherwise, false. See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Task.WaitAll method (4 of 5) Waits for all of the provided Task objects to complete execution within a specified time interval. public static bool WaitAll(Task[] tasks, TimeSpan timeout) parameter description tasks The tasks to wait for completion. timeout A time span that represents the number of milliseconds to wait, or TimeSpan.FromMilliseconds(-1) to wait indefinitely. Return Value True if all tasks completed execution within the allotted time; otherwise, false. See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Task.WaitAll method (5 of 5) Waits for any of the provided Task objects to complete execution within a specified number of milliseconds or until a cancellation token is cancelled. public static bool WaitAll(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken) parameter description tasks The tasks to wait for completion. millisecondsTimeout The number of milliseconds to wait, or -1 to wait indefinitely. cancellationToken Cancellation token that can be used to cancel the wait. Return Value True if all tasks completed execution within the allotted time; otherwise, false. See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"WaitAll"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WaitAll/#taskwaitall-method-1-of-5","text":"Waits for all of the provided Task objects to complete execution. public static void WaitAll(params Task[] tasks) parameter description tasks The tasks to wait for completion.","title":"Task.WaitAll method (1 of 5)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WaitAll/#see-also","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WaitAll/#taskwaitall-method-2-of-5","text":"Waits for all of the provided Task objects to complete execution unless the wait is cancelled. public static void WaitAll(Task[] tasks, CancellationToken cancellationToken) parameter description tasks The tasks to wait for completion. cancellationToken Cancellation token that can be used to cancel the wait.","title":"Task.WaitAll method (2 of 5)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WaitAll/#see-also_1","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WaitAll/#taskwaitall-method-3-of-5","text":"Waits for all of the provided Task objects to complete execution within a specified number of milliseconds. public static bool WaitAll(Task[] tasks, int millisecondsTimeout) parameter description tasks The tasks to wait for completion. millisecondsTimeout The number of milliseconds to wait, or -1 to wait indefinitely.","title":"Task.WaitAll method (3 of 5)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WaitAll/#return-value","text":"True if all tasks completed execution within the allotted time; otherwise, false.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WaitAll/#see-also_2","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WaitAll/#taskwaitall-method-4-of-5","text":"Waits for all of the provided Task objects to complete execution within a specified time interval. public static bool WaitAll(Task[] tasks, TimeSpan timeout) parameter description tasks The tasks to wait for completion. timeout A time span that represents the number of milliseconds to wait, or TimeSpan.FromMilliseconds(-1) to wait indefinitely.","title":"Task.WaitAll method (4 of 5)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WaitAll/#return-value_1","text":"True if all tasks completed execution within the allotted time; otherwise, false.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WaitAll/#see-also_3","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WaitAll/#taskwaitall-method-5-of-5","text":"Waits for any of the provided Task objects to complete execution within a specified number of milliseconds or until a cancellation token is cancelled. public static bool WaitAll(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken) parameter description tasks The tasks to wait for completion. millisecondsTimeout The number of milliseconds to wait, or -1 to wait indefinitely. cancellationToken Cancellation token that can be used to cancel the wait.","title":"Task.WaitAll method (5 of 5)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WaitAll/#return-value_2","text":"True if all tasks completed execution within the allotted time; otherwise, false.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WaitAll/#see-also_4","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WaitAny/","text":"Task.WaitAny method (1 of 5) Waits for any of the provided Task objects to complete execution. public static int WaitAny(params Task[] tasks) parameter description tasks The tasks to wait for completion. Return Value The index of the completed task in the tasks array. See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Task.WaitAny method (2 of 5) Waits for any of the provided Task objects to complete execution unless the wait is cancelled. public static int WaitAny(Task[] tasks, CancellationToken cancellationToken) parameter description tasks The tasks to wait for completion. cancellationToken Cancellation token that can be used to cancel the wait. Return Value The index of the completed task in the tasks array. See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Task.WaitAny method (3 of 5) Waits for any of the provided Task objects to complete execution within a specified number of milliseconds. public static int WaitAny(Task[] tasks, int millisecondsTimeout) parameter description tasks The tasks to wait for completion. millisecondsTimeout The number of milliseconds to wait, or -1 to wait indefinitely. Return Value The index of the completed task in the tasks array, or -1 if the timeout occurred. See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Task.WaitAny method (4 of 5) Waits for any of the provided Task objects to complete execution within a specified time interval. public static int WaitAny(Task[] tasks, TimeSpan timeout) parameter description tasks The tasks to wait for completion. timeout A time span that represents the number of milliseconds to wait, or TimeSpan.FromMilliseconds(-1) to wait indefinitely. Return Value The index of the completed task in the tasks array, or -1 if the timeout occurred. See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Task.WaitAny method (5 of 5) Waits for any of the provided Task objects to complete execution within a specified number of milliseconds or until a cancellation token is cancelled. public static int WaitAny(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken) parameter description tasks The tasks to wait for completion. millisecondsTimeout The number of milliseconds to wait, or -1 to wait indefinitely. cancellationToken Cancellation token that can be used to cancel the wait. Return Value The index of the completed task in the tasks array, or -1 if the timeout occurred. See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"WaitAny"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WaitAny/#taskwaitany-method-1-of-5","text":"Waits for any of the provided Task objects to complete execution. public static int WaitAny(params Task[] tasks) parameter description tasks The tasks to wait for completion.","title":"Task.WaitAny method (1 of 5)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WaitAny/#return-value","text":"The index of the completed task in the tasks array.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WaitAny/#see-also","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WaitAny/#taskwaitany-method-2-of-5","text":"Waits for any of the provided Task objects to complete execution unless the wait is cancelled. public static int WaitAny(Task[] tasks, CancellationToken cancellationToken) parameter description tasks The tasks to wait for completion. cancellationToken Cancellation token that can be used to cancel the wait.","title":"Task.WaitAny method (2 of 5)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WaitAny/#return-value_1","text":"The index of the completed task in the tasks array.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WaitAny/#see-also_1","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WaitAny/#taskwaitany-method-3-of-5","text":"Waits for any of the provided Task objects to complete execution within a specified number of milliseconds. public static int WaitAny(Task[] tasks, int millisecondsTimeout) parameter description tasks The tasks to wait for completion. millisecondsTimeout The number of milliseconds to wait, or -1 to wait indefinitely.","title":"Task.WaitAny method (3 of 5)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WaitAny/#return-value_2","text":"The index of the completed task in the tasks array, or -1 if the timeout occurred.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WaitAny/#see-also_2","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WaitAny/#taskwaitany-method-4-of-5","text":"Waits for any of the provided Task objects to complete execution within a specified time interval. public static int WaitAny(Task[] tasks, TimeSpan timeout) parameter description tasks The tasks to wait for completion. timeout A time span that represents the number of milliseconds to wait, or TimeSpan.FromMilliseconds(-1) to wait indefinitely.","title":"Task.WaitAny method (4 of 5)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WaitAny/#return-value_3","text":"The index of the completed task in the tasks array, or -1 if the timeout occurred.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WaitAny/#see-also_3","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WaitAny/#taskwaitany-method-5-of-5","text":"Waits for any of the provided Task objects to complete execution within a specified number of milliseconds or until a cancellation token is cancelled. public static int WaitAny(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken) parameter description tasks The tasks to wait for completion. millisecondsTimeout The number of milliseconds to wait, or -1 to wait indefinitely. cancellationToken Cancellation token that can be used to cancel the wait.","title":"Task.WaitAny method (5 of 5)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WaitAny/#return-value_4","text":"The index of the completed task in the tasks array, or -1 if the timeout occurred.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WaitAny/#see-also_4","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WhenAll/","text":"Task.WhenAll method (1 of 4) Creates a Task that will complete when all tasks in the specified enumerable collection have completed. public static Task WhenAll(IEnumerable<Task> tasks) parameter description tasks The tasks to wait for completion. Return Value Task that represents the completion of all of the specified tasks. See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Task.WhenAll method (2 of 4) Creates a Task that will complete when all tasks in the specified array have completed. public static Task WhenAll(params Task[] tasks) parameter description tasks The tasks to wait for completion. Return Value Task that represents the completion of all of the specified tasks. See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Task.WhenAll<TResult> method (3 of 4) Creates a Task that will complete when all tasks in the specified enumerable collection have completed. public static Task<TResult[]> WhenAll<TResult>(IEnumerable<Task<TResult>> tasks) parameter description TResult The result type of the task. tasks The tasks to wait for completion. Return Value Task that represents the completion of all of the specified tasks. See Also class Task<TResult> class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Task.WhenAll<TResult> method (4 of 4) Creates a Task that will complete when all tasks in the specified array have completed. public static Task<TResult[]> WhenAll<TResult>(params Task<TResult>[] tasks) parameter description TResult The result type of the task. tasks The tasks to wait for completion. Return Value Task that represents the completion of all of the specified tasks. See Also class Task<TResult> class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"WhenAll"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WhenAll/#taskwhenall-method-1-of-4","text":"Creates a Task that will complete when all tasks in the specified enumerable collection have completed. public static Task WhenAll(IEnumerable<Task> tasks) parameter description tasks The tasks to wait for completion.","title":"Task.WhenAll method (1 of 4)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WhenAll/#return-value","text":"Task that represents the completion of all of the specified tasks.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WhenAll/#see-also","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WhenAll/#taskwhenall-method-2-of-4","text":"Creates a Task that will complete when all tasks in the specified array have completed. public static Task WhenAll(params Task[] tasks) parameter description tasks The tasks to wait for completion.","title":"Task.WhenAll method (2 of 4)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WhenAll/#return-value_1","text":"Task that represents the completion of all of the specified tasks.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WhenAll/#see-also_1","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WhenAll/#taskwhenalltresult-method-3-of-4","text":"Creates a Task that will complete when all tasks in the specified enumerable collection have completed. public static Task<TResult[]> WhenAll<TResult>(IEnumerable<Task<TResult>> tasks) parameter description TResult The result type of the task. tasks The tasks to wait for completion.","title":"Task.WhenAll&lt;TResult&gt; method (3 of 4)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WhenAll/#return-value_2","text":"Task that represents the completion of all of the specified tasks.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WhenAll/#see-also_2","text":"class Task<TResult> class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WhenAll/#taskwhenalltresult-method-4-of-4","text":"Creates a Task that will complete when all tasks in the specified array have completed. public static Task<TResult[]> WhenAll<TResult>(params Task<TResult>[] tasks) parameter description TResult The result type of the task. tasks The tasks to wait for completion.","title":"Task.WhenAll&lt;TResult&gt; method (4 of 4)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WhenAll/#return-value_3","text":"Task that represents the completion of all of the specified tasks.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WhenAll/#see-also_3","text":"class Task<TResult> class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WhenAny/","text":"Task.WhenAny method (1 of 4) Creates a Task that will complete when any task in the specified enumerable collection have completed. public static Task<Task> WhenAny(IEnumerable<Task> tasks) parameter description tasks The tasks to wait for completion. See Also class Task<TResult> class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Task.WhenAny method (2 of 4) Creates a Task that will complete when any task in the specified array have completed. public static Task<Task> WhenAny(params Task[] tasks) parameter description tasks The tasks to wait for completion. See Also class Task<TResult> class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Task.WhenAny<TResult> method (3 of 4) Creates a Task that will complete when any task in the specified enumerable collection have completed. public static Task<Task<TResult>> WhenAny<TResult>(IEnumerable<Task<TResult>> tasks) parameter description tasks The tasks to wait for completion. See Also class Task<TResult> class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote Task.WhenAny<TResult> method (4 of 4) Creates a Task that will complete when any task in the specified array have completed. public static Task<Task<TResult>> WhenAny<TResult>(params Task<TResult>[] tasks) parameter description tasks The tasks to wait for completion. See Also class Task<TResult> class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"WhenAny"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WhenAny/#taskwhenany-method-1-of-4","text":"Creates a Task that will complete when any task in the specified enumerable collection have completed. public static Task<Task> WhenAny(IEnumerable<Task> tasks) parameter description tasks The tasks to wait for completion.","title":"Task.WhenAny method (1 of 4)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WhenAny/#see-also","text":"class Task<TResult> class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WhenAny/#taskwhenany-method-2-of-4","text":"Creates a Task that will complete when any task in the specified array have completed. public static Task<Task> WhenAny(params Task[] tasks) parameter description tasks The tasks to wait for completion.","title":"Task.WhenAny method (2 of 4)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WhenAny/#see-also_1","text":"class Task<TResult> class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WhenAny/#taskwhenanytresult-method-3-of-4","text":"Creates a Task that will complete when any task in the specified enumerable collection have completed. public static Task<Task<TResult>> WhenAny<TResult>(IEnumerable<Task<TResult>> tasks) parameter description tasks The tasks to wait for completion.","title":"Task.WhenAny&lt;TResult&gt; method (3 of 4)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WhenAny/#see-also_2","text":"class Task<TResult> class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WhenAny/#taskwhenanytresult-method-4-of-4","text":"Creates a Task that will complete when any task in the specified array have completed. public static Task<Task<TResult>> WhenAny<TResult>(params Task<TResult>[] tasks) parameter description tasks The tasks to wait for completion.","title":"Task.WhenAny&lt;TResult&gt; method (4 of 4)"},{"location":"ref/Microsoft.Coyote.Tasks/Task/WhenAny/#see-also_3","text":"class Task<TResult> class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Yield/","text":"Task.Yield method Creates an awaitable that asynchronously yields back to the current context when awaited. public static YieldAwaitable Yield() Remarks You can use await Task.Yield() in an asynchronous method to force the method to complete asynchronously. During systematic testing, the underlying scheduling strategy can use this as a hint on how to better prioritize this work relative to other work that may be pending. See Also class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"Yield"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Yield/#taskyield-method","text":"Creates an awaitable that asynchronously yields back to the current context when awaited. public static YieldAwaitable Yield()","title":"Task.Yield method"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Yield/#remarks","text":"You can use await Task.Yield() in an asynchronous method to force the method to complete asynchronously. During systematic testing, the underlying scheduling strategy can use this as a hint on how to better prioritize this work relative to other work that may be pending.","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Tasks/Task/Yield/#see-also","text":"class Task namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task-1/ConfigureAwait/","text":"Task<TResult>.ConfigureAwait method Configures an awaiter used to await this task. public ConfiguredTaskAwaitable<TResult> ConfigureAwait(bool continueOnCapturedContext) parameter description continueOnCapturedContext True to attempt to marshal the continuation back to the original context captured; otherwise, false. See Also class Task<TResult> namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"ConfigureAwait"},{"location":"ref/Microsoft.Coyote.Tasks/Task-1/ConfigureAwait/#tasktresultconfigureawait-method","text":"Configures an awaiter used to await this task. public ConfiguredTaskAwaitable<TResult> ConfigureAwait(bool continueOnCapturedContext) parameter description continueOnCapturedContext True to attempt to marshal the continuation back to the original context captured; otherwise, false.","title":"Task&lt;TResult&gt;.ConfigureAwait method"},{"location":"ref/Microsoft.Coyote.Tasks/Task-1/ConfigureAwait/#see-also","text":"class Task<TResult> namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task-1/GetAwaiter/","text":"Task<TResult>.GetAwaiter method Gets an awaiter for this awaitable. public TaskAwaiter<TResult> GetAwaiter() See Also class Task<TResult> namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"GetAwaiter"},{"location":"ref/Microsoft.Coyote.Tasks/Task-1/GetAwaiter/#tasktresultgetawaiter-method","text":"Gets an awaiter for this awaitable. public TaskAwaiter<TResult> GetAwaiter()","title":"Task&lt;TResult&gt;.GetAwaiter method"},{"location":"ref/Microsoft.Coyote.Tasks/Task-1/GetAwaiter/#see-also","text":"class Task<TResult> namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task-1/Result/","text":"Task<TResult>.Result property Gets the result value of this task. public TResult Result { get; } See Also class Task<TResult> namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"Result"},{"location":"ref/Microsoft.Coyote.Tasks/Task-1/Result/#tasktresultresult-property","text":"Gets the result value of this task. public TResult Result { get; }","title":"Task&lt;TResult&gt;.Result property"},{"location":"ref/Microsoft.Coyote.Tasks/Task-1/Result/#see-also","text":"class Task<TResult> namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/Task-1/UncontrolledTask/","text":"Task<TResult>.UncontrolledTask property The uncontrolled Task that is wrapped inside this controlled Task . public Task<TResult> UncontrolledTask { get; } See Also class Task<TResult> namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"UncontrolledTask"},{"location":"ref/Microsoft.Coyote.Tasks/Task-1/UncontrolledTask/#tasktresultuncontrolledtask-property","text":"The uncontrolled Task that is wrapped inside this controlled Task . public Task<TResult> UncontrolledTask { get; }","title":"Task&lt;TResult&gt;.UncontrolledTask property"},{"location":"ref/Microsoft.Coyote.Tasks/Task-1/UncontrolledTask/#see-also","text":"class Task<TResult> namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource/Create/","text":"TaskCompletionSource.Create<TResult> method Creates a new TaskCompletionSource instance. public static TaskCompletionSource<TResult> Create<TResult>() parameter description TResult The type of the result value assocatied with this task completion source. Return Value The task completion source. See Also class TaskCompletionSource<TResult> class TaskCompletionSource namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"Create"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource/Create/#taskcompletionsourcecreatetresult-method","text":"Creates a new TaskCompletionSource instance. public static TaskCompletionSource<TResult> Create<TResult>() parameter description TResult The type of the result value assocatied with this task completion source.","title":"TaskCompletionSource.Create&lt;TResult&gt; method"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource/Create/#return-value","text":"The task completion source.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource/Create/#see-also","text":"class TaskCompletionSource<TResult> class TaskCompletionSource namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource-1/SetCanceled/","text":"TaskCompletionSource<TResult>.SetCanceled method Transitions the underlying task into the Canceled state. public virtual void SetCanceled() Exceptions exception condition InvalidOperationException The underlying Task is already in one of the three final states: RanToCompletion, Faulted, or Canceled. See Also class TaskCompletionSource<TResult> namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"SetCanceled"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource-1/SetCanceled/#taskcompletionsourcetresultsetcanceled-method","text":"Transitions the underlying task into the Canceled state. public virtual void SetCanceled()","title":"TaskCompletionSource&lt;TResult&gt;.SetCanceled method"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource-1/SetCanceled/#exceptions","text":"exception condition InvalidOperationException The underlying Task is already in one of the three final states: RanToCompletion, Faulted, or Canceled.","title":"Exceptions"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource-1/SetCanceled/#see-also","text":"class TaskCompletionSource<TResult> namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource-1/SetException/","text":"TaskCompletionSource<TResult>.SetException method Transitions the underlying task into the Faulted state and binds it to the specified exception. public virtual void SetException(Exception exception) parameter description exception The exception to bind to this task. Exceptions exception condition InvalidOperationException The underlying Task is already in one of the three final states: RanToCompletion, Faulted, or Canceled. See Also class TaskCompletionSource<TResult> namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"SetException"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource-1/SetException/#taskcompletionsourcetresultsetexception-method","text":"Transitions the underlying task into the Faulted state and binds it to the specified exception. public virtual void SetException(Exception exception) parameter description exception The exception to bind to this task.","title":"TaskCompletionSource&lt;TResult&gt;.SetException method"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource-1/SetException/#exceptions","text":"exception condition InvalidOperationException The underlying Task is already in one of the three final states: RanToCompletion, Faulted, or Canceled.","title":"Exceptions"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource-1/SetException/#see-also","text":"class TaskCompletionSource<TResult> namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource-1/SetResult/","text":"TaskCompletionSource<TResult>.SetResult method Transitions the underlying task into the RanToCompletion state. public virtual void SetResult(TResult result) parameter description result The result value to bind to this task. Exceptions exception condition InvalidOperationException The underlying Task is already in one of the three final states: RanToCompletion, Faulted, or Canceled. See Also class TaskCompletionSource<TResult> namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"SetResult"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource-1/SetResult/#taskcompletionsourcetresultsetresult-method","text":"Transitions the underlying task into the RanToCompletion state. public virtual void SetResult(TResult result) parameter description result The result value to bind to this task.","title":"TaskCompletionSource&lt;TResult&gt;.SetResult method"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource-1/SetResult/#exceptions","text":"exception condition InvalidOperationException The underlying Task is already in one of the three final states: RanToCompletion, Faulted, or Canceled.","title":"Exceptions"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource-1/SetResult/#see-also","text":"class TaskCompletionSource<TResult> namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource-1/Task/","text":"TaskCompletionSource<TResult>.Task property Gets the task created by this task completion source. public virtual Task<TResult> Task { get; } See Also class Task<TResult> class TaskCompletionSource<TResult> namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"Task"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource-1/Task/#taskcompletionsourcetresulttask-property","text":"Gets the task created by this task completion source. public virtual Task<TResult> Task { get; }","title":"TaskCompletionSource&lt;TResult&gt;.Task property"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource-1/Task/#see-also","text":"class Task<TResult> class TaskCompletionSource<TResult> namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource-1/TrySetCanceled/","text":"TaskCompletionSource<TResult>.TrySetCanceled method Attempts to transition the underlying task into the Canceled state. public virtual bool TrySetCanceled() Return Value True if the operation was successful; otherwise, false. See Also class TaskCompletionSource<TResult> namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"TrySetCanceled"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource-1/TrySetCanceled/#taskcompletionsourcetresulttrysetcanceled-method","text":"Attempts to transition the underlying task into the Canceled state. public virtual bool TrySetCanceled()","title":"TaskCompletionSource&lt;TResult&gt;.TrySetCanceled method"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource-1/TrySetCanceled/#return-value","text":"True if the operation was successful; otherwise, false.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource-1/TrySetCanceled/#see-also","text":"class TaskCompletionSource<TResult> namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource-1/TrySetException/","text":"TaskCompletionSource<TResult>.TrySetException method Attempts to transition the underlying task into the Faulted state and binds it to the specified exception. public virtual bool TrySetException(Exception exception) parameter description exception The exception to bind to this task. Return Value True if the operation was successful; otherwise, false. See Also class TaskCompletionSource<TResult> namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"TrySetException"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource-1/TrySetException/#taskcompletionsourcetresulttrysetexception-method","text":"Attempts to transition the underlying task into the Faulted state and binds it to the specified exception. public virtual bool TrySetException(Exception exception) parameter description exception The exception to bind to this task.","title":"TaskCompletionSource&lt;TResult&gt;.TrySetException method"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource-1/TrySetException/#return-value","text":"True if the operation was successful; otherwise, false.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource-1/TrySetException/#see-also","text":"class TaskCompletionSource<TResult> namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource-1/TrySetResult/","text":"TaskCompletionSource<TResult>.TrySetResult method Attempts to transition the underlying task into the RanToCompletion state. public virtual bool TrySetResult(TResult result) parameter description result The result value to bind to this task. Return Value True if the operation was successful; otherwise, false. See Also class TaskCompletionSource<TResult> namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"TrySetResult"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource-1/TrySetResult/#taskcompletionsourcetresulttrysetresult-method","text":"Attempts to transition the underlying task into the RanToCompletion state. public virtual bool TrySetResult(TResult result) parameter description result The result value to bind to this task.","title":"TaskCompletionSource&lt;TResult&gt;.TrySetResult method"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource-1/TrySetResult/#return-value","text":"True if the operation was successful; otherwise, false.","title":"Return Value"},{"location":"ref/Microsoft.Coyote.Tasks/TaskCompletionSource-1/TrySetResult/#see-also","text":"class TaskCompletionSource<TResult> namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/TaskExtensions/WrapInControlledTask/","text":"TaskExtensions.WrapInControlledTask method (1 of 2) Returns a dummy controlled Task that wraps this uncontrolled Task. public static Task WrapInControlledTask(this Task @this) Remarks The returned dummy controlled Task does not actually take control of the uncontrolled Task during systematic testing, so this method should only be used to cross an interface boundary where a controlled Task must be temporarily converted into an uncontrolled Task and then coverted back to a controlled Task . See Also class Task class TaskExtensions namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote TaskExtensions.WrapInControlledTask<TResult> method (2 of 2) Returns a dummy controlled Task that wraps this uncontrolled Task. public static Task<TResult> WrapInControlledTask<TResult>(this Task<TResult> @this) Remarks The returned dummy controlled Task does not actually take control of the uncontrolled Task during systematic testing, so this method should only be used to cross an interface boundary where a controlled Task must be temporarily converted into an uncontrolled Task and then coverted back to a controlled Task . See Also class Task<TResult> class TaskExtensions namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"WrapInControlledTask"},{"location":"ref/Microsoft.Coyote.Tasks/TaskExtensions/WrapInControlledTask/#taskextensionswrapincontrolledtask-method-1-of-2","text":"Returns a dummy controlled Task that wraps this uncontrolled Task. public static Task WrapInControlledTask(this Task @this)","title":"TaskExtensions.WrapInControlledTask method (1 of 2)"},{"location":"ref/Microsoft.Coyote.Tasks/TaskExtensions/WrapInControlledTask/#remarks","text":"The returned dummy controlled Task does not actually take control of the uncontrolled Task during systematic testing, so this method should only be used to cross an interface boundary where a controlled Task must be temporarily converted into an uncontrolled Task and then coverted back to a controlled Task .","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Tasks/TaskExtensions/WrapInControlledTask/#see-also","text":"class Task class TaskExtensions namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"ref/Microsoft.Coyote.Tasks/TaskExtensions/WrapInControlledTask/#taskextensionswrapincontrolledtasktresult-method-2-of-2","text":"Returns a dummy controlled Task that wraps this uncontrolled Task. public static Task<TResult> WrapInControlledTask<TResult>(this Task<TResult> @this)","title":"TaskExtensions.WrapInControlledTask&lt;TResult&gt; method (2 of 2)"},{"location":"ref/Microsoft.Coyote.Tasks/TaskExtensions/WrapInControlledTask/#remarks_1","text":"The returned dummy controlled Task does not actually take control of the uncontrolled Task during systematic testing, so this method should only be used to cross an interface boundary where a controlled Task must be temporarily converted into an uncontrolled Task and then coverted back to a controlled Task .","title":"Remarks"},{"location":"ref/Microsoft.Coyote.Tasks/TaskExtensions/WrapInControlledTask/#see-also_1","text":"class Task<TResult> class TaskExtensions namespace Microsoft.Coyote.Tasks assembly Microsoft.Coyote","title":"See Also"},{"location":"samples/overview/","text":"Overview of Coyote samples All Coyote samples are available on GitHub . The repo is organized in two sets of samples. The first set shows how you can use Coyote to systematically test unmodified C# task-based programs: AccountManager : demonstrates how to write a simple task-based C# application to create, get and delete account records in a backend NoSQL database and then systematically test this application using Coyote to find a race condition. Read the accompanying two-parts tutorial available here and here . Coffee Machine Failover : demonstrates how to systematically test the failover logic in your task-based applications. Read the accompanying tutorial available here . BoundedBuffer : demonstrates how to use coyote rewrite to find deadlocks in unmodified C# code. Read more about this sample here . The second set shows how you can use the more advanced actor programming model of Coyote to build reliable applications and services: HelloWorldActors : demonstrates how to write a simple Coyote application using actors, and then run and systematically test it. Read the accompanying tutorial available here . CloudMessaging : demonstrates how to write a Coyote application that contains components that communicate with each other using the Azure Service Bus cloud messaging queue. ead the accompanying two-parts tutorial available here and here . Timers in Actors : demonstrates how to use the timer API of the Coyote actor programming model. Coffee Machine Failover : demonstrates how to systematically test the failover logic in your Coyote actor applications. Read the accompanying tutorial available here . Robot Navigator Failover : demonstrates how to systematically test the failover logic in your Coyote actors applications. Read more about this sample here . Building the samples To build the samples, clone the Coyote samples repo , then use the following PowerShell command line from a Visual Studio 2019 Developer Command Prompt: powershell -f build.ps1 In your local Coyote samples repo you can find the compiled binaries in the bin folder. You can use the coyote tool to automatically test these samples and find bugs. Read how to use the tool here .","title":"Overview"},{"location":"samples/overview/#overview-of-coyote-samples","text":"All Coyote samples are available on GitHub . The repo is organized in two sets of samples. The first set shows how you can use Coyote to systematically test unmodified C# task-based programs: AccountManager : demonstrates how to write a simple task-based C# application to create, get and delete account records in a backend NoSQL database and then systematically test this application using Coyote to find a race condition. Read the accompanying two-parts tutorial available here and here . Coffee Machine Failover : demonstrates how to systematically test the failover logic in your task-based applications. Read the accompanying tutorial available here . BoundedBuffer : demonstrates how to use coyote rewrite to find deadlocks in unmodified C# code. Read more about this sample here . The second set shows how you can use the more advanced actor programming model of Coyote to build reliable applications and services: HelloWorldActors : demonstrates how to write a simple Coyote application using actors, and then run and systematically test it. Read the accompanying tutorial available here . CloudMessaging : demonstrates how to write a Coyote application that contains components that communicate with each other using the Azure Service Bus cloud messaging queue. ead the accompanying two-parts tutorial available here and here . Timers in Actors : demonstrates how to use the timer API of the Coyote actor programming model. Coffee Machine Failover : demonstrates how to systematically test the failover logic in your Coyote actor applications. Read the accompanying tutorial available here . Robot Navigator Failover : demonstrates how to systematically test the failover logic in your Coyote actors applications. Read more about this sample here .","title":"Overview of Coyote samples"},{"location":"samples/overview/#building-the-samples","text":"To build the samples, clone the Coyote samples repo , then use the following PowerShell command line from a Visual Studio 2019 Developer Command Prompt: powershell -f build.ps1 In your local Coyote samples repo you can find the compiled binaries in the bin folder. You can use the coyote tool to automatically test these samples and find bugs. Read how to use the tool here .","title":"Building the samples"},{"location":"samples/actors/failover-robot-navigator/","text":"Failover robot navigator service with actors Wikipedia provides this definition : \u201c Failover is switching to a redundant or standby computer server, system, hardware component or network upon the failure or abnormal termination of the previously active application, server, system, hardware component, or network. Systems designers usually provide failover capability in servers, systems or networks requiring near-continuous availability and a high degree of reliability.\u201d This sample implements a failover scenario in a system where an instance of a service is terminated and replaced by a new one , unlike the Failover Coffee Machine sample , which is about applying the failover concept to the firmware of an automated espresso machine. In this scenario there is a Robot that must serve drinks to people in a room: Before starting to serve the next client the Robot is always at an InitialLocation in the room. In order to do its job the Robot needs the help of a service called the Navigator , which when provided with the latest picture of the room, finds a person who needs to be served next and sends the details (adult or minor, location) of that person to the Robot . It is not always possible to follow the straight line connecting the Robot \u2018s location with that of the selected client as there are obstacles, like furniture, in the room. Thus, the Robot asks the Navigator to produce a collision-free route from the Robot \u2018s location to the person who will be served. The Navigator provides the requested route that must be reached, with the last being that of the client. A route is simply a list of consecutive straight line segments. The Robot traverses the route and reaches the client. Then the Robot selects randomly an appropriate drink for the client: alcoholic for an adult and non-alcoholic for a minor client. The Robot pours a glass of the selected drink for the client and retreats to its InitialLocation . The steps 1 to 5 above are repeated continuously. To make this a failover test, at random times the Navigator is killed and a new Navigator is created to replace the old one. When this happens it is required that the system will continue to operate flawlessly: no data (request or response) between the Robot and a Navigator will be lost, and the Robot will not stop doing its job. The following diagram depicts the Failover workflow in this sample: Do note: 1. This is a general diagram that can be used not only in this scenario, but for any other scenarios involving a robot that operates with the help of object recognition and route planning. 2. The green nodes represent the product code we are testing here, and everything else is mock test infrastructure. The main goal is to show the use of coyote test in finding concurrency issues even at the design stage when the actual implementation hasn\u2019t started. For this reason we\u2019ve only provided mock implementations of the cognitive service, the route planner, and the storage service. The Navigator doesn\u2019t know these are mock implementations. 3. The sample uses the FailoverDriver component to perform the termination of the Navigator and the creation of a new Navigator . Also a MockStorage component is used to store the state needed to restart the newly-created instance without loss of state. The Robot and the Navigator are modeled as state machines and they are started by another state machine called FailoverDriver . The FailoverDriver lets the first Navigator instance run for a bit then it randomly kills it by sending it the TerminateEvent , then it starts a new Navigator . The new Navigator instance needs to figure out the state of any previous request: was the prior Navigator killed while having an incompletely processed request from the Robot or not? To be able to do so the Navigator stores any newly received request from the Robot in the MockStorage where it remains until the request is completely processed and the response is sent to the Robot and at that moment the Navigator deletes the pending request record from the MockStorage . Note that this is going one step further than the Coffee Machine example. In this example, not only are we testing that the Navigator can restart successfully, but we are also testing that the Robot is also able to handle that failover condition. The following diagram shows the overall plan where Navigator2 is able to complete the request started by Navigator1: The MockStorage is an Actor that provides simple key-value storage for persisting data and its instance lives across all instances of the Navigator . MockStorage makes Navigator failover possible. The MockStorage component, as its name implies, is a mock of a real-world service that provides similar storage capabilities. Likewise, the MockCognitiveService and MockRoutePlanner are mocks of real-world services providing cognitive services (such as object identification) and motion-path planning. Some safety Asserts are placed in the code that verify certain important things, including: - on reaching the client the Robot \u2018s coordinates must be the same as the client\u2019s. - the key retrieved from the MockStorage when requesting a read for a saved Robot \u2018s request is an expected non-null string. - the Navigator checks that after MockStorage performs a write operation to save a Robot \u2018s request this has not overwritten another existing value for the same storage key. This ensures a request from the Robot is not lost. - all required non-null parameters for MockStorage operations (such as key or requestorId ) are indeed non-null. There is a LivenessMonitor that monitors the execution of the system to make sure it never gets stuck, i.e., the Robot always gets a valid response to any of its requests from the Navigator and serves the selected client. See Liveness Checking . A number of excellent bugs were found by Coyote during the development of this sample, and this illustrates the fact that Coyote can be applied to find bugs quickly, even in the design stage, before coding and pushing to production. What you will need To run the DrinksServingRobotActors example, you will need to: Install Visual Studio 2019 . Install the .NET 5.0 version of the coyote tool . Clone the Coyote Samples git repo . Be familiar with the coyote tool. See using Coyote . Build the samples Build the coyote-samples repo by running the following command: powershell -f build.ps1 Running and testing the Drink Serving Robot Now you can run the DrinksServingRobotActors application: \"./bin/net5.0/DrinksServingRobotActors.exe\" When you run the executable like this without using coyote test (this is called running in production mode ), you will get infinite console output, that you can to terminate by pressing ENTER, similar to this: <FailoverDriver> ################################################################# <FailoverDriver> Starting the Robot. <CognitiveService> CognitiveService is starting. <Navigator> Navigator starting <Navigator> Got RobotId <Robot> Obtained a Room Picture at 2/11/2020 6:21:35 PM UTC <Robot> Asked for a new Drink Order <Navigator> There was no prior pending request to find drink clients ... <FailoverDriver> ################################################################# <FailoverDriver> # Starting the fail over of the Navigator # <FailoverDriver> ################################################################# <Navigator> Terminating as previously ordered ... <Navigator> Sent Termination Confirmation to my Creator ... <Navigator> Halting now ... <FailoverDriver> ***** The Navigator confirmed that it has terminated ***** <FailoverDriver> ***** Created a new Navigator -- paused ***** <FailoverDriver> ***** Waking up the new Navigator ***** <CognitiveService> CognitiveService is starting. <Navigator> Navigator starting <Navigator> Got RobotId <Navigator> Restarting the pending Robot's request to find drink clients ... <Robot> received a new Navigator, and pending drink order=True!!! <FailoverDriver> ***** Robot confirmed it reset to the new Navigator ***** <Robot> Received new Drink Order. Executing ... <Robot> Asked for driving instructions from ( 1, 1 ) to ( 26, 16 ) <Navigator> drink order is complete, deleting the job record. <Robot> Moving from ( 1, 1 ) to ( 26, 16 ) <Robot> Reached Client. <Robot> Serving order <Robot> Selected \"WaterMelonLemonade\" for Minor client <Robot> Filled a new glass of WaterMelonLemonade to 100% level <Robot> Finished serving the order. Retreating. ================================================== <Robot> Moving from ( 26, 16 ) to ( 1, 1 ) <Robot> Obtained a Room Picture at 2/11/2020 6:21:40 PM UTC <Robot> Asked for a new Drink Order <FailoverDriver> ################################################################# <FailoverDriver> # Starting the fail over of the Navigator # <FailoverDriver> ################################################################# <Navigator> Terminating as previously ordered ... <Navigator> Sent Termination Confirmation to my Creator ... <Navigator> Halting now ... <FailoverDriver> ***** The Navigator confirmed that it has terminated ***** <FailoverDriver> ***** Created a new Navigator -- paused ***** <CognitiveService> CognitiveService is starting. <FailoverDriver> ***** Waking up the new Navigator ***** <Navigator> Navigator starting <Navigator> Got RobotId <Robot> received a new Navigator, and pending drink order=True!!! <Navigator> Restarting the pending Robot's request to find drink clients ... <FailoverDriver> ***** Robot confirmed it reset to the new Navigator ***** <Robot> Received new Drink Order. Executing ... <Robot> Asked for driving instructions from ( 1, 1 ) to ( 14, 4 ) <Navigator> drink order is complete, deleting the job record. <Robot> Moving from ( 1, 1 ) to ( 6, 23 ) <Robot> Moving from ( 6, 23 ) to ( 14, 4 ) <Robot> Reached Client. <Robot> Serving order <Robot> Selected \"Sprite\" for Minor client <Robot> Filled a new glass of Sprite to 100% level <Robot> Finished serving the order. Retreating. ================================================== <Robot> Moving from ( 14, 4 ) to ( 1, 1 ) <Robot> Obtained a Room Picture at 2/11/2020 6:21:45 PM UTC <Robot> Asked for a new Drink Order <FailoverDriver> ################################################################# <FailoverDriver> # Starting the fail over of the Navigator # <FailoverDriver> ################################################################# <Navigator> Terminating as previously ordered ... <Navigator> Sent Termination Confirmation to my Creator ... <Navigator> Halting now ... <FailoverDriver> ***** The Navigator confirmed that it has terminated ***** <FailoverDriver> ***** Created a new Navigator -- paused ***** <CognitiveService> CognitiveService is starting. <FailoverDriver> ***** Waking up the new Navigator ***** <Navigator> Navigator starting <Navigator> Got RobotId <Robot> received a new Navigator, and pending drink order=True!!! <Navigator> Restarting the pending Robot's request to find drink clients ... <FailoverDriver> ***** Robot confirmed it reset to the new Navigator ***** <Robot> Received new Drink Order. Executing ... <Robot> Asked for driving instructions from ( 1, 1 ) to ( 25, 17 ) <Navigator> drink order is complete, deleting the job record. <Robot> Moving from ( 1, 1 ) to ( 2, 4 ) <Robot> Moving from ( 2, 4 ) to ( 25, 17 ) <Robot> Reached Client. <Robot> Serving order <Robot> Selected \"Water\" for Minor client <Robot> Filled a new glass of Water to 100% level <Robot> Finished serving the order. Retreating. ================================================== <Robot> Moving from ( 25, 17 ) to ( 1, 1 ) You can leave this running and you will see the FailoverDriver halting a Navigator instance at random times. Each halted machine is terminated and discarded, then a new Navigator instance is started. Each new Navigator instance figures out the exact state it should continue from, and you see that the Robot continues without incident. You can now use coyote test to test the code and see if any bugs can be found. From the CoyoteSamples folder enter this command: coyote test ./bin/net5.0/DrinksServingRobotActors.dll -i 1000 -ms 2000 --sch-pct 10 Chances are this will find a bug quickly, and you will see output from the test like this: . Testing .\\bin\\net5.0\\DrinksServingRobotActors.exe Starting TestingProcessScheduler in process 26236 ... Created '1' testing task. ... Task 0 is using 'pct' strategy (seed:324932188). ..... Iteration #1 ..... Iteration #2 ..... Iteration #3 ..... Iteration #4 ..... Iteration #5 ..... Iteration #6 ..... Iteration #7 ..... Iteration #8 ..... Iteration #9 ..... Iteration #10 ..... Iteration #20 ..... Iteration #30 ... Task 0 found a bug. ... Emitting task 0 traces: ..... Writing CoyoteOutput\\DrinksServingRobotActors_0_0.txt ..... Writing CoyoteOutput\\DrinksServingRobotActors_0_0.schedule ... Elapsed 0.5330326 sec. ... Testing statistics: ..... Found 1 bug. ... Scheduling statistics: ..... Explored 34 schedules: 0 fair and 34 unfair. ..... Found 2.94% buggy schedules. ... Elapsed 0.6310144 sec. . Done Notice that a log file is produced .bin\\net5.0\\Output\\DrinksServingRobot.exe\\CoyoteOutput\\DrinksServingRobot_0_1.txt . This log can be pretty big, it contains the test iteration that failed, and towards the end of this file you will see something like this: <ErrorLog> Microsoft.Coyote.Samples.DrinksServingRobot.LivenessMonitor detected liveness bug in hot state 'Busy' at the end of program execution. <StrategyLog> Found bug using 'PCT' strategy. <StrategyLog> Testing statistics: <StrategyLog> Found 1 bug. <StrategyLog> Scheduling statistics: <StrategyLog> Explored 9 schedules: 0 fair and 9 unfair. <StrategyLog> Found 11.11% buggy schedules. So the DrinksServingRobot has a liveness bug. Just 0.6 seconds were enough for coyote test to find this liveness bug, with 30 test iterations each doing up to 2000 async operations. This bug is hard to reproduce in a production run of the DrinksServingRobot. A bug exists in the code somewhere. Can you find it? You can find an explanation and fix at the end of this tutorial. How the sample works You already know the main components of the Drinks Serving Robot sample. Now is the time to understand the details. As with other tutorials the code that starts the program consists of a [Test] method that takes an IActorRuntime : public static class Program { private static bool RunForever = false; public static void Main() { ... RunForever = true; IActorRuntime runtime = RuntimeFactory.Create(conf); Execute(runtime); Console.ReadLine(); } [Microsoft.Coyote.SystematicTesting.Test] public static void Execute(IActorRuntime runtime) { runtime.RegisterMonitor<LivenessMonitor>(); ActorId driver = runtime.CreateActor(typeof(FailoverDriver), new FailoverDriver.ConfigEvent(RunForever)); } } You already know from the Hello World tutorials how the two main entry points are used in a Coyote program. What is new here is that the Execute() method registers a LivenessMonitor used by Coyote to find liveness bugs. The rest of the execution is controlled by the FailoverDriver . The FailoverDriver The FailoverDriver state machine has two states: Init : This is the initial state of the machine where it creates everything, including the MockStorage , Navigator and Robot machines. Active : When the robot is ready, a timer is started to begin the failover process by going to the next state. TerminatingNavigator : This state performs the failover of the Navigator . It does this by sending a special termination event to the Navigator , and once that is confirmed, it goes back to the Active state where a new Navigator will be created. This happens once during a coyote test run, and it happens forever when running in production mode. The Robot The Robot has the most states compared to all state machines in this sample as it does all the visible work: the Start state Init , Active , ExecutingOrder , ReachingClient , MovingOnRoute , ServingClient , and FinishState . The Init and Active states perform processing that is relevant from the perspective of failover, while the remaining states do simple serving-related processing and aren\u2019t described in detail here. You can review the code of the sample to see exactly what the Robot does to serve the client. Init : This is the initial state of the machine. The Robot is initialized and then waits for a Navigator to present itself. If a previous Navigator has been killed, the Robot cleans up its own state. The Robot confirms to the FailoverDriver that it has started using the new Navigator . Active : In this state the Robot asks the Navigator for a DrinkOrder , sending it a new Picture of the room. Then the Robot waits for the Navigator to confirm that this request has been recorded. Having received this confirmation the Robot itself informs the FailoverDriver that the handshake with the Navigator is complete and now it is safe to do termination of the Navigator . Think of this as a type of distributed transaction. There is no point terminating the Navigator before the order is stored because it would not be an interesting test. After the Robot receives the requested DrinkOrder it goes to state ExecutingOrder The Navigator The Navigator receives a drink request from the robot, and coordinates that with 2 back end services, a cognitive service that can recognize people in an image, and a route planning service that can figure out how to drive the robot around your house. The Navigator uses a Storage service to persist any state it needs in order to survive the failover test. The Navigator has these states: the Start state Init , Paused , and Active : Init : This is the initial state of the Navigator . After initialization, it pushes the state Paused . Paused : In this state the Navigator is woken up by the FailoverDriver . Then it says \u201cHello\u201d to the Robot and then the Navigator checks for any existing pending request that was already saved in the Storage . If a pending request exists, the Navigator restarts processing this request. Finally, when all this is done, the Navigator goes to state Active . Active : In this state the Navigator receives two types of requests from the Robot : a drink order request and a request for driving instructions. It first saves the request in the Storage and confirms to the Robot that its request has been recorded, then asks the CognitiveService to find a client in the picture of the room, whom the Robot can serve. For DrivingInstructions the Navigator asks the RoutePlannerService to produce a collision-free route from the Robot to the selected client. Finally, when the Navigator receives the requested data from the CognitiveService or the RoutePlannerService it sends the result back to the Robot . The MockStorage MockStorage is a Coyote Actor that models the asynchronous nature of a typical cloud-based storage service. It supports simple read, write, and delete operations where write operations are confirmed with a ConfirmedEvent . This is an Actor model of pseudo-transactional storage. The MockStorage actor receives three kinds of events: a ReadKeyEvent , a KeyValueEvent (requesting the writing of a value under the specified key) and a DeleteKeyEvent . The MockStorage replies with two kinds of events: a KeyValueEvent in response to a ReadKeyEvent and a ConfirmedEvent in response to a (write) KeyValueEvent . This is quite simple processing as you can see when reviewing the code of the sample. Besides the usual functionality, note that the ConfirmedEvent has a boolean Existing member to show if a write operation replaced an existing value under the same key. This can be used by the client of the MockStorage to determine if a key was replaced. For example, the Navigator does actually use this to write a safety Assert checking to make sure a pending drink order request isn\u2019t getting lost in the failover process. The Liveness monitor The LivenessMonitor (See Liveness Checking ) monitors the Robot and the Navigator to make sure the Robot always finishes the job, by serving a Drink . This \u201cliveness\u201d property can be enforced using a very simple LivenessMonitor as shown below: internal class LivenessMonitor : Monitor { public class BusyEvent : Event { } public class IdleEvent : Event { } [Start] [Cold] [OnEventGotoState(typeof(BusyEvent), typeof(Busy))] [IgnoreEvents(typeof(IdleEvent))] private class Idle : State { } [Hot] [OnEventGotoState(typeof(IdleEvent), typeof(Idle))] [IgnoreEvents(typeof(BusyEvent))] private class Busy : State { } } The Robot can send events to this monitor to tell it when to switch into Busy or Idle state. When the Robot requests a DrinkOrder or DrivingInstructions from the Navigator , it sends this event: this.Monitor<LivenessMonitor>(new LivenessMonitor.BusyEvent()); And when the Robot finishes an order it sends this event: this.Monitor<LivenessMonitor>(new LivenessMonitor.IdleEvent()); The Busy state is marked as a [Hot] state and the Idle state is marked as a [Cold] state. During testing if coyote test finds the LivenessMonitor to be stuck in the [Hot] state for too long it raises an exception and the test fails. This is in fact the failure that is detected during the test. Explanation of the bug Remember the last lines of the coyote test execution log file: <ErrorLog> Monitor 'Microsoft.Coyote.Samples.DrinksServingRobot.LivenessMonitor' detected liveness bug in hot state 'Busy' at the end of program execution. If you add to the coyote test command line --graph-bug , and test again: coyote test .\\bin\\net5.0\\DrinksServingRobotActors.dll -i 1000 -ms 2000 --sch-pct 10 --graph-bug you\u2019ll see in the output of the tester that a DGML diagram has been produced: ..... Writing CoyoteOutput\\DrinksServingRobotActors_0_0.dgml Open this with Visual Studio 2019 and you will see a diagram like this. Here the diagram is also animated using the contents of the --xml-trace output so you can see the sequence of events leading up to the bug. MockStateMachineTimer information was removed from this graph just to simplify the diagram: This is the exact snapshot at the time when the bug manifested. This diagram shows that the first Navigator (Navigator(6)) was terminated by the FailoverDriver , which then created a second Navigator (Navigator(13)). The link from this Navigator to the Robot shows that the Navigator registered itself with the Robot . What looks bad is that there is no link from the Robot to this Navigator . The Robot never sent any request and remained waiting. This is in fact the liveness bug! But who sent it in the Active state? The diagram clearly shows that MovingOnRoute was the state from which the transition occurred. The state MovingOnRoute is very simple. It processes a single type of event ( MoveTimerElapsedEvent ) with the NextMove() action: [OnEventDoAction(typeof(MoveTimerElapsedEvent), nameof(NextMove))] [IgnoreEvents(typeof(Navigator.DrinkOrderProducedEvent))] internal class MovingOnRoute : State { } private void NextMove() { this.DrinkOrderPending = false; if (this.Route == null) { return; } if (!this.Route.Any()) { this.StopMoving(); this.RaiseGotoStateEvent<ServingClient>(); this.WriteLine(\"<Robot> Reached Client.\"); Specification.Assert( this.Coordinates == this.CurrentOrder.ClientDetails.Coordinates, \"Having reached the Client the Robot's coordinates must be the same \" + \"as the Client's, but they aren't\"); } else { var nextDestination = this.Route[0]; this.Route.RemoveAt(0); this.MoveTo(nextDestination); this.Timers[\"MoveTimer\"] = this.StartTimer(TimeSpan.FromSeconds(MoveDuration), new MoveTimerElapsedEvent()); } } Note that in this code there is no transition or even mentioning of the state Active \u2026 so how was it possible to transition from MovingOnRoute to Active ? The diagram shows exactly what happened: The Navigator registered itself sending a Navigator.RegisterNavigatorEvent to the Robot . When the Robot dequeued this event, it was in state MovingOnRoute . But this state doesn\u2019t process registrations from the Robot . Then who processed this event? The diagram again answers this. See that the state Init pushed the Active state, and then the following states all happened on the top of the active states stack, with Init below. This was done on purpose so that only one state, Init , should have to deal with the registration of the Navigator . State Init processed the registration of the Navigator , then transitioned to state Active . So what happened was that the robot was in the MoveOnRoute state when Navigator failover occurred. The new Navigator (13) started up and sent the RegisterNavigatorEvent , and the OnSetNavigator sees that this is a failover condition, because this.NavigatorId is already set, so it aborts the current robot move on route operation and goes back to the Active state using this.RaiseGotoStateEvent<Active>() But what happened to the Robot in state Active ? Why it didn\u2019t send any request to the Navigator ? This code fragment explains what happened: [OnEntry(nameof(OnInitActive))] [OnEventGotoState(typeof(Navigator.DrinkOrderProducedEvent), typeof(ExecutingOrder))] [OnEventDoAction(typeof(Navigator.DrinkOrderConfirmedEvent), nameof(OnDrinkOrderConfirmed))] internal class Active : State { } private void OnInitActive() { if (!this.DrinkOrderPending) { this.SendEvent(this.NavigatorId, new Navigator.GetDrinkOrderEvent(this.GetPicture())); this.WriteLine(\"<Robot> Asked for a new Drink Order\"); } this.Monitor<LivenessMonitor>(new LivenessMonitor.BusyEvent()); } The Robot didn\u2019t send a request to the Navigator , because this.DrinkOrderPending was true (when in fact it should have been false ). The Robot just informed the LivenessMonitor that it is busy, and then waited (forever) to receive the Navigator \u2018s response to the pending order it believed was coming. But it was out of sync with the Navigator because there was no pending order in the Storage service. Thus, the reason for the bug is the incorrect value of this.DrinkOrderPending in state MovingOnRoute at the time of the registration event. Look at the code of Robot.cs where this.DrinkOrderPending is being modified. The only place where this is set to false is in the NextMove() method: private void NextMove() { this.DrinkOrderPending = false; ... } Unfortunately, this is too late\u2026 So when is the right moment to set this.DrinkOrderPending to false ? This is a classic timing bug then, and the coyote tester was able to uncover this bug because it takes control of all the timing and ordering of messages between the actors. The problem is the Navigator considers the drink request complete (and clears the Storage of that request) when it returns the DrivingInstructionsEvent. This event is handled by the robot in the method ReachClient. So this is where the Robot should be clearing its internal DrinkOrderPending state: private void ReachClient(Event e) { var route = (e as DrivingInstructionsEvent)?.Route; if (route != null) { this.Route = route; // this.DrinkOrderPending = false; // this is where it really belongs. this.Timers[\"MoveTimer\"] = this.StartTimer(TimeSpan.FromSeconds(MoveDuration), new MoveTimerElapsedEvent()); } this.RaiseGotoStateEvent<MovingOnRoute>(); } You can even see the fix for the bug in the code above. Although currently commented out, this is the exact place to set DrinkOrderPending to false . So, the fix is to remove from the NextMove() method this line: this.DrinkOrderPending = false; and to move it into the ReachClient() method (or just uncomment the fix that is hidden there). After you perform this fix and rebuild the sample, try running coyote test again with the same command line which previously reported the liveness bug: coyote test ./bin/net5.0/DrinksServingRobotActors.dll -i 1000 -ms 2000 --sch-pct 10 And now no bug will be found \u2013 you should get result similar to this: ..... Iteration #800 ..... Iteration #800 ..... Iteration #900 ..... Iteration #900 ..... Iteration #1000 ..... Iteration #1000 ... Testing statistics: ..... Found 0 bugs. ... Scheduling statistics: ..... Explored 2000 schedules: 0 fair and 2000 unfair. ..... Hit the max-steps bound of '2000' in 8.55% of the unfair schedules. ... Elapsed 25.7423125 sec. . Done If you want to have a high degree of certainty that no bug is found, run the coyote tester with a sufficiently big number of iterations, say 100,000 and --parallel N where N is a number that works well on your computer. If N is too high it will thrash your CPU and the test will run slowly. A good rule of thumb is to use ceiling(0.65 * NUMBER_OF_PROCESSORS) . NUMBER_OF_PROCESSORS is a system environment variable, typically equal to the number of cores in the computer. But sometimes this number is doubled if your computer supports hyper-threading. Summary Failover testing is simple to achieve using Coyote and yields many interesting bugs in your code, including some thought-provoking design bugs. The technique of halting a \u201cproduction\u201d state-machine, and recreating it by reading from a \u201cpersistent\u201d MockStorage (which is not halted during testing) can be generalized to many other scenarios (such as actual cloud services) where someone needs to test failover logic of production actors using Coyote. In this tutorial you learned: How to do failover testing using a Coyote FailoverDriver state machine. How to use Coyote to test failover in a service. How to use --sch-pct testing on multiple processes to find tricky bugs more quickly. How to specify the --graph-bug argument so that the coyote test tool would produce a snapshot-DGML diagram of the final state of the system when the bug was found. How to use RaisePushStateEvent() and RaisePopStateEvent() to achieve additional simplicity in handling common events in one place. How Assert helps find violations of safety properties during testing. How to ensure graceful termination of one state machine (before creating a new one) via the TerminateEvent and HaltedEvent handshake between the FailoverDriver and the Navigator. How to write and use a LivenessMonitor in order to discover tricky liveness bugs.","title":"Robot navigator failover"},{"location":"samples/actors/failover-robot-navigator/#failover-robot-navigator-service-with-actors","text":"Wikipedia provides this definition : \u201c Failover is switching to a redundant or standby computer server, system, hardware component or network upon the failure or abnormal termination of the previously active application, server, system, hardware component, or network. Systems designers usually provide failover capability in servers, systems or networks requiring near-continuous availability and a high degree of reliability.\u201d This sample implements a failover scenario in a system where an instance of a service is terminated and replaced by a new one , unlike the Failover Coffee Machine sample , which is about applying the failover concept to the firmware of an automated espresso machine. In this scenario there is a Robot that must serve drinks to people in a room: Before starting to serve the next client the Robot is always at an InitialLocation in the room. In order to do its job the Robot needs the help of a service called the Navigator , which when provided with the latest picture of the room, finds a person who needs to be served next and sends the details (adult or minor, location) of that person to the Robot . It is not always possible to follow the straight line connecting the Robot \u2018s location with that of the selected client as there are obstacles, like furniture, in the room. Thus, the Robot asks the Navigator to produce a collision-free route from the Robot \u2018s location to the person who will be served. The Navigator provides the requested route that must be reached, with the last being that of the client. A route is simply a list of consecutive straight line segments. The Robot traverses the route and reaches the client. Then the Robot selects randomly an appropriate drink for the client: alcoholic for an adult and non-alcoholic for a minor client. The Robot pours a glass of the selected drink for the client and retreats to its InitialLocation . The steps 1 to 5 above are repeated continuously. To make this a failover test, at random times the Navigator is killed and a new Navigator is created to replace the old one. When this happens it is required that the system will continue to operate flawlessly: no data (request or response) between the Robot and a Navigator will be lost, and the Robot will not stop doing its job. The following diagram depicts the Failover workflow in this sample: Do note: 1. This is a general diagram that can be used not only in this scenario, but for any other scenarios involving a robot that operates with the help of object recognition and route planning. 2. The green nodes represent the product code we are testing here, and everything else is mock test infrastructure. The main goal is to show the use of coyote test in finding concurrency issues even at the design stage when the actual implementation hasn\u2019t started. For this reason we\u2019ve only provided mock implementations of the cognitive service, the route planner, and the storage service. The Navigator doesn\u2019t know these are mock implementations. 3. The sample uses the FailoverDriver component to perform the termination of the Navigator and the creation of a new Navigator . Also a MockStorage component is used to store the state needed to restart the newly-created instance without loss of state. The Robot and the Navigator are modeled as state machines and they are started by another state machine called FailoverDriver . The FailoverDriver lets the first Navigator instance run for a bit then it randomly kills it by sending it the TerminateEvent , then it starts a new Navigator . The new Navigator instance needs to figure out the state of any previous request: was the prior Navigator killed while having an incompletely processed request from the Robot or not? To be able to do so the Navigator stores any newly received request from the Robot in the MockStorage where it remains until the request is completely processed and the response is sent to the Robot and at that moment the Navigator deletes the pending request record from the MockStorage . Note that this is going one step further than the Coffee Machine example. In this example, not only are we testing that the Navigator can restart successfully, but we are also testing that the Robot is also able to handle that failover condition. The following diagram shows the overall plan where Navigator2 is able to complete the request started by Navigator1: The MockStorage is an Actor that provides simple key-value storage for persisting data and its instance lives across all instances of the Navigator . MockStorage makes Navigator failover possible. The MockStorage component, as its name implies, is a mock of a real-world service that provides similar storage capabilities. Likewise, the MockCognitiveService and MockRoutePlanner are mocks of real-world services providing cognitive services (such as object identification) and motion-path planning. Some safety Asserts are placed in the code that verify certain important things, including: - on reaching the client the Robot \u2018s coordinates must be the same as the client\u2019s. - the key retrieved from the MockStorage when requesting a read for a saved Robot \u2018s request is an expected non-null string. - the Navigator checks that after MockStorage performs a write operation to save a Robot \u2018s request this has not overwritten another existing value for the same storage key. This ensures a request from the Robot is not lost. - all required non-null parameters for MockStorage operations (such as key or requestorId ) are indeed non-null. There is a LivenessMonitor that monitors the execution of the system to make sure it never gets stuck, i.e., the Robot always gets a valid response to any of its requests from the Navigator and serves the selected client. See Liveness Checking . A number of excellent bugs were found by Coyote during the development of this sample, and this illustrates the fact that Coyote can be applied to find bugs quickly, even in the design stage, before coding and pushing to production.","title":"Failover robot navigator service with actors"},{"location":"samples/actors/failover-robot-navigator/#what-you-will-need","text":"To run the DrinksServingRobotActors example, you will need to: Install Visual Studio 2019 . Install the .NET 5.0 version of the coyote tool . Clone the Coyote Samples git repo . Be familiar with the coyote tool. See using Coyote .","title":"What you will need"},{"location":"samples/actors/failover-robot-navigator/#build-the-samples","text":"Build the coyote-samples repo by running the following command: powershell -f build.ps1","title":"Build the samples"},{"location":"samples/actors/failover-robot-navigator/#running-and-testing-the-drink-serving-robot","text":"Now you can run the DrinksServingRobotActors application: \"./bin/net5.0/DrinksServingRobotActors.exe\" When you run the executable like this without using coyote test (this is called running in production mode ), you will get infinite console output, that you can to terminate by pressing ENTER, similar to this: <FailoverDriver> ################################################################# <FailoverDriver> Starting the Robot. <CognitiveService> CognitiveService is starting. <Navigator> Navigator starting <Navigator> Got RobotId <Robot> Obtained a Room Picture at 2/11/2020 6:21:35 PM UTC <Robot> Asked for a new Drink Order <Navigator> There was no prior pending request to find drink clients ... <FailoverDriver> ################################################################# <FailoverDriver> # Starting the fail over of the Navigator # <FailoverDriver> ################################################################# <Navigator> Terminating as previously ordered ... <Navigator> Sent Termination Confirmation to my Creator ... <Navigator> Halting now ... <FailoverDriver> ***** The Navigator confirmed that it has terminated ***** <FailoverDriver> ***** Created a new Navigator -- paused ***** <FailoverDriver> ***** Waking up the new Navigator ***** <CognitiveService> CognitiveService is starting. <Navigator> Navigator starting <Navigator> Got RobotId <Navigator> Restarting the pending Robot's request to find drink clients ... <Robot> received a new Navigator, and pending drink order=True!!! <FailoverDriver> ***** Robot confirmed it reset to the new Navigator ***** <Robot> Received new Drink Order. Executing ... <Robot> Asked for driving instructions from ( 1, 1 ) to ( 26, 16 ) <Navigator> drink order is complete, deleting the job record. <Robot> Moving from ( 1, 1 ) to ( 26, 16 ) <Robot> Reached Client. <Robot> Serving order <Robot> Selected \"WaterMelonLemonade\" for Minor client <Robot> Filled a new glass of WaterMelonLemonade to 100% level <Robot> Finished serving the order. Retreating. ================================================== <Robot> Moving from ( 26, 16 ) to ( 1, 1 ) <Robot> Obtained a Room Picture at 2/11/2020 6:21:40 PM UTC <Robot> Asked for a new Drink Order <FailoverDriver> ################################################################# <FailoverDriver> # Starting the fail over of the Navigator # <FailoverDriver> ################################################################# <Navigator> Terminating as previously ordered ... <Navigator> Sent Termination Confirmation to my Creator ... <Navigator> Halting now ... <FailoverDriver> ***** The Navigator confirmed that it has terminated ***** <FailoverDriver> ***** Created a new Navigator -- paused ***** <CognitiveService> CognitiveService is starting. <FailoverDriver> ***** Waking up the new Navigator ***** <Navigator> Navigator starting <Navigator> Got RobotId <Robot> received a new Navigator, and pending drink order=True!!! <Navigator> Restarting the pending Robot's request to find drink clients ... <FailoverDriver> ***** Robot confirmed it reset to the new Navigator ***** <Robot> Received new Drink Order. Executing ... <Robot> Asked for driving instructions from ( 1, 1 ) to ( 14, 4 ) <Navigator> drink order is complete, deleting the job record. <Robot> Moving from ( 1, 1 ) to ( 6, 23 ) <Robot> Moving from ( 6, 23 ) to ( 14, 4 ) <Robot> Reached Client. <Robot> Serving order <Robot> Selected \"Sprite\" for Minor client <Robot> Filled a new glass of Sprite to 100% level <Robot> Finished serving the order. Retreating. ================================================== <Robot> Moving from ( 14, 4 ) to ( 1, 1 ) <Robot> Obtained a Room Picture at 2/11/2020 6:21:45 PM UTC <Robot> Asked for a new Drink Order <FailoverDriver> ################################################################# <FailoverDriver> # Starting the fail over of the Navigator # <FailoverDriver> ################################################################# <Navigator> Terminating as previously ordered ... <Navigator> Sent Termination Confirmation to my Creator ... <Navigator> Halting now ... <FailoverDriver> ***** The Navigator confirmed that it has terminated ***** <FailoverDriver> ***** Created a new Navigator -- paused ***** <CognitiveService> CognitiveService is starting. <FailoverDriver> ***** Waking up the new Navigator ***** <Navigator> Navigator starting <Navigator> Got RobotId <Robot> received a new Navigator, and pending drink order=True!!! <Navigator> Restarting the pending Robot's request to find drink clients ... <FailoverDriver> ***** Robot confirmed it reset to the new Navigator ***** <Robot> Received new Drink Order. Executing ... <Robot> Asked for driving instructions from ( 1, 1 ) to ( 25, 17 ) <Navigator> drink order is complete, deleting the job record. <Robot> Moving from ( 1, 1 ) to ( 2, 4 ) <Robot> Moving from ( 2, 4 ) to ( 25, 17 ) <Robot> Reached Client. <Robot> Serving order <Robot> Selected \"Water\" for Minor client <Robot> Filled a new glass of Water to 100% level <Robot> Finished serving the order. Retreating. ================================================== <Robot> Moving from ( 25, 17 ) to ( 1, 1 ) You can leave this running and you will see the FailoverDriver halting a Navigator instance at random times. Each halted machine is terminated and discarded, then a new Navigator instance is started. Each new Navigator instance figures out the exact state it should continue from, and you see that the Robot continues without incident. You can now use coyote test to test the code and see if any bugs can be found. From the CoyoteSamples folder enter this command: coyote test ./bin/net5.0/DrinksServingRobotActors.dll -i 1000 -ms 2000 --sch-pct 10 Chances are this will find a bug quickly, and you will see output from the test like this: . Testing .\\bin\\net5.0\\DrinksServingRobotActors.exe Starting TestingProcessScheduler in process 26236 ... Created '1' testing task. ... Task 0 is using 'pct' strategy (seed:324932188). ..... Iteration #1 ..... Iteration #2 ..... Iteration #3 ..... Iteration #4 ..... Iteration #5 ..... Iteration #6 ..... Iteration #7 ..... Iteration #8 ..... Iteration #9 ..... Iteration #10 ..... Iteration #20 ..... Iteration #30 ... Task 0 found a bug. ... Emitting task 0 traces: ..... Writing CoyoteOutput\\DrinksServingRobotActors_0_0.txt ..... Writing CoyoteOutput\\DrinksServingRobotActors_0_0.schedule ... Elapsed 0.5330326 sec. ... Testing statistics: ..... Found 1 bug. ... Scheduling statistics: ..... Explored 34 schedules: 0 fair and 34 unfair. ..... Found 2.94% buggy schedules. ... Elapsed 0.6310144 sec. . Done Notice that a log file is produced .bin\\net5.0\\Output\\DrinksServingRobot.exe\\CoyoteOutput\\DrinksServingRobot_0_1.txt . This log can be pretty big, it contains the test iteration that failed, and towards the end of this file you will see something like this: <ErrorLog> Microsoft.Coyote.Samples.DrinksServingRobot.LivenessMonitor detected liveness bug in hot state 'Busy' at the end of program execution. <StrategyLog> Found bug using 'PCT' strategy. <StrategyLog> Testing statistics: <StrategyLog> Found 1 bug. <StrategyLog> Scheduling statistics: <StrategyLog> Explored 9 schedules: 0 fair and 9 unfair. <StrategyLog> Found 11.11% buggy schedules. So the DrinksServingRobot has a liveness bug. Just 0.6 seconds were enough for coyote test to find this liveness bug, with 30 test iterations each doing up to 2000 async operations. This bug is hard to reproduce in a production run of the DrinksServingRobot. A bug exists in the code somewhere. Can you find it? You can find an explanation and fix at the end of this tutorial.","title":"Running and testing the Drink Serving Robot"},{"location":"samples/actors/failover-robot-navigator/#how-the-sample-works","text":"You already know the main components of the Drinks Serving Robot sample. Now is the time to understand the details. As with other tutorials the code that starts the program consists of a [Test] method that takes an IActorRuntime : public static class Program { private static bool RunForever = false; public static void Main() { ... RunForever = true; IActorRuntime runtime = RuntimeFactory.Create(conf); Execute(runtime); Console.ReadLine(); } [Microsoft.Coyote.SystematicTesting.Test] public static void Execute(IActorRuntime runtime) { runtime.RegisterMonitor<LivenessMonitor>(); ActorId driver = runtime.CreateActor(typeof(FailoverDriver), new FailoverDriver.ConfigEvent(RunForever)); } } You already know from the Hello World tutorials how the two main entry points are used in a Coyote program. What is new here is that the Execute() method registers a LivenessMonitor used by Coyote to find liveness bugs. The rest of the execution is controlled by the FailoverDriver .","title":"How the sample works"},{"location":"samples/actors/failover-robot-navigator/#the-failoverdriver","text":"The FailoverDriver state machine has two states: Init : This is the initial state of the machine where it creates everything, including the MockStorage , Navigator and Robot machines. Active : When the robot is ready, a timer is started to begin the failover process by going to the next state. TerminatingNavigator : This state performs the failover of the Navigator . It does this by sending a special termination event to the Navigator , and once that is confirmed, it goes back to the Active state where a new Navigator will be created. This happens once during a coyote test run, and it happens forever when running in production mode.","title":"The FailoverDriver"},{"location":"samples/actors/failover-robot-navigator/#the-robot","text":"The Robot has the most states compared to all state machines in this sample as it does all the visible work: the Start state Init , Active , ExecutingOrder , ReachingClient , MovingOnRoute , ServingClient , and FinishState . The Init and Active states perform processing that is relevant from the perspective of failover, while the remaining states do simple serving-related processing and aren\u2019t described in detail here. You can review the code of the sample to see exactly what the Robot does to serve the client. Init : This is the initial state of the machine. The Robot is initialized and then waits for a Navigator to present itself. If a previous Navigator has been killed, the Robot cleans up its own state. The Robot confirms to the FailoverDriver that it has started using the new Navigator . Active : In this state the Robot asks the Navigator for a DrinkOrder , sending it a new Picture of the room. Then the Robot waits for the Navigator to confirm that this request has been recorded. Having received this confirmation the Robot itself informs the FailoverDriver that the handshake with the Navigator is complete and now it is safe to do termination of the Navigator . Think of this as a type of distributed transaction. There is no point terminating the Navigator before the order is stored because it would not be an interesting test. After the Robot receives the requested DrinkOrder it goes to state ExecutingOrder","title":"The Robot"},{"location":"samples/actors/failover-robot-navigator/#the-navigator","text":"The Navigator receives a drink request from the robot, and coordinates that with 2 back end services, a cognitive service that can recognize people in an image, and a route planning service that can figure out how to drive the robot around your house. The Navigator uses a Storage service to persist any state it needs in order to survive the failover test. The Navigator has these states: the Start state Init , Paused , and Active : Init : This is the initial state of the Navigator . After initialization, it pushes the state Paused . Paused : In this state the Navigator is woken up by the FailoverDriver . Then it says \u201cHello\u201d to the Robot and then the Navigator checks for any existing pending request that was already saved in the Storage . If a pending request exists, the Navigator restarts processing this request. Finally, when all this is done, the Navigator goes to state Active . Active : In this state the Navigator receives two types of requests from the Robot : a drink order request and a request for driving instructions. It first saves the request in the Storage and confirms to the Robot that its request has been recorded, then asks the CognitiveService to find a client in the picture of the room, whom the Robot can serve. For DrivingInstructions the Navigator asks the RoutePlannerService to produce a collision-free route from the Robot to the selected client. Finally, when the Navigator receives the requested data from the CognitiveService or the RoutePlannerService it sends the result back to the Robot .","title":"The Navigator"},{"location":"samples/actors/failover-robot-navigator/#the-mockstorage","text":"MockStorage is a Coyote Actor that models the asynchronous nature of a typical cloud-based storage service. It supports simple read, write, and delete operations where write operations are confirmed with a ConfirmedEvent . This is an Actor model of pseudo-transactional storage. The MockStorage actor receives three kinds of events: a ReadKeyEvent , a KeyValueEvent (requesting the writing of a value under the specified key) and a DeleteKeyEvent . The MockStorage replies with two kinds of events: a KeyValueEvent in response to a ReadKeyEvent and a ConfirmedEvent in response to a (write) KeyValueEvent . This is quite simple processing as you can see when reviewing the code of the sample. Besides the usual functionality, note that the ConfirmedEvent has a boolean Existing member to show if a write operation replaced an existing value under the same key. This can be used by the client of the MockStorage to determine if a key was replaced. For example, the Navigator does actually use this to write a safety Assert checking to make sure a pending drink order request isn\u2019t getting lost in the failover process.","title":"The MockStorage"},{"location":"samples/actors/failover-robot-navigator/#the-liveness-monitor","text":"The LivenessMonitor (See Liveness Checking ) monitors the Robot and the Navigator to make sure the Robot always finishes the job, by serving a Drink . This \u201cliveness\u201d property can be enforced using a very simple LivenessMonitor as shown below: internal class LivenessMonitor : Monitor { public class BusyEvent : Event { } public class IdleEvent : Event { } [Start] [Cold] [OnEventGotoState(typeof(BusyEvent), typeof(Busy))] [IgnoreEvents(typeof(IdleEvent))] private class Idle : State { } [Hot] [OnEventGotoState(typeof(IdleEvent), typeof(Idle))] [IgnoreEvents(typeof(BusyEvent))] private class Busy : State { } } The Robot can send events to this monitor to tell it when to switch into Busy or Idle state. When the Robot requests a DrinkOrder or DrivingInstructions from the Navigator , it sends this event: this.Monitor<LivenessMonitor>(new LivenessMonitor.BusyEvent()); And when the Robot finishes an order it sends this event: this.Monitor<LivenessMonitor>(new LivenessMonitor.IdleEvent()); The Busy state is marked as a [Hot] state and the Idle state is marked as a [Cold] state. During testing if coyote test finds the LivenessMonitor to be stuck in the [Hot] state for too long it raises an exception and the test fails. This is in fact the failure that is detected during the test.","title":"The Liveness monitor"},{"location":"samples/actors/failover-robot-navigator/#explanation-of-the-bug","text":"Remember the last lines of the coyote test execution log file: <ErrorLog> Monitor 'Microsoft.Coyote.Samples.DrinksServingRobot.LivenessMonitor' detected liveness bug in hot state 'Busy' at the end of program execution. If you add to the coyote test command line --graph-bug , and test again: coyote test .\\bin\\net5.0\\DrinksServingRobotActors.dll -i 1000 -ms 2000 --sch-pct 10 --graph-bug you\u2019ll see in the output of the tester that a DGML diagram has been produced: ..... Writing CoyoteOutput\\DrinksServingRobotActors_0_0.dgml Open this with Visual Studio 2019 and you will see a diagram like this. Here the diagram is also animated using the contents of the --xml-trace output so you can see the sequence of events leading up to the bug. MockStateMachineTimer information was removed from this graph just to simplify the diagram: This is the exact snapshot at the time when the bug manifested. This diagram shows that the first Navigator (Navigator(6)) was terminated by the FailoverDriver , which then created a second Navigator (Navigator(13)). The link from this Navigator to the Robot shows that the Navigator registered itself with the Robot . What looks bad is that there is no link from the Robot to this Navigator . The Robot never sent any request and remained waiting. This is in fact the liveness bug! But who sent it in the Active state? The diagram clearly shows that MovingOnRoute was the state from which the transition occurred. The state MovingOnRoute is very simple. It processes a single type of event ( MoveTimerElapsedEvent ) with the NextMove() action: [OnEventDoAction(typeof(MoveTimerElapsedEvent), nameof(NextMove))] [IgnoreEvents(typeof(Navigator.DrinkOrderProducedEvent))] internal class MovingOnRoute : State { } private void NextMove() { this.DrinkOrderPending = false; if (this.Route == null) { return; } if (!this.Route.Any()) { this.StopMoving(); this.RaiseGotoStateEvent<ServingClient>(); this.WriteLine(\"<Robot> Reached Client.\"); Specification.Assert( this.Coordinates == this.CurrentOrder.ClientDetails.Coordinates, \"Having reached the Client the Robot's coordinates must be the same \" + \"as the Client's, but they aren't\"); } else { var nextDestination = this.Route[0]; this.Route.RemoveAt(0); this.MoveTo(nextDestination); this.Timers[\"MoveTimer\"] = this.StartTimer(TimeSpan.FromSeconds(MoveDuration), new MoveTimerElapsedEvent()); } } Note that in this code there is no transition or even mentioning of the state Active \u2026 so how was it possible to transition from MovingOnRoute to Active ? The diagram shows exactly what happened: The Navigator registered itself sending a Navigator.RegisterNavigatorEvent to the Robot . When the Robot dequeued this event, it was in state MovingOnRoute . But this state doesn\u2019t process registrations from the Robot . Then who processed this event? The diagram again answers this. See that the state Init pushed the Active state, and then the following states all happened on the top of the active states stack, with Init below. This was done on purpose so that only one state, Init , should have to deal with the registration of the Navigator . State Init processed the registration of the Navigator , then transitioned to state Active . So what happened was that the robot was in the MoveOnRoute state when Navigator failover occurred. The new Navigator (13) started up and sent the RegisterNavigatorEvent , and the OnSetNavigator sees that this is a failover condition, because this.NavigatorId is already set, so it aborts the current robot move on route operation and goes back to the Active state using this.RaiseGotoStateEvent<Active>() But what happened to the Robot in state Active ? Why it didn\u2019t send any request to the Navigator ? This code fragment explains what happened: [OnEntry(nameof(OnInitActive))] [OnEventGotoState(typeof(Navigator.DrinkOrderProducedEvent), typeof(ExecutingOrder))] [OnEventDoAction(typeof(Navigator.DrinkOrderConfirmedEvent), nameof(OnDrinkOrderConfirmed))] internal class Active : State { } private void OnInitActive() { if (!this.DrinkOrderPending) { this.SendEvent(this.NavigatorId, new Navigator.GetDrinkOrderEvent(this.GetPicture())); this.WriteLine(\"<Robot> Asked for a new Drink Order\"); } this.Monitor<LivenessMonitor>(new LivenessMonitor.BusyEvent()); } The Robot didn\u2019t send a request to the Navigator , because this.DrinkOrderPending was true (when in fact it should have been false ). The Robot just informed the LivenessMonitor that it is busy, and then waited (forever) to receive the Navigator \u2018s response to the pending order it believed was coming. But it was out of sync with the Navigator because there was no pending order in the Storage service. Thus, the reason for the bug is the incorrect value of this.DrinkOrderPending in state MovingOnRoute at the time of the registration event. Look at the code of Robot.cs where this.DrinkOrderPending is being modified. The only place where this is set to false is in the NextMove() method: private void NextMove() { this.DrinkOrderPending = false; ... } Unfortunately, this is too late\u2026 So when is the right moment to set this.DrinkOrderPending to false ? This is a classic timing bug then, and the coyote tester was able to uncover this bug because it takes control of all the timing and ordering of messages between the actors. The problem is the Navigator considers the drink request complete (and clears the Storage of that request) when it returns the DrivingInstructionsEvent. This event is handled by the robot in the method ReachClient. So this is where the Robot should be clearing its internal DrinkOrderPending state: private void ReachClient(Event e) { var route = (e as DrivingInstructionsEvent)?.Route; if (route != null) { this.Route = route; // this.DrinkOrderPending = false; // this is where it really belongs. this.Timers[\"MoveTimer\"] = this.StartTimer(TimeSpan.FromSeconds(MoveDuration), new MoveTimerElapsedEvent()); } this.RaiseGotoStateEvent<MovingOnRoute>(); } You can even see the fix for the bug in the code above. Although currently commented out, this is the exact place to set DrinkOrderPending to false . So, the fix is to remove from the NextMove() method this line: this.DrinkOrderPending = false; and to move it into the ReachClient() method (or just uncomment the fix that is hidden there). After you perform this fix and rebuild the sample, try running coyote test again with the same command line which previously reported the liveness bug: coyote test ./bin/net5.0/DrinksServingRobotActors.dll -i 1000 -ms 2000 --sch-pct 10 And now no bug will be found \u2013 you should get result similar to this: ..... Iteration #800 ..... Iteration #800 ..... Iteration #900 ..... Iteration #900 ..... Iteration #1000 ..... Iteration #1000 ... Testing statistics: ..... Found 0 bugs. ... Scheduling statistics: ..... Explored 2000 schedules: 0 fair and 2000 unfair. ..... Hit the max-steps bound of '2000' in 8.55% of the unfair schedules. ... Elapsed 25.7423125 sec. . Done If you want to have a high degree of certainty that no bug is found, run the coyote tester with a sufficiently big number of iterations, say 100,000 and --parallel N where N is a number that works well on your computer. If N is too high it will thrash your CPU and the test will run slowly. A good rule of thumb is to use ceiling(0.65 * NUMBER_OF_PROCESSORS) . NUMBER_OF_PROCESSORS is a system environment variable, typically equal to the number of cores in the computer. But sometimes this number is doubled if your computer supports hyper-threading.","title":"Explanation of the bug"},{"location":"samples/actors/failover-robot-navigator/#summary","text":"Failover testing is simple to achieve using Coyote and yields many interesting bugs in your code, including some thought-provoking design bugs. The technique of halting a \u201cproduction\u201d state-machine, and recreating it by reading from a \u201cpersistent\u201d MockStorage (which is not halted during testing) can be generalized to many other scenarios (such as actual cloud services) where someone needs to test failover logic of production actors using Coyote. In this tutorial you learned: How to do failover testing using a Coyote FailoverDriver state machine. How to use Coyote to test failover in a service. How to use --sch-pct testing on multiple processes to find tricky bugs more quickly. How to specify the --graph-bug argument so that the coyote test tool would produce a snapshot-DGML diagram of the final state of the system when the bug was found. How to use RaisePushStateEvent() and RaisePopStateEvent() to achieve additional simplicity in handling common events in one place. How Assert helps find violations of safety properties during testing. How to ensure graceful termination of one state machine (before creating a new one) via the TerminateEvent and HaltedEvent handshake between the FailoverDriver and the Navigator. How to write and use a LivenessMonitor in order to discover tricky liveness bugs.","title":"Summary"},{"location":"samples/actors/failure-detector/","text":"Bug in failure detector There is a particularly hard bug to find in the coyote-samples/Monitors sample application. If you run this application from your command prompt it will write output forever. It seems perfectly happy, right? But there is a bug that happens rarely, the kind of pesky bug that would keep you up late at night scratching your head. Read further to learn how to find this bug using Coyote! What you will need You will also need to: Install Visual Studio 2019 . Install the .NET 5.0 version of the coyote tool . Clone the Coyote Samples git repo . Be familiar with the coyote tool. See using Coyote . Build the samples Build the coyote-samples repo by running the following command: powershell -f build.ps1 Run the sample Let\u2019s see if Coyote can find the bug in this sample. Type coyote -? to see the help page to make sure you have installed it correctly. Now you are ready to run a coyote test as follows: cd coyote-samples coyote test ./bin/net5.0/Monitors.dll --iterations 1000 --max-steps 200 This also runs perfectly up to 1000 iterations. So this is indeed a hard bug to find. It can be found using the PCT exploration strategy with a given maximum number of priority switch points --sch-pct (or with the default Random exploration strategy, but with a much larger number of iterations, typically more than 100,000 of them). coyote test ./bin/net5.0/Monitors.dll --iterations 1000 --max-steps 200 --sch-pct 10 Even then you might need to run it a few times to catch the bug. Set --iterations to a bigger number if necessary. You can also let coyote decide which exploration strategy to use. Just use --sch-portfolio and size --parallel N and Coyote will run N different exploration strategies for you, in parallel. coyote manages the portfolio to give you the best chance of revealing bugs. These strategies were developed from real-world experience on large products in Microsoft Azure. When you use the right scheduling strategy, you will see a bug report: ... Task 0 found a bug. ... Emitting task 0 traces: ..... Writing .\\bin\\net48\\Output\\Monitors.exe\\CoyoteOutput\\Monitors_0_0.txt ..... Writing .\\bin\\net48\\Output\\Monitors.exe\\CoyoteOutput\\Monitors_0_0.schedule The *.txt file is the text log of the iteration that found the bug. The *.schedule contains the information needed to reproduce the bug. Finding a hard to find bug is one thing, but if you can\u2019t reproduce this bug while debugging there is no point. So the *.schedule can be used with the coyote replay command as follows: coyote replay ./bin/net5.0/Monitors.dll .\\bin\\net48\\Output\\Monitors.exe\\CoyoteOutput\\Monitors_0_0.schedule . Reproducing trace in coyote-samples\\./bin/net48/Monitors.exe ... Reproduced 1 bug. ... Elapsed 0.1724228 sec. Attach a debugger during replay and you can see what exactly is going wrong. You might be wondering what the Monitors sample app is really doing. The coyote command line tool can help you with that also. If you run the following command line it will produce a DGML diagram of the state machines that are being tested: coyote test ./bin/net5.0/Monitors.dll --iterations 10 --max-steps 20 --graph You will see the following output: ... Emitting graph: ..... Writing .\\bin\\net48\\Output\\Monitors.exe\\CoyoteOutput\\Monitors_0_1.dgml Open the DGML diagram using Visual Studio 2019 and you will see the following: Download the Monitors.dgml file to view it interactively using Visual Studio. Make sure the downloaded file keeps the file extension .dgml . Use CTRL+A to select everything and this will show you all the detailed links as well.","title":"Bug in failure detector"},{"location":"samples/actors/failure-detector/#bug-in-failure-detector","text":"There is a particularly hard bug to find in the coyote-samples/Monitors sample application. If you run this application from your command prompt it will write output forever. It seems perfectly happy, right? But there is a bug that happens rarely, the kind of pesky bug that would keep you up late at night scratching your head. Read further to learn how to find this bug using Coyote!","title":"Bug in failure detector"},{"location":"samples/actors/failure-detector/#what-you-will-need","text":"You will also need to: Install Visual Studio 2019 . Install the .NET 5.0 version of the coyote tool . Clone the Coyote Samples git repo . Be familiar with the coyote tool. See using Coyote .","title":"What you will need"},{"location":"samples/actors/failure-detector/#build-the-samples","text":"Build the coyote-samples repo by running the following command: powershell -f build.ps1","title":"Build the samples"},{"location":"samples/actors/failure-detector/#run-the-sample","text":"Let\u2019s see if Coyote can find the bug in this sample. Type coyote -? to see the help page to make sure you have installed it correctly. Now you are ready to run a coyote test as follows: cd coyote-samples coyote test ./bin/net5.0/Monitors.dll --iterations 1000 --max-steps 200 This also runs perfectly up to 1000 iterations. So this is indeed a hard bug to find. It can be found using the PCT exploration strategy with a given maximum number of priority switch points --sch-pct (or with the default Random exploration strategy, but with a much larger number of iterations, typically more than 100,000 of them). coyote test ./bin/net5.0/Monitors.dll --iterations 1000 --max-steps 200 --sch-pct 10 Even then you might need to run it a few times to catch the bug. Set --iterations to a bigger number if necessary. You can also let coyote decide which exploration strategy to use. Just use --sch-portfolio and size --parallel N and Coyote will run N different exploration strategies for you, in parallel. coyote manages the portfolio to give you the best chance of revealing bugs. These strategies were developed from real-world experience on large products in Microsoft Azure. When you use the right scheduling strategy, you will see a bug report: ... Task 0 found a bug. ... Emitting task 0 traces: ..... Writing .\\bin\\net48\\Output\\Monitors.exe\\CoyoteOutput\\Monitors_0_0.txt ..... Writing .\\bin\\net48\\Output\\Monitors.exe\\CoyoteOutput\\Monitors_0_0.schedule The *.txt file is the text log of the iteration that found the bug. The *.schedule contains the information needed to reproduce the bug. Finding a hard to find bug is one thing, but if you can\u2019t reproduce this bug while debugging there is no point. So the *.schedule can be used with the coyote replay command as follows: coyote replay ./bin/net5.0/Monitors.dll .\\bin\\net48\\Output\\Monitors.exe\\CoyoteOutput\\Monitors_0_0.schedule . Reproducing trace in coyote-samples\\./bin/net48/Monitors.exe ... Reproduced 1 bug. ... Elapsed 0.1724228 sec. Attach a debugger during replay and you can see what exactly is going wrong. You might be wondering what the Monitors sample app is really doing. The coyote command line tool can help you with that also. If you run the following command line it will produce a DGML diagram of the state machines that are being tested: coyote test ./bin/net5.0/Monitors.dll --iterations 10 --max-steps 20 --graph You will see the following output: ... Emitting graph: ..... Writing .\\bin\\net48\\Output\\Monitors.exe\\CoyoteOutput\\Monitors_0_1.dgml Open the DGML diagram using Visual Studio 2019 and you will see the following: Download the Monitors.dgml file to view it interactively using Visual Studio. Make sure the downloaded file keeps the file extension .dgml . Use CTRL+A to select everything and this will show you all the detailed links as well.","title":"Run the sample"},{"location":"samples/tasks/bounded-buffer/","text":"Deadlock in bounded-buffer Concurrent programming can be tricky. This tutorial shows a classic example of a deadlock and how Coyote can help you find and understand that deadlock. More details about this program and how Coyote can find this deadlock is found in this blog article . What you will need To run the BoundedBuffer example, you will need to: Install Visual Studio 2019 . Install the .NET 5.0 version of the coyote tool . Clone the Coyote Samples git repo . Be familiar with the coyote tool. See using Coyote . Build the samples Build the coyote-samples repo by running the following command: powershell -f build.ps1 Run the bounded-buffer application Now you can run the BoundedBuffer application in a mode that should trigger the deadlock most of the time: ./bin/net5.0/BoundedBuffer.exe -m And you can run it with a fix for the deadlock as follows: ./bin/net5.0/BoundedBuffer.exe -f Can you find the deadlock bug in BoundedBuffer class? The BoundedBuffer is a producer consumer queue where the Take method blocks if the buffer is empty and the Put method blocks if the buffer has reached it\u2019s maximum allowed capacity and while the code looks correct it contains a nasty deadlock bug. Writing concurrent code is tricky and with the popular async/await feature in the C# Programming Language it is now extremely easy to write concurrent code. But how do we test concurrency in our code? Testing tools and frameworks have not kept up with the pace of language innovation and so this is where Coyote comes to the rescue. When you use Coyote to test your programs you will find concurrency bugs that are very hard to find any other way. Coyote rewrites your async tasks in a way that allows the coyote tool to control all the concurrency and locking in your program and this allows it to find bugs using intelligent systematic testing . For example, if you take the BoundedBuffer.dll from the above sample you can do the following: coyote rewrite BoundedBuffer.dll coyote test BoundedBuffer.dll -m TestBoundedBufferMinimalDeadlock --iterations 100 This will report a deadlock error because Coyote has deadlock detection during testing. You will get a log file explaining all this, and more importantly you will also get a trace file that can be used to replay the bug in your debugger in a way that is 100% reproducible. Concurrency bugs tend to be the kind of bugs that keep people up late at night pulling their hair out because they are often not easily reproduced in any sort of predictable manner. Coyote solves this problem giving you an environment where concurrency bugs can be systematically found and reliably reproduced in a debugger \u2013 allowing developers to fully understand them and fix the core problem.","title":"Deadlock in bounded-buffer"},{"location":"samples/tasks/bounded-buffer/#deadlock-in-bounded-buffer","text":"Concurrent programming can be tricky. This tutorial shows a classic example of a deadlock and how Coyote can help you find and understand that deadlock. More details about this program and how Coyote can find this deadlock is found in this blog article .","title":"Deadlock in bounded-buffer"},{"location":"samples/tasks/bounded-buffer/#what-you-will-need","text":"To run the BoundedBuffer example, you will need to: Install Visual Studio 2019 . Install the .NET 5.0 version of the coyote tool . Clone the Coyote Samples git repo . Be familiar with the coyote tool. See using Coyote .","title":"What you will need"},{"location":"samples/tasks/bounded-buffer/#build-the-samples","text":"Build the coyote-samples repo by running the following command: powershell -f build.ps1","title":"Build the samples"},{"location":"samples/tasks/bounded-buffer/#run-the-bounded-buffer-application","text":"Now you can run the BoundedBuffer application in a mode that should trigger the deadlock most of the time: ./bin/net5.0/BoundedBuffer.exe -m And you can run it with a fix for the deadlock as follows: ./bin/net5.0/BoundedBuffer.exe -f","title":"Run the bounded-buffer application"},{"location":"samples/tasks/bounded-buffer/#can-you-find-the-deadlock-bug-in-boundedbuffer-class","text":"The BoundedBuffer is a producer consumer queue where the Take method blocks if the buffer is empty and the Put method blocks if the buffer has reached it\u2019s maximum allowed capacity and while the code looks correct it contains a nasty deadlock bug. Writing concurrent code is tricky and with the popular async/await feature in the C# Programming Language it is now extremely easy to write concurrent code. But how do we test concurrency in our code? Testing tools and frameworks have not kept up with the pace of language innovation and so this is where Coyote comes to the rescue. When you use Coyote to test your programs you will find concurrency bugs that are very hard to find any other way. Coyote rewrites your async tasks in a way that allows the coyote tool to control all the concurrency and locking in your program and this allows it to find bugs using intelligent systematic testing . For example, if you take the BoundedBuffer.dll from the above sample you can do the following: coyote rewrite BoundedBuffer.dll coyote test BoundedBuffer.dll -m TestBoundedBufferMinimalDeadlock --iterations 100 This will report a deadlock error because Coyote has deadlock detection during testing. You will get a log file explaining all this, and more importantly you will also get a trace file that can be used to replay the bug in your debugger in a way that is 100% reproducible. Concurrency bugs tend to be the kind of bugs that keep people up late at night pulling their hair out because they are often not easily reproduced in any sort of predictable manner. Coyote solves this problem giving you an environment where concurrency bugs can be systematically found and reliably reproduced in a debugger \u2013 allowing developers to fully understand them and fix the core problem.","title":"Can you find the deadlock bug in BoundedBuffer class?"},{"location":"tutorials/first-concurrency-unit-test/","text":"Write your first concurrency unit test with Coyote Modern software systems are inherently concurrent in nature as they perform many different activities at the same time, across different threads, processes and machines. Concurrency is notoriously hard to test, and concurrent bugs can be hard to reproduce and understand. Coyote is a very effective tool in taming this complexity. By giving you the ability to easily test for concurrency bugs, Coyote helps you build more reliable applications and services. In this tutorial, you will write a simple AccountManager class to create, get and delete account records in a backend NoSQL database. We\u2019ll design our class to be used in a concurrent setting, where methods in multiple instances of the class can be called concurrently, either within the same process or across processes and machines. This latter condition means that using locks will not help you in writing correct concurrent code. What you will need To run the code in this tutorial, you will need to: Install Visual Studio 2019 . Install the .NET 5.0 version of the coyote tool . Be familiar with the coyote tool. See using Coyote . Watch this tutorial Optionally, you can watch this tutorial on YouTube: Walkthrough Without further ado, let\u2019s look at the signature of the AccountManager class: public class AccountManager { private IDbCollection AccountCollection; // Returns true if the account is created, else false. public async Task<bool> CreateAccount(string accountName, string accountPayload) { ... } // Returns the accountPayload if the account is found, else null. public async Task<string> GetAccount(string accountName) { ... } // Returns true if the account is deleted, else false. public async Task<bool> DeleteAccount(string accountName) { ... } } Here are the methods available in the IDbCollection interface: public interface IDbCollection { Task<bool> CreateRow(string key, string value); Task<bool> DoesRowExist(string key); Task<string> GetRow(string key); Task<bool> DeleteRow(string key); } The CreateRow method creates the row with the given key, unless it already exists in which case it returns the RowAlreadyExistsException exception. The DoesRowExist method returns true if the row exists, otherwise it returns false . The GetRow method returns the content of the given key and throws RowNotFoundException exception if it doesn\u2019t exist. Finally, the DeleteRow method deletes the row if it exists and throws RowNotFoundException exception if it doesn\u2019t exist. Before reading on, please open your editor and attempt to write an implementation of the AccountManager class. You might write something like this: public class AccountManager { private readonly IDbCollection AccountCollection; public AccountManager(IDbCollection dbCollection) { this.AccountCollection = dbCollection; } // Returns true if the account is created, else false. public async Task<bool> CreateAccount(string accountName, string accountPayload) { if (await this.AccountCollection.DoesRowExist(accountName)) { return false; } return await this.AccountCollection.CreateRow(accountName, accountPayload); } // Returns the accountPayload if the account is found, else null. public async Task<string> GetAccount(string accountName) { if (!await this.AccountCollection.DoesRowExist(accountName)) { return null; } return await this.AccountCollection.GetRow(accountName); } // Returns true if the account is deleted, else false. public async Task<bool> DeleteAccount(string accountName) { if (!await this.AccountCollection.DoesRowExist(accountName)) { return false; } return await this.AccountCollection.DeleteRow(accountName); } } Does the above implementation look reasonable to you? Can you find any bugs? And how can you convince yourself of the absence of any bugs in the above program? Let\u2019s write a unit test to test the AccountManager code. In production, IDbCollection is implemented using a distributed NoSQL database. To keep things simple during testing, you can just replace it with a mock. The following code shows such a mock implementation: public class InMemoryDbCollection : IDbCollection { private readonly ConcurrentDictionary<string, string> Collection; public InMemoryDbCollection() { this.Collection = new ConcurrentDictionary<string, string>(); } public Task<bool> CreateRow(string key, string value) { return Task.Run(() => { bool success = this.Collection.TryAdd(key, value); if (!success) { throw new RowAlreadyExistsException(); } return true; }); } public Task<bool> DoesRowExist(string key) { return Task.Run(() => { return this.Collection.ContainsKey(key); }); } public Task<string> GetRow(string key) { return Task.Run(() => { bool success = this.Collection.TryGetValue(key, out string value); if (!success) { throw new RowNotFoundException(); } return value; }); } public Task<bool> DeleteRow(string key) { return Task.Run(() => { bool success = this.Collection.TryRemove(key, out string _); if (!success) { throw new RowNotFoundException(); } return true; }); } } The InMemoryDbCollection mock is very simple, it just maintains an in-memory ConcurrentDictionary to store the keys and values. Each method of the mock runs a new concurrent task (via Task.Run ) to make the call execute asynchronously, modeling async I/O in a real database call. You can read later this follow-up tutorial to delve into mock design for concurrency unit testing. Now that you have written this mock, you can write a simple test: [Test] public static async Task TestAccountCreation() { // Initialize the mock in-memory DB and account manager. var dbCollection = new InMemoryDbCollection(); var accountManager = new AccountManager(dbCollection); // Create some dummy data. string accountName = \"MyAccount\"; string accountPayload = \"...\"; // Create the account, it should complete successfully and return true. var result = await accountManager.CreateAccount(accountName, accountPayload); Assert.True(result); // Create the same account again. The method should return false this time. result = await accountManager.CreateAccount(accountName, accountPayload); Assert.False(result); } The above unit test clearly tests that the same account cannot be created twice. Try run it (check below for instructions on how to build and run this tutorial from our samples repository) and you will see that it always passes. But is the behavior still true if two requests happen concurrently ? How can you test this? What happens if you spawn two tasks that create the same account concurrently? What if you assert that only one creation succeeds, while the other always fails? That should work because the InMemoryDbCollection uses a ConcurrentDictionary right? [Test] public static async Task TestConcurrentAccountCreation() { // Initialize the mock in-memory DB and account manager. var dbCollection = new InMemoryDbCollection(); var accountManager = new AccountManager(dbCollection); // Create some dummy data. string accountName = \"MyAccount\"; string accountPayload = \"...\"; // Call CreateAccount twice without awaiting, which makes both methods run // asynchronously with each other. var task1 = accountManager.CreateAccount(accountName, accountPayload); var task2 = accountManager.CreateAccount(accountName, accountPayload); // Then wait both requests to complete. await Task.WhenAll(task1, task2); // Finally, assert that only one of the two requests succeeded and the other // failed. Note that we do not know which one of the two succeeded as the // requests ran concurrently (this is why we use an exclusive OR). Assert.True(task1.Result ^ task2.Result); } Try run this concurrent test. The assertion will most likely fail. The reason it is not a guaranteed failure is that there are some task interleavings where it passes, and others where it fails with the following exception: RowAlreadyExistsException: Exception of type 'RowAlreadyExistsException' was thrown. ... Let\u2019s dig into why the concurrent test failed. The test started two asynchronous CreateAccount calls, the first one checked whether the account existed through the DoesRowExist method which returned false . Due to the underlying concurrency, control passed to the second task which made a similar call to DoesRowExist which also returned false . Both tasks then resumed believing that the account does not exist and tried to add the account. One of them succeeded while the other threw an exception, indicating a bug in your AccountManager implementation. So writing out this test was useful and easily exposed this race condition. But why don\u2019t we write such tests a lot more often? The reason is they are often flaky and find bugs through sheer luck instead of a systematic exploration of the possible interleavings. The above test hits the bug fairly frequently due to the way .NET task scheduling works (on a reasonably fast machine with light CPU load). Let\u2019s tweak the test very slightly by adding a delay of a millisecond between the two CreateAccount calls: var task1 = accountManager.CreateAccount(accountName, accountPayload); await Task.Delay(1); // Artificial delay. var task2 = accountManager.CreateAccount(accountName, accountPayload); If you run this test, chances are it will fail very rarely. If you run this test in a loop invoking it a hundred times it probably won\u2019t fail once. The race condition is still there but our concurrency unit test suddenly became ineffective at catching it. This explains why developers don\u2019t write such tests as they are very sensitive to timing issues. Instead, developers often write stress tests, where the system is bombarded with thousands of concurrent requests in the hopes that some rare interleaving would expose these kind of nondeterministic bugs (known as Heizenbugs ) before the code is deployed in production. But stress testing can be complex to setup and it doesn\u2019t always find the most tricky bugs. Even if it does find a bug, it usually produces such long traces (or logs) that understanding the bug and fixing it becomes a very time consuming and frustrating task. Flakey tests is clearly not a satisfactory situation. What we need is a tool which can systematically explore the various task interleavings in test mode as opposed to leaving that to luck (i.e. the operating system scheduler). Coyote gives you exactly this. To use Coyote on your task-based program is very easy in most cases. All you need to do is to invoke the coyote tool to rewrite your assembly (for testing only) so that Coyote can inject logic that allows it to take control of the schedule of C# tasks. Then, you can invoke the coyote test tool which systematically explores task interleavings to uncover bug. What is even better is that if a bug is uncovered, Coyote allows you to deterministically reproduce it every single time. Now run your test under the control of Coyote. First use Coyote to rewrite the assembly: coyote rewrite .\\AccountManager.dll . Rewriting AccountManager.dll ... Rewriting the 'AccountManager.dll' assembly ... Writing the modified 'AccountManager.dll' assembly to AccountManager.dll . Done rewriting in 0.6425808 sec Note : if your project contains multiple assemblies (which is usually the normal), then you need to rewrite all of them. This can be easily done by passing a JSON configuration file to coyote rewrite as discussed here . Awesome, now lets try use Coyote on the above concurrent test: coyote test .\\AccountManager.dll -m TestConcurrentAccountCreation -i 100 Note : for this to work the unit test method needs to use the [Microsoft.Coyote.SystematicTesting.Test] custom attribute to declare the test method which is what you will see if you have already downloaded the Coyote Samples git repo . The above command tells Coyote to execute the test method TestConcurrentAccountCreation for 100 iterations. Each iteration will try explore different interleavings to try unearth the bug. You can read more about other Coyote tool options here . Indeed after 20 iterations and 0.15 seconds Coyote finds a bug: . Testing .\\AccountManager.dll ... Method TestConcurrentAccountCreation ... Started the testing task scheduler (process:17368). ... Created '1' testing task (process:17368). ... Task 0 is using 'random' strategy (seed:1046544966). ..... Iteration #1 ..... Iteration #2 ..... Iteration #3 ..... Iteration #4 ..... Iteration #5 ..... Iteration #6 ..... Iteration #7 ..... Iteration #8 ..... Iteration #9 ..... Iteration #10 ..... Iteration #20 ... Task 0 found a bug. ... Emitting task 0 traces: ..... Writing AccountManager.dll\\CoyoteOutput\\AccountManager_0_0.txt ..... Writing AccountManager.dll\\CoyoteOutput\\AccountManager_0_0.schedule ... Elapsed 0.0743756 sec. ... Testing statistics: ..... Found 1 bug. ... Scheduling statistics: ..... Explored 26 schedules: 26 fair and 0 unfair. ..... Found 3.85% buggy schedules. ..... Number of scheduling points in fair terminating schedules: 17 (min), 23 (avg), 31 (max). ... Elapsed 0.1574494 sec. Cool, the flakey test is no longer flakey! Coyote can also help you reproduce and debug it. You can simply run coyote replay giving the .schedule file that Coyote outputs upon finding a bug: coyote replay .\\AccountManager.dll -schedule AccountManager_0_0.schedule -m TestConcurrentAccountCreation . Replaying .\\Output\\AccountManager.dll\\CoyoteOutput\\AccountManager_0_1.schedule ... Task 0 is using 'replay' strategy. ... Reproduced 1 bug (use --break to attach the debugger). ... Elapsed 0.0671654 sec. Nice, the bug was reproduced. You can use the --break option to attach the VS debugger and happily debug the deterministic trace to figure out what is causing the bug and take as long as you want, stepping through the code in the debug, and that will not change any timing conditions, the same bug will still happen. You can repeat this as many times as you want! In this tutorial, you saw that you were able to use Coyote to reliably reproduce the race condition in AccountManager . You did this with a tiny test (just two CreateAccount calls racing with each other), as opposed to overloading the system with thousands of concurrent tasks through stress testing. This of course was a simple example, but it\u2019s easy to imagine how Coyote can find many non-trivial concurrency bugs in a much more complex codebase. Such bugs have very low probability of being caught during test time if you don\u2019t use a tool like Coyote. In the absence of such tools, these bugs can go undetected and occur sporadically in production, making them difficult to diagnose and debug. No more late nights debugging a live site! In the next tutorial , you will write a few more concurrency unit tests for the AccountManager to increase our familiarity with Coyote. Get the sample source code To get the complete source code for the AccountManager tutorial, clone the Coyote Samples git repo . Note that the repo also contains the code from the next tutorial which builds upon this AccountManager sample. You can build the samples by running the following command: powershell -f build.ps1 You can now run the tests (without Coyote) like this: cd .\\bin\\net5.0 .\\AccountManager.exe This version has some command line arguments to make it easy select which test to run: Usage: AccountManager [option] Options: -s Run sequential test without Coyote -c Run concurrent test without Coyote To rewrite and test the sample with Coyote you can use the following commands (as discussed above): coyote rewrite .\\AccountManager.dll coyote test .\\AccountManager.dll -m TestConcurrentAccountCreation -i 100 If you find a bug you can replay with the following command: coyote replay .\\AccountManager.dll -schedule AccountManager_0_0.schedule -m TestConcurrentAccountCreation Enjoy!","title":"Write your first concurrency unit test"},{"location":"tutorials/first-concurrency-unit-test/#write-your-first-concurrency-unit-test-with-coyote","text":"Modern software systems are inherently concurrent in nature as they perform many different activities at the same time, across different threads, processes and machines. Concurrency is notoriously hard to test, and concurrent bugs can be hard to reproduce and understand. Coyote is a very effective tool in taming this complexity. By giving you the ability to easily test for concurrency bugs, Coyote helps you build more reliable applications and services. In this tutorial, you will write a simple AccountManager class to create, get and delete account records in a backend NoSQL database. We\u2019ll design our class to be used in a concurrent setting, where methods in multiple instances of the class can be called concurrently, either within the same process or across processes and machines. This latter condition means that using locks will not help you in writing correct concurrent code.","title":"Write your first concurrency unit test with Coyote"},{"location":"tutorials/first-concurrency-unit-test/#what-you-will-need","text":"To run the code in this tutorial, you will need to: Install Visual Studio 2019 . Install the .NET 5.0 version of the coyote tool . Be familiar with the coyote tool. See using Coyote .","title":"What you will need"},{"location":"tutorials/first-concurrency-unit-test/#watch-this-tutorial","text":"Optionally, you can watch this tutorial on YouTube:","title":"Watch this tutorial"},{"location":"tutorials/first-concurrency-unit-test/#walkthrough","text":"Without further ado, let\u2019s look at the signature of the AccountManager class: public class AccountManager { private IDbCollection AccountCollection; // Returns true if the account is created, else false. public async Task<bool> CreateAccount(string accountName, string accountPayload) { ... } // Returns the accountPayload if the account is found, else null. public async Task<string> GetAccount(string accountName) { ... } // Returns true if the account is deleted, else false. public async Task<bool> DeleteAccount(string accountName) { ... } } Here are the methods available in the IDbCollection interface: public interface IDbCollection { Task<bool> CreateRow(string key, string value); Task<bool> DoesRowExist(string key); Task<string> GetRow(string key); Task<bool> DeleteRow(string key); } The CreateRow method creates the row with the given key, unless it already exists in which case it returns the RowAlreadyExistsException exception. The DoesRowExist method returns true if the row exists, otherwise it returns false . The GetRow method returns the content of the given key and throws RowNotFoundException exception if it doesn\u2019t exist. Finally, the DeleteRow method deletes the row if it exists and throws RowNotFoundException exception if it doesn\u2019t exist. Before reading on, please open your editor and attempt to write an implementation of the AccountManager class. You might write something like this: public class AccountManager { private readonly IDbCollection AccountCollection; public AccountManager(IDbCollection dbCollection) { this.AccountCollection = dbCollection; } // Returns true if the account is created, else false. public async Task<bool> CreateAccount(string accountName, string accountPayload) { if (await this.AccountCollection.DoesRowExist(accountName)) { return false; } return await this.AccountCollection.CreateRow(accountName, accountPayload); } // Returns the accountPayload if the account is found, else null. public async Task<string> GetAccount(string accountName) { if (!await this.AccountCollection.DoesRowExist(accountName)) { return null; } return await this.AccountCollection.GetRow(accountName); } // Returns true if the account is deleted, else false. public async Task<bool> DeleteAccount(string accountName) { if (!await this.AccountCollection.DoesRowExist(accountName)) { return false; } return await this.AccountCollection.DeleteRow(accountName); } } Does the above implementation look reasonable to you? Can you find any bugs? And how can you convince yourself of the absence of any bugs in the above program? Let\u2019s write a unit test to test the AccountManager code. In production, IDbCollection is implemented using a distributed NoSQL database. To keep things simple during testing, you can just replace it with a mock. The following code shows such a mock implementation: public class InMemoryDbCollection : IDbCollection { private readonly ConcurrentDictionary<string, string> Collection; public InMemoryDbCollection() { this.Collection = new ConcurrentDictionary<string, string>(); } public Task<bool> CreateRow(string key, string value) { return Task.Run(() => { bool success = this.Collection.TryAdd(key, value); if (!success) { throw new RowAlreadyExistsException(); } return true; }); } public Task<bool> DoesRowExist(string key) { return Task.Run(() => { return this.Collection.ContainsKey(key); }); } public Task<string> GetRow(string key) { return Task.Run(() => { bool success = this.Collection.TryGetValue(key, out string value); if (!success) { throw new RowNotFoundException(); } return value; }); } public Task<bool> DeleteRow(string key) { return Task.Run(() => { bool success = this.Collection.TryRemove(key, out string _); if (!success) { throw new RowNotFoundException(); } return true; }); } } The InMemoryDbCollection mock is very simple, it just maintains an in-memory ConcurrentDictionary to store the keys and values. Each method of the mock runs a new concurrent task (via Task.Run ) to make the call execute asynchronously, modeling async I/O in a real database call. You can read later this follow-up tutorial to delve into mock design for concurrency unit testing. Now that you have written this mock, you can write a simple test: [Test] public static async Task TestAccountCreation() { // Initialize the mock in-memory DB and account manager. var dbCollection = new InMemoryDbCollection(); var accountManager = new AccountManager(dbCollection); // Create some dummy data. string accountName = \"MyAccount\"; string accountPayload = \"...\"; // Create the account, it should complete successfully and return true. var result = await accountManager.CreateAccount(accountName, accountPayload); Assert.True(result); // Create the same account again. The method should return false this time. result = await accountManager.CreateAccount(accountName, accountPayload); Assert.False(result); } The above unit test clearly tests that the same account cannot be created twice. Try run it (check below for instructions on how to build and run this tutorial from our samples repository) and you will see that it always passes. But is the behavior still true if two requests happen concurrently ? How can you test this? What happens if you spawn two tasks that create the same account concurrently? What if you assert that only one creation succeeds, while the other always fails? That should work because the InMemoryDbCollection uses a ConcurrentDictionary right? [Test] public static async Task TestConcurrentAccountCreation() { // Initialize the mock in-memory DB and account manager. var dbCollection = new InMemoryDbCollection(); var accountManager = new AccountManager(dbCollection); // Create some dummy data. string accountName = \"MyAccount\"; string accountPayload = \"...\"; // Call CreateAccount twice without awaiting, which makes both methods run // asynchronously with each other. var task1 = accountManager.CreateAccount(accountName, accountPayload); var task2 = accountManager.CreateAccount(accountName, accountPayload); // Then wait both requests to complete. await Task.WhenAll(task1, task2); // Finally, assert that only one of the two requests succeeded and the other // failed. Note that we do not know which one of the two succeeded as the // requests ran concurrently (this is why we use an exclusive OR). Assert.True(task1.Result ^ task2.Result); } Try run this concurrent test. The assertion will most likely fail. The reason it is not a guaranteed failure is that there are some task interleavings where it passes, and others where it fails with the following exception: RowAlreadyExistsException: Exception of type 'RowAlreadyExistsException' was thrown. ... Let\u2019s dig into why the concurrent test failed. The test started two asynchronous CreateAccount calls, the first one checked whether the account existed through the DoesRowExist method which returned false . Due to the underlying concurrency, control passed to the second task which made a similar call to DoesRowExist which also returned false . Both tasks then resumed believing that the account does not exist and tried to add the account. One of them succeeded while the other threw an exception, indicating a bug in your AccountManager implementation. So writing out this test was useful and easily exposed this race condition. But why don\u2019t we write such tests a lot more often? The reason is they are often flaky and find bugs through sheer luck instead of a systematic exploration of the possible interleavings. The above test hits the bug fairly frequently due to the way .NET task scheduling works (on a reasonably fast machine with light CPU load). Let\u2019s tweak the test very slightly by adding a delay of a millisecond between the two CreateAccount calls: var task1 = accountManager.CreateAccount(accountName, accountPayload); await Task.Delay(1); // Artificial delay. var task2 = accountManager.CreateAccount(accountName, accountPayload); If you run this test, chances are it will fail very rarely. If you run this test in a loop invoking it a hundred times it probably won\u2019t fail once. The race condition is still there but our concurrency unit test suddenly became ineffective at catching it. This explains why developers don\u2019t write such tests as they are very sensitive to timing issues. Instead, developers often write stress tests, where the system is bombarded with thousands of concurrent requests in the hopes that some rare interleaving would expose these kind of nondeterministic bugs (known as Heizenbugs ) before the code is deployed in production. But stress testing can be complex to setup and it doesn\u2019t always find the most tricky bugs. Even if it does find a bug, it usually produces such long traces (or logs) that understanding the bug and fixing it becomes a very time consuming and frustrating task. Flakey tests is clearly not a satisfactory situation. What we need is a tool which can systematically explore the various task interleavings in test mode as opposed to leaving that to luck (i.e. the operating system scheduler). Coyote gives you exactly this. To use Coyote on your task-based program is very easy in most cases. All you need to do is to invoke the coyote tool to rewrite your assembly (for testing only) so that Coyote can inject logic that allows it to take control of the schedule of C# tasks. Then, you can invoke the coyote test tool which systematically explores task interleavings to uncover bug. What is even better is that if a bug is uncovered, Coyote allows you to deterministically reproduce it every single time. Now run your test under the control of Coyote. First use Coyote to rewrite the assembly: coyote rewrite .\\AccountManager.dll . Rewriting AccountManager.dll ... Rewriting the 'AccountManager.dll' assembly ... Writing the modified 'AccountManager.dll' assembly to AccountManager.dll . Done rewriting in 0.6425808 sec Note : if your project contains multiple assemblies (which is usually the normal), then you need to rewrite all of them. This can be easily done by passing a JSON configuration file to coyote rewrite as discussed here . Awesome, now lets try use Coyote on the above concurrent test: coyote test .\\AccountManager.dll -m TestConcurrentAccountCreation -i 100 Note : for this to work the unit test method needs to use the [Microsoft.Coyote.SystematicTesting.Test] custom attribute to declare the test method which is what you will see if you have already downloaded the Coyote Samples git repo . The above command tells Coyote to execute the test method TestConcurrentAccountCreation for 100 iterations. Each iteration will try explore different interleavings to try unearth the bug. You can read more about other Coyote tool options here . Indeed after 20 iterations and 0.15 seconds Coyote finds a bug: . Testing .\\AccountManager.dll ... Method TestConcurrentAccountCreation ... Started the testing task scheduler (process:17368). ... Created '1' testing task (process:17368). ... Task 0 is using 'random' strategy (seed:1046544966). ..... Iteration #1 ..... Iteration #2 ..... Iteration #3 ..... Iteration #4 ..... Iteration #5 ..... Iteration #6 ..... Iteration #7 ..... Iteration #8 ..... Iteration #9 ..... Iteration #10 ..... Iteration #20 ... Task 0 found a bug. ... Emitting task 0 traces: ..... Writing AccountManager.dll\\CoyoteOutput\\AccountManager_0_0.txt ..... Writing AccountManager.dll\\CoyoteOutput\\AccountManager_0_0.schedule ... Elapsed 0.0743756 sec. ... Testing statistics: ..... Found 1 bug. ... Scheduling statistics: ..... Explored 26 schedules: 26 fair and 0 unfair. ..... Found 3.85% buggy schedules. ..... Number of scheduling points in fair terminating schedules: 17 (min), 23 (avg), 31 (max). ... Elapsed 0.1574494 sec. Cool, the flakey test is no longer flakey! Coyote can also help you reproduce and debug it. You can simply run coyote replay giving the .schedule file that Coyote outputs upon finding a bug: coyote replay .\\AccountManager.dll -schedule AccountManager_0_0.schedule -m TestConcurrentAccountCreation . Replaying .\\Output\\AccountManager.dll\\CoyoteOutput\\AccountManager_0_1.schedule ... Task 0 is using 'replay' strategy. ... Reproduced 1 bug (use --break to attach the debugger). ... Elapsed 0.0671654 sec. Nice, the bug was reproduced. You can use the --break option to attach the VS debugger and happily debug the deterministic trace to figure out what is causing the bug and take as long as you want, stepping through the code in the debug, and that will not change any timing conditions, the same bug will still happen. You can repeat this as many times as you want! In this tutorial, you saw that you were able to use Coyote to reliably reproduce the race condition in AccountManager . You did this with a tiny test (just two CreateAccount calls racing with each other), as opposed to overloading the system with thousands of concurrent tasks through stress testing. This of course was a simple example, but it\u2019s easy to imagine how Coyote can find many non-trivial concurrency bugs in a much more complex codebase. Such bugs have very low probability of being caught during test time if you don\u2019t use a tool like Coyote. In the absence of such tools, these bugs can go undetected and occur sporadically in production, making them difficult to diagnose and debug. No more late nights debugging a live site! In the next tutorial , you will write a few more concurrency unit tests for the AccountManager to increase our familiarity with Coyote.","title":"Walkthrough"},{"location":"tutorials/first-concurrency-unit-test/#get-the-sample-source-code","text":"To get the complete source code for the AccountManager tutorial, clone the Coyote Samples git repo . Note that the repo also contains the code from the next tutorial which builds upon this AccountManager sample. You can build the samples by running the following command: powershell -f build.ps1 You can now run the tests (without Coyote) like this: cd .\\bin\\net5.0 .\\AccountManager.exe This version has some command line arguments to make it easy select which test to run: Usage: AccountManager [option] Options: -s Run sequential test without Coyote -c Run concurrent test without Coyote To rewrite and test the sample with Coyote you can use the following commands (as discussed above): coyote rewrite .\\AccountManager.dll coyote test .\\AccountManager.dll -m TestConcurrentAccountCreation -i 100 If you find a bug you can replay with the following command: coyote replay .\\AccountManager.dll -schedule AccountManager_0_0.schedule -m TestConcurrentAccountCreation Enjoy!","title":"Get the sample source code"},{"location":"tutorials/overview/","text":"Learn how to use Coyote in practice Now that you have learned how to install and use the Coyote tool, you are ready to write your first concurrency unit test . This introductory tutorial is also available as a video on YouTube . Next, we recommend you to read the following tutorials: Test concurrent CRUD operations Mocking dependencies for testing Test failover and liveness More on the way! If you are looking to hone your mock crafting skills, go through the following tutorials: Simulating optimistic concurrency control using ETags More on the way! If you are interested in the more advanced actor programming model of Coyote, check out these tutorials: Hello world in Coyote actors Raft consensus protocol on Azure Raft consensus protocol with mocks for testing Test failover and liveness in actors More on the way! You can learn the core concepts behind Coyote by reading here .","title":"Overview"},{"location":"tutorials/overview/#learn-how-to-use-coyote-in-practice","text":"Now that you have learned how to install and use the Coyote tool, you are ready to write your first concurrency unit test . This introductory tutorial is also available as a video on YouTube . Next, we recommend you to read the following tutorials: Test concurrent CRUD operations Mocking dependencies for testing Test failover and liveness More on the way! If you are looking to hone your mock crafting skills, go through the following tutorials: Simulating optimistic concurrency control using ETags More on the way! If you are interested in the more advanced actor programming model of Coyote, check out these tutorials: Hello world in Coyote actors Raft consensus protocol on Azure Raft consensus protocol with mocks for testing Test failover and liveness in actors More on the way! You can learn the core concepts behind Coyote by reading here .","title":"Learn how to use Coyote in practice"},{"location":"tutorials/test-concurrent-operations/","text":"Test concurrent CRUD operations with Coyote In the previous tutorial , we explored how to write our first concurrency unit test for AccountManager , and reliably reproduce a race condition in the CreateAccount logic using Coyote. As a typical resource controller, AccountManager exposes an API for creating, reading and deleting accounts. Such operations (including updating, which is skipped here for simplicity) are commonly known as CRUD . In this follow-up tutorial, you will write a few more tests that exercise the concurrency in the AccountManager CRUD operations. What you will need To run the code in this tutorial, you will need to: Install Visual Studio 2019 . Install the .NET 5.0 version of the coyote tool . Be familiar with the coyote tool. See using Coyote . Go through the write your first concurrency unit test tutorial. Walkthrough Our first concurrency unit test , TestConcurrentAccountCreation , exercised a race between two concurrent CreateAccount requests. A logical next test would be to create two DeleteAccount requests and see what happens when they execute concurrently (as if the system was running in production). Here is one such test: [Microsoft.Coyote.SystematicTesting.Test] public static async Task TestConcurrentAccountDeletion() { // Initialize the mock in-memory DB and account manager. var dbCollection = new InMemoryDbCollection(); var accountManager = new AccountManager(dbCollection); // Create some dummy data. string accountName = \"MyAccount\"; string accountPayload = \"...\"; // Create the account and wait for it to complete. await accountManager.CreateAccount(accountName, accountPayload); // Call DeleteAccount twice without awaiting, which makes both methods run // asynchronously with each other. var task1 = accountManager.DeleteAccount(accountName); var task2 = accountManager.DeleteAccount(accountName); // Then wait both requests to complete. await Task.WhenAll(task1, task2); // Finally, assert that only one of the two requests succeeded and the other // failed. Note that we do not know which one of the two succeeded as the // requests ran concurrently (this is why we use an exclusive OR). Assert.True(task1.Result ^ task2.Result); } The test looks pretty similar to the TestConcurrentAccountCreation from the previous tutorial. The main difference is that it first runs a CreateAccount request and waits it to complete, because without first creating an account you cannot test its deletion! The test then invokes two DeleteAccount requests, without waiting so that they can run at the same time, then waits for both to complete before finally asserting that only one deletion happened (and the other was ignored). Run this TestConcurrentAccountDeletion test using Coyote (remember to use coyote rewrite first!): coyote rewrite .\\AccountManager.dll coyote test .\\AccountManager.dll -m TestConcurrentAccountDeletion -i 100 When you run this TestConcurrentAccountDeletion test using Coyote, you\u2019ll find that Coyote finds a bug very fast. This bug is caused due to a very similar race condition that made the TestConcurrentAccountCreation test fail. . Testing .\\AccountManager.dll ... Method TestConcurrentAccountDeletion ... Started the testing task scheduler (process:15672). ... Created '1' testing task (process:15672). ... Task 0 is using 'random' strategy (seed:3336165456). ..... Iteration #1 ..... Iteration #2 ..... Iteration #3 ... Task 0 found a bug. ... Emitting task 0 traces: ..... Writing AccountManager.dll\\CoyoteOutput\\AccountManager_0_0.txt ..... Writing AccountManager.dll\\CoyoteOutput\\AccountManager_0_0.schedule ... Elapsed 0.1939681 sec. ... Testing statistics: ..... Found 1 bug. ... Scheduling statistics: ..... Explored 3 schedules: 3 fair and 0 unfair. ..... Found 33.33% buggy schedules. ..... Number of scheduling points in fair terminating schedules: 24 (min), 27 (avg), 31 (max). ... Elapsed 0.444569 sec. Both concurrent DeleteAccount requests conclude that the account exists, before either of them gets a chance to delete the row. Then due to the race condition, both requests proceed to delete the row with one succeeding and the other failing with a RowNotFoundException exception. // Returns true if the account is deleted, else false. public async Task<bool> DeleteAccount(string accountName) { if (!await this.AccountCollection.DoesRowExist(accountName)) { return false; } return await this.AccountCollection.DeleteRow(accountName); } This exception is a bug that could possibly lead to unintended consequences in your logic (e.g. data corruption or loss). It could also trigger a 500 internal server error , if AccountManager was a deployed service, which is not a nice HTTP status code to return to the client of the request! Here\u2019s one way to fix the DeleteAccount method: // Returns true if the account is deleted, else false. public async Task<bool> DeleteAccount(string userName) { try { return await this.AccountCollection.DeleteRow(userName); } catch (RowNotFoundException) { return false; } } The above implementation avoids using the DoesRowExist method, because you can never be sure that some other concurrent request did not already delete the same row while this method is executing between the DoesRowExist and DeleteRow calls. Such race conditions might not happen most of the times, but clearly some times they can happen. In production, with thousands of requests happening at the same time, such race conditions might manifest more often and are notoriously hard to reproduce and debug. This is why using Coyote can really help. Going back to the fixed method above, it directly calls DeleteRow on IDbCollection and relies on the database returning an error response (through the RowNotFound exception) to deal with such race conditions. It effectively offloads the problem of preventing such races to the database itself. Trying to do this in the application logic would be really hard. So far you wrote two concurrency unit tests, one exercising two concurrent CreateAccount requests and the other one exercising two concurrent DeleteAccount requests. Can you think of other interesting test cases that would allow us to test the CRUD operations of AccountManager more thoroughly? Any set of methods that may read or write shared state (and thus potentially create interference) are a great candidate for writing concurrency unit tests. What about a race between a CreateAccount and DeleteAccount call? At first glance, this may seem like a weird test to write as you can\u2019t control the order in which the two methods will concurrently execute in respect with each other. This makes it difficult to write meaningful assertions at the end of the test. But if you think about this more deeply, you will realize that there are only a few distinct outcomes of these races and you can assert for each of these outcomes. Tests like these are very useful for ensuring that when CRUD operations execute concurrently (which is the norm in production!), a resource (an account in this case) is either fully created or fully deleted, and is not left in a half-broken state. This particular example is simple but you can easily imagine more complex examples where such race conditions can in fact lead to your state being corrupted (e.g. partially created and partially deleted) in the presence of concurrency bugs. Coyote allows you to easily test exactly these kinds of scenarios, making sure that your customer data will not get corrupted. The awesome part is that Coyote will find and help you debug these bugs on your local machine before you deploy your service, saving you ton of headache! Of course this does not only apply to CRUD operations and resource providers, you can imagine many other systems can benefit of this kind of testing! Going back to our AccountManager example, let\u2019s write the test that exercises CreateAccount and DeleteAccount requests happening at the same time. The test is a bit more involved this time. [Microsoft.Coyote.SystematicTesting.Test] public static async Task TestConcurrentAccountCreationAndDeletion() { // Initialize the mock in-memory DB and account manager. var dbCollection = new InMemoryDbCollection(); var accountManager = new AccountManager(dbCollection); // Create some dummy data. string accountName = \"MyAccount\"; string accountPayload = \"...\"; // Call CreateAccount and DeleteAccount without awaiting, which makes both // methods run asynchronously with each other. var createTask = accountManager.CreateAccount(accountName, accountPayload); var deleteTask = accountManager.DeleteAccount(accountName); // Then wait both requests to complete. await Task.WhenAll(createTask, deleteTask); // The CreateAccount request will always succeed, no matter what. The DeleteAccount // may or may not succeed depending on if it finds the account already created or // not created while executing concurrently with the CreateAccount request. Assert.True(createTask.Result); if (!deleteTask.Result) { // The DeleteAccount request didn't find the account and failed as expected. // We assert that the account payload is still available. string fetchedAccountPayload = await accountManager.GetAccount(accountName); Assert.Equal(accountPayload, fetchedAccountPayload); } else { // If CreateAccount and DeleteAccount both returned true, then the account // must have been created before the deletion happened. // We assert that the payload is not available, as the account was deleted. string fetchedAccountPayload = await accountManager.GetAccount(accountName); Assert.Null(fetchedAccountPayload); } } Now run your TestConcurrentAccountCreationAndDeletion test with Coyote (remember to rewrite the assembly first!) and see if it passes. coyote rewrite .\\AccountManager.dll coyote test .\\AccountManager.dll -m TestConcurrentAccountCreationAndDeletion -i 100 The test passed without reporting any bugs which gives you confidence in the correctness of your code. . Testing .\\AccountManager.dll ... Method TestConcurrentAccountCreationAndDeletion ... Started the testing task scheduler (process:25840). ... Created '1' testing task (process:25840). ... Task 0 is using 'random' strategy (seed:2968084874). ..... Iteration #1 ..... Iteration #2 ..... Iteration #3 ..... Iteration #4 ..... Iteration #5 ..... Iteration #6 ..... Iteration #7 ..... Iteration #8 ..... Iteration #9 ..... Iteration #10 ..... Iteration #20 ..... Iteration #30 ..... Iteration #40 ..... Iteration #50 ..... Iteration #60 ..... Iteration #70 ..... Iteration #80 ..... Iteration #90 ..... Iteration #100 ... Testing statistics: ..... Found 0 bugs. ... Scheduling statistics: ..... Explored 100 schedules: 100 fair and 0 unfair. ..... Number of scheduling points in fair terminating schedules: 12 (min), 23 (avg), 35 (max). ... Elapsed 0.2443369 sec. Often times, even if your code is correct and Coyote doesn\u2019t find any bugs, it makes you deeply think about possible scenarios and outcomes in the presence of race conditions in your logic, and helps you reason about the correct behavior. This clarity in thinking alone is extremely valuable. Developers often reason about edge cases when writing sequential tests, but sometimes miss bugs in the presence of concurrency as they don\u2019t write focused concurrency unit tests, because they are impractical to write without a tool like Coyote. Now this was a simple example but you can imagine how it would be possible for the AccountManager to get into an inconsistent state if the CreateAccount and DeleteAccount methods involved multiple steps, such as modifying a couple of collections instead of just one, emitting events and create entries in other non-database systems (e.g. provisioning a dedicated Azure Storage container for the account). Get the sample source code To get the complete source code for the AccountManager tutorial, clone the Coyote Samples git repo . You can build the sample by running the following command: powershell -f build.ps1 To rewrite and test the sample with Coyote you can use the following commands (as discussed above): coyote rewrite .\\AccountManager.dll coyote test .\\AccountManager.dll -m TestConcurrentAccountDeletion -i 100 If you find a bug you can replay with the following command (providing the correct .schedule file reported from the previous coyote test that failed): coyote replay .\\AccountManager.dll -schedule AccountManager_0_0.schedule -m TestConcurrentAccountDeletion Feel free to play around with the code and write more concurrency unit tests with Coyote!","title":"Test concurrent CRUD operations"},{"location":"tutorials/test-concurrent-operations/#test-concurrent-crud-operations-with-coyote","text":"In the previous tutorial , we explored how to write our first concurrency unit test for AccountManager , and reliably reproduce a race condition in the CreateAccount logic using Coyote. As a typical resource controller, AccountManager exposes an API for creating, reading and deleting accounts. Such operations (including updating, which is skipped here for simplicity) are commonly known as CRUD . In this follow-up tutorial, you will write a few more tests that exercise the concurrency in the AccountManager CRUD operations.","title":"Test concurrent CRUD operations with Coyote"},{"location":"tutorials/test-concurrent-operations/#what-you-will-need","text":"To run the code in this tutorial, you will need to: Install Visual Studio 2019 . Install the .NET 5.0 version of the coyote tool . Be familiar with the coyote tool. See using Coyote . Go through the write your first concurrency unit test tutorial.","title":"What you will need"},{"location":"tutorials/test-concurrent-operations/#walkthrough","text":"Our first concurrency unit test , TestConcurrentAccountCreation , exercised a race between two concurrent CreateAccount requests. A logical next test would be to create two DeleteAccount requests and see what happens when they execute concurrently (as if the system was running in production). Here is one such test: [Microsoft.Coyote.SystematicTesting.Test] public static async Task TestConcurrentAccountDeletion() { // Initialize the mock in-memory DB and account manager. var dbCollection = new InMemoryDbCollection(); var accountManager = new AccountManager(dbCollection); // Create some dummy data. string accountName = \"MyAccount\"; string accountPayload = \"...\"; // Create the account and wait for it to complete. await accountManager.CreateAccount(accountName, accountPayload); // Call DeleteAccount twice without awaiting, which makes both methods run // asynchronously with each other. var task1 = accountManager.DeleteAccount(accountName); var task2 = accountManager.DeleteAccount(accountName); // Then wait both requests to complete. await Task.WhenAll(task1, task2); // Finally, assert that only one of the two requests succeeded and the other // failed. Note that we do not know which one of the two succeeded as the // requests ran concurrently (this is why we use an exclusive OR). Assert.True(task1.Result ^ task2.Result); } The test looks pretty similar to the TestConcurrentAccountCreation from the previous tutorial. The main difference is that it first runs a CreateAccount request and waits it to complete, because without first creating an account you cannot test its deletion! The test then invokes two DeleteAccount requests, without waiting so that they can run at the same time, then waits for both to complete before finally asserting that only one deletion happened (and the other was ignored). Run this TestConcurrentAccountDeletion test using Coyote (remember to use coyote rewrite first!): coyote rewrite .\\AccountManager.dll coyote test .\\AccountManager.dll -m TestConcurrentAccountDeletion -i 100 When you run this TestConcurrentAccountDeletion test using Coyote, you\u2019ll find that Coyote finds a bug very fast. This bug is caused due to a very similar race condition that made the TestConcurrentAccountCreation test fail. . Testing .\\AccountManager.dll ... Method TestConcurrentAccountDeletion ... Started the testing task scheduler (process:15672). ... Created '1' testing task (process:15672). ... Task 0 is using 'random' strategy (seed:3336165456). ..... Iteration #1 ..... Iteration #2 ..... Iteration #3 ... Task 0 found a bug. ... Emitting task 0 traces: ..... Writing AccountManager.dll\\CoyoteOutput\\AccountManager_0_0.txt ..... Writing AccountManager.dll\\CoyoteOutput\\AccountManager_0_0.schedule ... Elapsed 0.1939681 sec. ... Testing statistics: ..... Found 1 bug. ... Scheduling statistics: ..... Explored 3 schedules: 3 fair and 0 unfair. ..... Found 33.33% buggy schedules. ..... Number of scheduling points in fair terminating schedules: 24 (min), 27 (avg), 31 (max). ... Elapsed 0.444569 sec. Both concurrent DeleteAccount requests conclude that the account exists, before either of them gets a chance to delete the row. Then due to the race condition, both requests proceed to delete the row with one succeeding and the other failing with a RowNotFoundException exception. // Returns true if the account is deleted, else false. public async Task<bool> DeleteAccount(string accountName) { if (!await this.AccountCollection.DoesRowExist(accountName)) { return false; } return await this.AccountCollection.DeleteRow(accountName); } This exception is a bug that could possibly lead to unintended consequences in your logic (e.g. data corruption or loss). It could also trigger a 500 internal server error , if AccountManager was a deployed service, which is not a nice HTTP status code to return to the client of the request! Here\u2019s one way to fix the DeleteAccount method: // Returns true if the account is deleted, else false. public async Task<bool> DeleteAccount(string userName) { try { return await this.AccountCollection.DeleteRow(userName); } catch (RowNotFoundException) { return false; } } The above implementation avoids using the DoesRowExist method, because you can never be sure that some other concurrent request did not already delete the same row while this method is executing between the DoesRowExist and DeleteRow calls. Such race conditions might not happen most of the times, but clearly some times they can happen. In production, with thousands of requests happening at the same time, such race conditions might manifest more often and are notoriously hard to reproduce and debug. This is why using Coyote can really help. Going back to the fixed method above, it directly calls DeleteRow on IDbCollection and relies on the database returning an error response (through the RowNotFound exception) to deal with such race conditions. It effectively offloads the problem of preventing such races to the database itself. Trying to do this in the application logic would be really hard. So far you wrote two concurrency unit tests, one exercising two concurrent CreateAccount requests and the other one exercising two concurrent DeleteAccount requests. Can you think of other interesting test cases that would allow us to test the CRUD operations of AccountManager more thoroughly? Any set of methods that may read or write shared state (and thus potentially create interference) are a great candidate for writing concurrency unit tests. What about a race between a CreateAccount and DeleteAccount call? At first glance, this may seem like a weird test to write as you can\u2019t control the order in which the two methods will concurrently execute in respect with each other. This makes it difficult to write meaningful assertions at the end of the test. But if you think about this more deeply, you will realize that there are only a few distinct outcomes of these races and you can assert for each of these outcomes. Tests like these are very useful for ensuring that when CRUD operations execute concurrently (which is the norm in production!), a resource (an account in this case) is either fully created or fully deleted, and is not left in a half-broken state. This particular example is simple but you can easily imagine more complex examples where such race conditions can in fact lead to your state being corrupted (e.g. partially created and partially deleted) in the presence of concurrency bugs. Coyote allows you to easily test exactly these kinds of scenarios, making sure that your customer data will not get corrupted. The awesome part is that Coyote will find and help you debug these bugs on your local machine before you deploy your service, saving you ton of headache! Of course this does not only apply to CRUD operations and resource providers, you can imagine many other systems can benefit of this kind of testing! Going back to our AccountManager example, let\u2019s write the test that exercises CreateAccount and DeleteAccount requests happening at the same time. The test is a bit more involved this time. [Microsoft.Coyote.SystematicTesting.Test] public static async Task TestConcurrentAccountCreationAndDeletion() { // Initialize the mock in-memory DB and account manager. var dbCollection = new InMemoryDbCollection(); var accountManager = new AccountManager(dbCollection); // Create some dummy data. string accountName = \"MyAccount\"; string accountPayload = \"...\"; // Call CreateAccount and DeleteAccount without awaiting, which makes both // methods run asynchronously with each other. var createTask = accountManager.CreateAccount(accountName, accountPayload); var deleteTask = accountManager.DeleteAccount(accountName); // Then wait both requests to complete. await Task.WhenAll(createTask, deleteTask); // The CreateAccount request will always succeed, no matter what. The DeleteAccount // may or may not succeed depending on if it finds the account already created or // not created while executing concurrently with the CreateAccount request. Assert.True(createTask.Result); if (!deleteTask.Result) { // The DeleteAccount request didn't find the account and failed as expected. // We assert that the account payload is still available. string fetchedAccountPayload = await accountManager.GetAccount(accountName); Assert.Equal(accountPayload, fetchedAccountPayload); } else { // If CreateAccount and DeleteAccount both returned true, then the account // must have been created before the deletion happened. // We assert that the payload is not available, as the account was deleted. string fetchedAccountPayload = await accountManager.GetAccount(accountName); Assert.Null(fetchedAccountPayload); } } Now run your TestConcurrentAccountCreationAndDeletion test with Coyote (remember to rewrite the assembly first!) and see if it passes. coyote rewrite .\\AccountManager.dll coyote test .\\AccountManager.dll -m TestConcurrentAccountCreationAndDeletion -i 100 The test passed without reporting any bugs which gives you confidence in the correctness of your code. . Testing .\\AccountManager.dll ... Method TestConcurrentAccountCreationAndDeletion ... Started the testing task scheduler (process:25840). ... Created '1' testing task (process:25840). ... Task 0 is using 'random' strategy (seed:2968084874). ..... Iteration #1 ..... Iteration #2 ..... Iteration #3 ..... Iteration #4 ..... Iteration #5 ..... Iteration #6 ..... Iteration #7 ..... Iteration #8 ..... Iteration #9 ..... Iteration #10 ..... Iteration #20 ..... Iteration #30 ..... Iteration #40 ..... Iteration #50 ..... Iteration #60 ..... Iteration #70 ..... Iteration #80 ..... Iteration #90 ..... Iteration #100 ... Testing statistics: ..... Found 0 bugs. ... Scheduling statistics: ..... Explored 100 schedules: 100 fair and 0 unfair. ..... Number of scheduling points in fair terminating schedules: 12 (min), 23 (avg), 35 (max). ... Elapsed 0.2443369 sec. Often times, even if your code is correct and Coyote doesn\u2019t find any bugs, it makes you deeply think about possible scenarios and outcomes in the presence of race conditions in your logic, and helps you reason about the correct behavior. This clarity in thinking alone is extremely valuable. Developers often reason about edge cases when writing sequential tests, but sometimes miss bugs in the presence of concurrency as they don\u2019t write focused concurrency unit tests, because they are impractical to write without a tool like Coyote. Now this was a simple example but you can imagine how it would be possible for the AccountManager to get into an inconsistent state if the CreateAccount and DeleteAccount methods involved multiple steps, such as modifying a couple of collections instead of just one, emitting events and create entries in other non-database systems (e.g. provisioning a dedicated Azure Storage container for the account).","title":"Walkthrough"},{"location":"tutorials/test-concurrent-operations/#get-the-sample-source-code","text":"To get the complete source code for the AccountManager tutorial, clone the Coyote Samples git repo . You can build the sample by running the following command: powershell -f build.ps1 To rewrite and test the sample with Coyote you can use the following commands (as discussed above): coyote rewrite .\\AccountManager.dll coyote test .\\AccountManager.dll -m TestConcurrentAccountDeletion -i 100 If you find a bug you can replay with the following command (providing the correct .schedule file reported from the previous coyote test that failed): coyote replay .\\AccountManager.dll -schedule AccountManager_0_0.schedule -m TestConcurrentAccountDeletion Feel free to play around with the code and write more concurrency unit tests with Coyote!","title":"Get the sample source code"},{"location":"tutorials/test-failover/","text":"Test failover and liveness Wikipedia provides this definition : \u201c Failover is switching to a redundant or standby computer server, system, hardware component or network upon the failure or abnormal termination of the previously active application, server, system, hardware component, or network. Systems designers usually provide failover capability in servers, systems or networks requiring near-continuous availability and a high degree of reliability.\u201d This sample applies the failover concept to the firmware of an automated espresso machine using the Coyote asynchronous tasks programming model. Imagine what would happen if the tiny CPU running the machine rebooted in the middle of making a coffee. What bad things might happen? Can we design a code that can handle this scenario and provide a more fault tolerant coffee machine? An identical version of this tutorial is also available that uses the coyote asynchronous actors programming model. The following diagram shows how Coyote can be used to test this scenario and help you design more reliable software. The CoffeeMachine is modeled as an asynchronous interface using controlled Tasks . This example it not providing real firmware, instead it mocks the hardware sensor platform built into the machine. This is done in the asynchronous MockSensors class. This class provides async ways of reading sensor values like the water temperature and setting things like the power button, or turning on and off the coffee grinder and so on. The reason we are using an asynchronous design is that even in the smallest of devices, often times there is a message passing architecture where different hardware components are connected via some sort of bus, whether it is a simple serial port, or something more sophisticated like a CAN bus . We will test that we can kill the CoffeeMachine and restart it without anything bad happening. This test is setup by the FailoverDriver . The FailoverDriver lets the first CoffeeMachine instance run for a bit then it randomly kills it by using the TerminateAsync method, then it starts a new CoffeeMachine . The new CoffeeMachine instance needs to figure out the state of the sensors such that when a MakeCoffeeEvent arrives, it doesn\u2019t do something silly that breaks the machine. The MockSensors class is not killed so that it acts as a persistent store for sensor state across all instances of the CoffeeMachine . Some safety Asserts are placed in the code that verify certain important things, including: - do not turn on heater if there is no water - do not turn on grinder if there are no beans in the hopper - do not turn on shot maker if there is no water There is also a correctness assert in the CoffeeMachine to make sure the correct number of espresso shots are made and there is a LivenessMonitor that monitors the CoffeeMachine to make sure it never gets stuck, i.e., it always finishes the job it was given or it goes to an error state if the machine needs to be fixed. See Liveness Checking . A number of excellent bugs were found by Coyote during the development of this sample, and this illustrates the fact that Coyote can be applied to any type of asynchronous software, not just cloud services. There is still one bug remaining in the code which you can find using coyote test , and it happens after failover just to prove the usefulness of this testing methodology. What you will need To run the CoffeeMachine example, you will need to: Install Visual Studio 2019 . Install the .NET 5.0 version of the coyote tool . Clone the Coyote Samples git repo . Be familiar with the coyote tool. See using Coyote . Build the samples Build the coyote-samples repo by running the following command: powershell -f build.ps1 Run the failover coffee machine application Now you can run the CoffeeMachine application: \"./bin/net5.0/CoffeeMachineTasks.exe\" The Coffee Machine There are many different types of coffee machines. This example is based on the following machine which can automatically heat water, grind beans, and make an espresso shot all with the press of a button: The following diagram shows the abstract state machine that is implemented in C# code: Run the executable without using coyote test (this is called running in production mode ), you will see the following console output. Notice in the output below that the FailoverDriver forces the termination of the CoffeeMachine right in the middle of making a coffee. Then when the CoffeeMachine is restarted, the FailoverDriver requests another coffee and the CoffeeMachine is able to continue on, the water is already warm, and it dumps the old grinds so you have the freshest possible coffee each time. <FailoverDriver> ################################################################# <FailoverDriver> starting new CoffeeMachine iteration 0. <CoffeeMachine> initializing... <CoffeeMachine> checking initial state of sensors... <CoffeeMachine> Water level is 23 % <CoffeeMachine> Hopper level is 85 % <CoffeeMachine> Warming the water to 100 degrees <CoffeeMachine> Turning on the water heater <CoffeeMachine> Coffee machine is warming up (71 degrees)... <CoffeeMachine> Coffee machine is warming up (81 degrees)... <CoffeeMachine> Coffee machine is warming up (91 degrees)... <CoffeeMachine> Coffee machine water temperature is now 100 <CoffeeMachine> Coffee machine water temperature is now 100 <CoffeeMachine> Coffee machine is ready to make coffee (green light is on) <CoffeeMachine> Turning off the water heater <CoffeeMachine> Coffee machine is ready to make coffee (green light is on) <CoffeeMachine> Coffee requested, shots=2 <CoffeeMachine> Grinding beans... <CoffeeMachine> PortaFilter is 10 % full <CoffeeMachine> PortaFilter is 20 % full <CoffeeMachine> PortaFilter is 30 % full <FailoverDriver> forcing termination of CoffeeMachine. <CoffeeMachine> Coffee Machine Terminating... <CoffeeMachine> Dumping the grinds! <CoffeeMachine> ################################################################# <CoffeeMachine> # Coffee Machine Halted # <CoffeeMachine> ################################################################# <CoffeeMachine> <FailoverDriver> ################################################################# <FailoverDriver> starting new CoffeeMachine iteration 1. <CoffeeMachine> initializing... <CoffeeMachine> checking initial state of sensors... <CoffeeMachine> Water level is 22 % <CoffeeMachine> Hopper level is 38 % <CoffeeMachine> Warming the water to 100 degrees <CoffeeMachine> Coffee machine water temperature is now 100 <CoffeeMachine> Coffee machine is ready to make coffee (green light is on) <CoffeeMachine> Coffee requested, shots=3 <CoffeeMachine> Grinding beans... <CoffeeMachine> PortaFilter is 10 % full <CoffeeMachine> PortaFilter is 20 % full <CoffeeMachine> PortaFilter is 30 % full <CoffeeMachine> PortaFilter is 40 % full <CoffeeMachine> PortaFilter is 50 % full <CoffeeMachine> PortaFilter is 60 % full <CoffeeMachine> PortaFilter is 70 % full <CoffeeMachine> PortaFilter is 80 % full <CoffeeMachine> PortaFilter is 90 % full <CoffeeMachine> PortaFilter is full <CoffeeMachine> Making shots... <CoffeeMachine> Shot count is 0 <CoffeeMachine> Shot count is 1 <CoffeeMachine> 2 shots completed and 2 shots requested! <CoffeeMachine> Dumping the grinds! <FailoverDriver> CoffeeMachine completed the job. ... You will not see this exact output because the test injects some randomness. The test will continue on making coffee until it runs out of either water or coffee beans and the FailoverDriver halts each CoffeeMachine instance at random times until the machine is out of resources, at which point the test is complete. The MockSensors also randomly choose some error conditions, so instead of the above you may see some errors like: <CoffeeMachine> Cannot safely operate coffee machine with the door open! <CoffeeMachine> Coffee machine needs manual refilling of water and/or coffee beans! If you see these errors, just press ENTER to terminate the program and run it again. These random start conditions just help the test cover more cases. Each halted machine is terminated and discarded, then a new CoffeeMachine instance is started. Each new CoffeeMachine instance must figure out what is happening with the sensors and make the next coffee without incident. Eventually a CoffeeMachine will report there is no more water or coffee beans and then it will stop with an error message saying the machine needs to be manually refilled. Coyote testing You can now use coyote test to exercise the code and see if any bugs can be found. From the coyote-samples folder: coyote test ./bin/net5.0/CoffeeMachineTasks.dll -i 1000 -ms 500 --sch-pct 10 Chances are this will find a bug quickly, one of the safety assertions will fire and you will see that a test output log is produced, like this: .\\bin\\net5.0\\Output\\CoffeeMachineTasks.exe\\CoyoteOutput\\CoffeeMachine_0_0.txt This log contains only the one test iteration that failed, and towards the end you will see something like this: <ErrorLog> Please do not turn on grinder if there are no beans in the hopper So the CoffeeMachine accidentally tried to grind beans when the hopper was empty. In the log you will see that the FailoverDriver has halted CoffeeMachine once or twice then the new CoffeeMachine instance which made it all the way to Grinding beans where it tripped the safety assert in MockSensors . So the bug here is that somehow, the second CoffeeMachine instance missed the fact that it was low on coffee beans. A bug exists in the code somewhere. Can you find it? It is not a trivial bug because the CheckSensors state is clearly checking the coffee level by sending the ReadHopperLevelEvent to the MockSensors actor and CheckInitialState does not advance to the HeatingWater state until this reading is returned. So what happened? Hint: if you search backwards in the output log you will find the following situation reported: <CoffeeMachine> Hopper level is -54 % The first CoffeeMachine instance left the grinder running a bit too long, and the sensor got confused thinking the coffee level is negative. The new CoffeeMachine instance never thought about this situation and checked only: if ((int)this.HopperLevel.Value == 0) ... And so it missed the fact it might be negative. The fix is easy, just change this condition to <= and the bug goes away. The fact that such a bug was found shows the usefulness of the failover testing strategy. Testing the scheduling of highly asynchronous operations This raises a bigger design question, how did the coffee level become negative? In firmware it is common to poll sensor readings and do something based on that. In this case we are polling a PortaFilterCoffeeLevelEvent in a tight loop while in the GrindingBeans state. Meanwhile the MockSensors class has a ControlledTimer running and when MonitorGrinder is called it decreases the coffee level by 10 percent during every time interval. So we have a very asynchronous operation going on here. Coffee level is decreasing based on a timer, and the CoffeeMachine is monitoring that coffee level using async events. This all seems to work perfectly in the production code where we see this output: <CoffeeMachine> Grinding beans... <CoffeeMachine> PortaFilter is 10 % full <CoffeeMachine> PortaFilter is 20 % full <CoffeeMachine> PortaFilter is 30 % full <CoffeeMachine> PortaFilter is 40 % full <CoffeeMachine> PortaFilter is 50 % full <CoffeeMachine> PortaFilter is 60 % full <CoffeeMachine> PortaFilter is 70 % full <CoffeeMachine> PortaFilter is 80 % full <CoffeeMachine> PortaFilter is 90 % full <CoffeeMachine> PortaFilter is full And the reason it works is because your Operating System is scheduling both of these async threads in a way that is relatively fair meaning one does not run for a long time without the other being scheduled also. But what if these two systems were running in a distributed world and one of them hangs for a long time? This is the kind of thread scheduling that coyote test is testing where one set of async tasks can run way ahead of the others. You need to take this into account when using timer based async events. One way to improve the design in a firmware based system like a coffee machine is to switch from a polling based system to an interrupt based system where the MockSensors can send important events to the CoffeeMachine . This style of interrupt based eventing is used to model the ShotCompleteEvent , WaterHotEvent , WaterEmptyEvent and HopperEmptyEvent . This shows how Coyote can help find actual design flaws in your code so you can design a system that is more robust in the face of unexpected faults. The coyote test engine provides several different scheduling strategies that test different kinds of fairness algorithms. These are designed to find different kinds of bugs. The following command line shows how to use --sch-portfolio and the --parallel options to test a bunch of different strategies in parallel, each in different test processes: coyote test ./bin/net5.0/CoffeeMachineTasks.dll -i 1000 -ms 500 --sch-portfolio --parallel 8 which outputs the following: . Testing .\\bin\\net5.0\\CoffeeMachineTasks.dll Starting TestingProcessScheduler in process 42036 ... Created '8' testing tasks. ... Task 3 is using 'FairPCT' strategy (seed:2143). ... Task 5 is using 'FairPCT' strategy (seed:3489). ... Task 2 is using 'ProbabilisticRandom' strategy (seed:1470). ... Task 7 is using 'FairPCT' strategy (seed:4835). ... Task 0 is using 'Random' strategy (seed:124). ... Task 6 is using 'ProbabilisticRandom' strategy (seed:4162). ... Task 4 is using 'ProbabilisticRandom' strategy (seed:2816). ... Task 1 is using 'FairPCT' strategy (seed:797). ... The --parallel 8 option means use 8 test processes in parallel, each one is assigned a random scheduling strategy. Each process runs until the first one finds a bug, then they are all terminated and the bug is reported. This can be useful when you want to leverage the full power of your computer to find those bugs that are particularly hard to find more quickly. Liveness monitor As described in the documentation on Liveness Checking the CoffeeMachine must also eventually finish what it is doing. It must either make a coffee when requested and return to the Ready state, or it must find a problem and go to the Error state or the RefillRequired state. This \u201cliveness\u201d property can be enforced using a very simple LivenessMonitor as shown below: internal class LivenessMonitor : Monitor { public class BusyEvent : Event { } public class IdleEvent : Event { } [Start] [Cold] [OnEventGotoState(typeof(BusyEvent), typeof(Busy))] [IgnoreEvents(typeof(IdleEvent))] private class Idle : State { } [Hot] [OnEventGotoState(typeof(IdleEvent), typeof(Idle))] [IgnoreEvents(typeof(BusyEvent))] private class Busy : State { } } This type of Monitor is also a special kind of limited state machine . The CoffeeMachine can send events to this monitor to tell it when it has switched into Busy state or Idle state. When the CoffeeMachine starts heating water, or making coffee it sends this event: Specification.Monitor<LivenessMonitor>(new LivenessMonitor.BusyEvent()); and when the CoffeeMachine is done making coffee or it has moved to an error state it sends this event: Specification.Monitor<LivenessMonitor>(new LivenessMonitor.IdleEvent()); The Busy state is marked as a [Hot] state and the Idle state is marked as a [Cold] state. During testing if coyote test finds the LivenessMonitor to be stuck in the [Hot] state too long it raises an exception and the test fails. Reliable termination handshake You may notice in the code that when the FailoverDriver wants to stop the first CoffeeMachine it calls TerminateAsync and waits for this async task to complete before it starts a new CoffeeMachine . This may seem a bit convoluted but you can\u2019t just create a new CoffeeMachine hoping the old one would be garbage collected because this would lead to confusion in the MockSensors class which was written to expect one and only one client CoffeeMachine at a time. The TerminateAsync handshake solves that problem. Summary Failover testing is simple to achieve using Coyote and yields many interesting bugs in your code, including some thought provoking design bugs. The technique of halting your \u201cproduction\u201d objects, and recreating them by reading from a \u201cpersistent\u201d mock (which is not halted during testing) can be generalized to many other scenarios (e.g. cloud services) where someone needs to test failover logic of production code using Coyote. In this tutorial you learned: How to do failover testing in the Coyote controlled Task programming model. How to use Coyote in a firmware/sensor scenario. How to use --sch-portfolio testing on multiple processes to find tricky bugs more quickly. How Assert helps find violations of safety properties during testing. How to write a LivenessMonitor .","title":"Test failover and liveness"},{"location":"tutorials/test-failover/#test-failover-and-liveness","text":"Wikipedia provides this definition : \u201c Failover is switching to a redundant or standby computer server, system, hardware component or network upon the failure or abnormal termination of the previously active application, server, system, hardware component, or network. Systems designers usually provide failover capability in servers, systems or networks requiring near-continuous availability and a high degree of reliability.\u201d This sample applies the failover concept to the firmware of an automated espresso machine using the Coyote asynchronous tasks programming model. Imagine what would happen if the tiny CPU running the machine rebooted in the middle of making a coffee. What bad things might happen? Can we design a code that can handle this scenario and provide a more fault tolerant coffee machine? An identical version of this tutorial is also available that uses the coyote asynchronous actors programming model. The following diagram shows how Coyote can be used to test this scenario and help you design more reliable software. The CoffeeMachine is modeled as an asynchronous interface using controlled Tasks . This example it not providing real firmware, instead it mocks the hardware sensor platform built into the machine. This is done in the asynchronous MockSensors class. This class provides async ways of reading sensor values like the water temperature and setting things like the power button, or turning on and off the coffee grinder and so on. The reason we are using an asynchronous design is that even in the smallest of devices, often times there is a message passing architecture where different hardware components are connected via some sort of bus, whether it is a simple serial port, or something more sophisticated like a CAN bus . We will test that we can kill the CoffeeMachine and restart it without anything bad happening. This test is setup by the FailoverDriver . The FailoverDriver lets the first CoffeeMachine instance run for a bit then it randomly kills it by using the TerminateAsync method, then it starts a new CoffeeMachine . The new CoffeeMachine instance needs to figure out the state of the sensors such that when a MakeCoffeeEvent arrives, it doesn\u2019t do something silly that breaks the machine. The MockSensors class is not killed so that it acts as a persistent store for sensor state across all instances of the CoffeeMachine . Some safety Asserts are placed in the code that verify certain important things, including: - do not turn on heater if there is no water - do not turn on grinder if there are no beans in the hopper - do not turn on shot maker if there is no water There is also a correctness assert in the CoffeeMachine to make sure the correct number of espresso shots are made and there is a LivenessMonitor that monitors the CoffeeMachine to make sure it never gets stuck, i.e., it always finishes the job it was given or it goes to an error state if the machine needs to be fixed. See Liveness Checking . A number of excellent bugs were found by Coyote during the development of this sample, and this illustrates the fact that Coyote can be applied to any type of asynchronous software, not just cloud services. There is still one bug remaining in the code which you can find using coyote test , and it happens after failover just to prove the usefulness of this testing methodology.","title":"Test failover and liveness"},{"location":"tutorials/test-failover/#what-you-will-need","text":"To run the CoffeeMachine example, you will need to: Install Visual Studio 2019 . Install the .NET 5.0 version of the coyote tool . Clone the Coyote Samples git repo . Be familiar with the coyote tool. See using Coyote .","title":"What you will need"},{"location":"tutorials/test-failover/#build-the-samples","text":"Build the coyote-samples repo by running the following command: powershell -f build.ps1","title":"Build the samples"},{"location":"tutorials/test-failover/#run-the-failover-coffee-machine-application","text":"Now you can run the CoffeeMachine application: \"./bin/net5.0/CoffeeMachineTasks.exe\"","title":"Run the failover coffee machine application"},{"location":"tutorials/test-failover/#the-coffee-machine","text":"There are many different types of coffee machines. This example is based on the following machine which can automatically heat water, grind beans, and make an espresso shot all with the press of a button: The following diagram shows the abstract state machine that is implemented in C# code: Run the executable without using coyote test (this is called running in production mode ), you will see the following console output. Notice in the output below that the FailoverDriver forces the termination of the CoffeeMachine right in the middle of making a coffee. Then when the CoffeeMachine is restarted, the FailoverDriver requests another coffee and the CoffeeMachine is able to continue on, the water is already warm, and it dumps the old grinds so you have the freshest possible coffee each time. <FailoverDriver> ################################################################# <FailoverDriver> starting new CoffeeMachine iteration 0. <CoffeeMachine> initializing... <CoffeeMachine> checking initial state of sensors... <CoffeeMachine> Water level is 23 % <CoffeeMachine> Hopper level is 85 % <CoffeeMachine> Warming the water to 100 degrees <CoffeeMachine> Turning on the water heater <CoffeeMachine> Coffee machine is warming up (71 degrees)... <CoffeeMachine> Coffee machine is warming up (81 degrees)... <CoffeeMachine> Coffee machine is warming up (91 degrees)... <CoffeeMachine> Coffee machine water temperature is now 100 <CoffeeMachine> Coffee machine water temperature is now 100 <CoffeeMachine> Coffee machine is ready to make coffee (green light is on) <CoffeeMachine> Turning off the water heater <CoffeeMachine> Coffee machine is ready to make coffee (green light is on) <CoffeeMachine> Coffee requested, shots=2 <CoffeeMachine> Grinding beans... <CoffeeMachine> PortaFilter is 10 % full <CoffeeMachine> PortaFilter is 20 % full <CoffeeMachine> PortaFilter is 30 % full <FailoverDriver> forcing termination of CoffeeMachine. <CoffeeMachine> Coffee Machine Terminating... <CoffeeMachine> Dumping the grinds! <CoffeeMachine> ################################################################# <CoffeeMachine> # Coffee Machine Halted # <CoffeeMachine> ################################################################# <CoffeeMachine> <FailoverDriver> ################################################################# <FailoverDriver> starting new CoffeeMachine iteration 1. <CoffeeMachine> initializing... <CoffeeMachine> checking initial state of sensors... <CoffeeMachine> Water level is 22 % <CoffeeMachine> Hopper level is 38 % <CoffeeMachine> Warming the water to 100 degrees <CoffeeMachine> Coffee machine water temperature is now 100 <CoffeeMachine> Coffee machine is ready to make coffee (green light is on) <CoffeeMachine> Coffee requested, shots=3 <CoffeeMachine> Grinding beans... <CoffeeMachine> PortaFilter is 10 % full <CoffeeMachine> PortaFilter is 20 % full <CoffeeMachine> PortaFilter is 30 % full <CoffeeMachine> PortaFilter is 40 % full <CoffeeMachine> PortaFilter is 50 % full <CoffeeMachine> PortaFilter is 60 % full <CoffeeMachine> PortaFilter is 70 % full <CoffeeMachine> PortaFilter is 80 % full <CoffeeMachine> PortaFilter is 90 % full <CoffeeMachine> PortaFilter is full <CoffeeMachine> Making shots... <CoffeeMachine> Shot count is 0 <CoffeeMachine> Shot count is 1 <CoffeeMachine> 2 shots completed and 2 shots requested! <CoffeeMachine> Dumping the grinds! <FailoverDriver> CoffeeMachine completed the job. ... You will not see this exact output because the test injects some randomness. The test will continue on making coffee until it runs out of either water or coffee beans and the FailoverDriver halts each CoffeeMachine instance at random times until the machine is out of resources, at which point the test is complete. The MockSensors also randomly choose some error conditions, so instead of the above you may see some errors like: <CoffeeMachine> Cannot safely operate coffee machine with the door open! <CoffeeMachine> Coffee machine needs manual refilling of water and/or coffee beans! If you see these errors, just press ENTER to terminate the program and run it again. These random start conditions just help the test cover more cases. Each halted machine is terminated and discarded, then a new CoffeeMachine instance is started. Each new CoffeeMachine instance must figure out what is happening with the sensors and make the next coffee without incident. Eventually a CoffeeMachine will report there is no more water or coffee beans and then it will stop with an error message saying the machine needs to be manually refilled.","title":"The Coffee Machine"},{"location":"tutorials/test-failover/#coyote-testing","text":"You can now use coyote test to exercise the code and see if any bugs can be found. From the coyote-samples folder: coyote test ./bin/net5.0/CoffeeMachineTasks.dll -i 1000 -ms 500 --sch-pct 10 Chances are this will find a bug quickly, one of the safety assertions will fire and you will see that a test output log is produced, like this: .\\bin\\net5.0\\Output\\CoffeeMachineTasks.exe\\CoyoteOutput\\CoffeeMachine_0_0.txt This log contains only the one test iteration that failed, and towards the end you will see something like this: <ErrorLog> Please do not turn on grinder if there are no beans in the hopper So the CoffeeMachine accidentally tried to grind beans when the hopper was empty. In the log you will see that the FailoverDriver has halted CoffeeMachine once or twice then the new CoffeeMachine instance which made it all the way to Grinding beans where it tripped the safety assert in MockSensors . So the bug here is that somehow, the second CoffeeMachine instance missed the fact that it was low on coffee beans. A bug exists in the code somewhere. Can you find it? It is not a trivial bug because the CheckSensors state is clearly checking the coffee level by sending the ReadHopperLevelEvent to the MockSensors actor and CheckInitialState does not advance to the HeatingWater state until this reading is returned. So what happened? Hint: if you search backwards in the output log you will find the following situation reported: <CoffeeMachine> Hopper level is -54 % The first CoffeeMachine instance left the grinder running a bit too long, and the sensor got confused thinking the coffee level is negative. The new CoffeeMachine instance never thought about this situation and checked only: if ((int)this.HopperLevel.Value == 0) ... And so it missed the fact it might be negative. The fix is easy, just change this condition to <= and the bug goes away. The fact that such a bug was found shows the usefulness of the failover testing strategy.","title":"Coyote testing"},{"location":"tutorials/test-failover/#testing-the-scheduling-of-highly-asynchronous-operations","text":"This raises a bigger design question, how did the coffee level become negative? In firmware it is common to poll sensor readings and do something based on that. In this case we are polling a PortaFilterCoffeeLevelEvent in a tight loop while in the GrindingBeans state. Meanwhile the MockSensors class has a ControlledTimer running and when MonitorGrinder is called it decreases the coffee level by 10 percent during every time interval. So we have a very asynchronous operation going on here. Coffee level is decreasing based on a timer, and the CoffeeMachine is monitoring that coffee level using async events. This all seems to work perfectly in the production code where we see this output: <CoffeeMachine> Grinding beans... <CoffeeMachine> PortaFilter is 10 % full <CoffeeMachine> PortaFilter is 20 % full <CoffeeMachine> PortaFilter is 30 % full <CoffeeMachine> PortaFilter is 40 % full <CoffeeMachine> PortaFilter is 50 % full <CoffeeMachine> PortaFilter is 60 % full <CoffeeMachine> PortaFilter is 70 % full <CoffeeMachine> PortaFilter is 80 % full <CoffeeMachine> PortaFilter is 90 % full <CoffeeMachine> PortaFilter is full And the reason it works is because your Operating System is scheduling both of these async threads in a way that is relatively fair meaning one does not run for a long time without the other being scheduled also. But what if these two systems were running in a distributed world and one of them hangs for a long time? This is the kind of thread scheduling that coyote test is testing where one set of async tasks can run way ahead of the others. You need to take this into account when using timer based async events. One way to improve the design in a firmware based system like a coffee machine is to switch from a polling based system to an interrupt based system where the MockSensors can send important events to the CoffeeMachine . This style of interrupt based eventing is used to model the ShotCompleteEvent , WaterHotEvent , WaterEmptyEvent and HopperEmptyEvent . This shows how Coyote can help find actual design flaws in your code so you can design a system that is more robust in the face of unexpected faults. The coyote test engine provides several different scheduling strategies that test different kinds of fairness algorithms. These are designed to find different kinds of bugs. The following command line shows how to use --sch-portfolio and the --parallel options to test a bunch of different strategies in parallel, each in different test processes: coyote test ./bin/net5.0/CoffeeMachineTasks.dll -i 1000 -ms 500 --sch-portfolio --parallel 8 which outputs the following: . Testing .\\bin\\net5.0\\CoffeeMachineTasks.dll Starting TestingProcessScheduler in process 42036 ... Created '8' testing tasks. ... Task 3 is using 'FairPCT' strategy (seed:2143). ... Task 5 is using 'FairPCT' strategy (seed:3489). ... Task 2 is using 'ProbabilisticRandom' strategy (seed:1470). ... Task 7 is using 'FairPCT' strategy (seed:4835). ... Task 0 is using 'Random' strategy (seed:124). ... Task 6 is using 'ProbabilisticRandom' strategy (seed:4162). ... Task 4 is using 'ProbabilisticRandom' strategy (seed:2816). ... Task 1 is using 'FairPCT' strategy (seed:797). ... The --parallel 8 option means use 8 test processes in parallel, each one is assigned a random scheduling strategy. Each process runs until the first one finds a bug, then they are all terminated and the bug is reported. This can be useful when you want to leverage the full power of your computer to find those bugs that are particularly hard to find more quickly.","title":"Testing the scheduling of highly asynchronous operations"},{"location":"tutorials/test-failover/#liveness-monitor","text":"As described in the documentation on Liveness Checking the CoffeeMachine must also eventually finish what it is doing. It must either make a coffee when requested and return to the Ready state, or it must find a problem and go to the Error state or the RefillRequired state. This \u201cliveness\u201d property can be enforced using a very simple LivenessMonitor as shown below: internal class LivenessMonitor : Monitor { public class BusyEvent : Event { } public class IdleEvent : Event { } [Start] [Cold] [OnEventGotoState(typeof(BusyEvent), typeof(Busy))] [IgnoreEvents(typeof(IdleEvent))] private class Idle : State { } [Hot] [OnEventGotoState(typeof(IdleEvent), typeof(Idle))] [IgnoreEvents(typeof(BusyEvent))] private class Busy : State { } } This type of Monitor is also a special kind of limited state machine . The CoffeeMachine can send events to this monitor to tell it when it has switched into Busy state or Idle state. When the CoffeeMachine starts heating water, or making coffee it sends this event: Specification.Monitor<LivenessMonitor>(new LivenessMonitor.BusyEvent()); and when the CoffeeMachine is done making coffee or it has moved to an error state it sends this event: Specification.Monitor<LivenessMonitor>(new LivenessMonitor.IdleEvent()); The Busy state is marked as a [Hot] state and the Idle state is marked as a [Cold] state. During testing if coyote test finds the LivenessMonitor to be stuck in the [Hot] state too long it raises an exception and the test fails.","title":"Liveness monitor"},{"location":"tutorials/test-failover/#reliable-termination-handshake","text":"You may notice in the code that when the FailoverDriver wants to stop the first CoffeeMachine it calls TerminateAsync and waits for this async task to complete before it starts a new CoffeeMachine . This may seem a bit convoluted but you can\u2019t just create a new CoffeeMachine hoping the old one would be garbage collected because this would lead to confusion in the MockSensors class which was written to expect one and only one client CoffeeMachine at a time. The TerminateAsync handshake solves that problem.","title":"Reliable termination handshake"},{"location":"tutorials/test-failover/#summary","text":"Failover testing is simple to achieve using Coyote and yields many interesting bugs in your code, including some thought provoking design bugs. The technique of halting your \u201cproduction\u201d objects, and recreating them by reading from a \u201cpersistent\u201d mock (which is not halted during testing) can be generalized to many other scenarios (e.g. cloud services) where someone needs to test failover logic of production code using Coyote. In this tutorial you learned: How to do failover testing in the Coyote controlled Task programming model. How to use Coyote in a firmware/sensor scenario. How to use --sch-portfolio testing on multiple processes to find tricky bugs more quickly. How Assert helps find violations of safety properties during testing. How to write a LivenessMonitor .","title":"Summary"},{"location":"tutorials/testing-aspnet-service/","text":"Systematically testing an ASP.NET service This sample shows how to use Coyote to systematically test an ASP.NET service. The sample ASP.NET service included here implements a simple image gallery . Please note that this sample service contains some interesting bugs on purpose. You can run the unit tests with and without Coyote and you can run the web front end using the Azure storage emulators. What you will need You will also need to: Install Visual Studio 2019 . Install the .NET 5.0 version of the coyote tool . Clone the Coyote Samples git repo . Be familiar with the coyote tool. See using Coyote . If you want to actually run the sample (rather than just running the unit tests) then you will also need the following: Azure Storage Emulator must be installed and running. Azure Cosmos Emulator must be installed and running. Open Azure Cosmos Data Explorer from taskbar tray and copy the Primary Connection String from there into ~/ImageGalleryAspNet/ImageGalleryService/appsettings.json . Build the sample After cloning the Coyote Samples git repo run the following command: cd ImageGalleryAspNet dotnet build Running the sample You do not need to do this unless you really want to, you can do all the unit testing using coyote without running the development version of the service. But some people like to see the code running before they think about how to test it. Once all the above prerequisites are complete (including the storage emulators) you can run this app using two separate console windows as follows: cd ImageGalleryService dotnet run And in the second window: cd ImageGallery dotnet run Navigate your web browser to http://localhost:5000/ and you will see the empty ImageGallery site. Create a new test account and upload some of your favorite photos (you can do more than one at a time) and you will see them appear. The \u201cdotnet run\u201d consoles will also show logging output that shows you what is happening behind the scenes. Sample structure The ImageGallery.sln solution consists of five projects (all will be discussed below): ImageGallery - this is the web front end that uses the API service. ImageGalleryService - this is the ASP.NET API service. ImageGalleryClient - a helper API for talking to the service. Tests - this contains two regular unit tests that use MSTest . Tests.Coyote - this invokes the two tests in Tests wrapping them with the Coyote systematic testing engine. TraceReplayer - makes it easy to reproduce the bugs found by coyote test . The Image Gallery sample service This service is based on a 3-tier architecture: (1) a client (implemented by the unit tests and by the ImageGallery web front end), (2) two ASP.NET API services, one for managing accounts ( AccountController ) and one for managing image galleries ( GalleryController ) associated with these accounts, and (3) two backend storage systems used by these API services (Cosmos DB to store accounts, and Azure Blob Storage to store images). The AccountController has 4 APIs to Create , Update , Get and Delete an account. Create first checks if the account already exists, and if not it creates it in Cosmos DB. Similarly, Update and Get first check if the account exists and, if it does, it updates it, or returns it, accordingly. Finally, Delete first checks if the account exists, and if it does it deletes it from Cosmos DB and then also deletes the associated image container for this account from Azure Blob Storage. The GalleryController is similar. It has 4 APIs: Store , Get , Delete GetList . Store first checks if the account already exists in Cosmos DB and, if it does, it stores the image in Azure Blob Storage. Get is simple, it checks if the image blob exists, if it it does, it returns the image. Finally, Delete first checks if the account already exists in Cosmos DB and, if it does, it deletes the image blob from Azure Blob Storage. GetList can be used to enumerate the images in an account in pages. Bugs in the service As mentioned above, this service was designed in purpose to contain some interesting bugs to showcase systematic testing with Coyote. You can read the comments in the controllers for more details about the bugs, but briefly a lot of the above APIs have race conditions. For example, the controller checks that the account exists, and tries to update it, but another request could delete the account between those two operations, resulting in an unhandled exception, and thus a 500 internal server error, which is a bad bug. The service should never return a 500 to its users! These kind of bugs involving race conditions between concurrent requests are hard to test. Unit tests are typically tailored to test sequential programs. Async race conditions can result in flaky tests and when you start debugging them, adding break points, and diving in, the race condition might just disappear, something known as a Heisenbug ! We wrote two unit tests (using MSTest and Microsoft.AspNetCore.Mvc.Testing ) to exercise the service and uncover bugs: TestConcurrentAccountRequests and TestConcurrentAccountAndImageRequests . The former only tests the AccountController , while the later tests both controllers at the same time. You can read more details in the comments for these tests, but let us quickly summarize what these tests do and what the bugs are. The TestConcurrentAccountRequests method initializes the mocks and injects them into the ASP.NET service, then creates a client, which does a Create account request to create a new account for Alice. It waits for this request to complete. It then concurrently invokes two requests: Update account and Delete account, and waits for both to complete. These requests are now racing, and because there is a race condition in the AccountController controller logic, the update request can fail due to an unhandled exception (500 error code) and this failure is nondeterministic. The issue is that the controller first checks if the account exists and, if it does, it then updates it. But after the \u201cdoes account exists check\u201d, the delete request could run, deleting the account! The update then tries to run which triggers the bug! Interestingly the non-coyote test run rarely finds this bug although it is possible to see it with teh ImageGallery web front end if you use multiple browser windows and do batch upload and delete operations in each. The TestConcurrentAccountAndImageRequests initializes the mocks and injects them into the ASP.NET service, then creates a client, which does a Create account request to create a new account for Alice. It waits for this request to complete. It then concurrently invokes two requests: Store image and Delete account, and waits for both to complete. Similar to the above test, these requests are now racing, and because there is a race condition in the controller logic, the store request can nondeterministically store the image in an \u201corphan\u201d container in Azure Storage, even if the associated account was deleted. This is more subtle bug because the request itself is not throwing an unhandled exception, it is just a sneaky race when trying to read/write from/to two backend systems at the same time. This issue is also a data race and you can see the detail in the controller logic. Most of the bugs described in this tutorial (and in the comments in the service code) can be fixed by catching the exceptions thrown by the (mock) storage systems (or checking their returned error codes) and returning back an appropriate non-500 error code to the client. Some of the bugs might also require to implement roll back logic in the case where a request updates one or more storage accounts in a non-transactional manner, which could result in stale data being stored, even if the the request failed. Before going further (and into Coyote), lets build and run the tests! How to run the unit tests Just run them from inside Visual Studio, or run the following: cd ImageGalleryAspNet dotnet test bin/net5.0/ImageGalleryTests.dll The tests may or may not trigger the bug! Most likely you will see this output: Total tests: 2 Passed: 2 Total time: 1.2053 Seconds And even if you do get them to fail, if you try to debug them, the bugs may or may not manifest (as they are Heizenbugs ). We surely want some better way of testing concurrent code, right? Coyote is here to help You can learn more about the systematic testing capabilities of Coyote here , but lets give a brief summary here to get quickly in action. Coyote serializes the execution of a concurrent program (i.e., only executes a single task at at time). A Coyote test executes this serialized program lots of times (called testing iterations), each time exploring different interleavings in a clever manner. If a bug is found, Coyote gives a trace that allows you to deterministically reproduce the bug. You can use the VS Debugger to go over the trace as many times as required to fix the bug. To be able to test this service, use Coyote\u2019s binary rewriting capabilities to instrument concurrency primitives (Coyote primarily supports common task-related types like Task and TaskCompletionSource , the lock statement, and some more ). This is handled by the build script above. How to run the Coyote systematic tests Please do not run the MSTest from inside Visual Studio, as it will currently run the un-rewritten binaries (requires a post build task to get around this). Instead, once you build the service and the tests, run the following from the root directory of the repo: coyote rewrite rewrite.coyote.json dotnet test bin/coyote/ImageGalleryTests.Coyote.dll This will rewrite the tests, and then run the tests inside the Coyote testing engine, up to 1000 iterations each, and report any found bugs. The bug should be found most of the time after just a few iterations (as they are not too deep). Besides the error output, you should see a bug error such as: X TestConcurrentAccountRequests [10s 407ms] Error Message: Assert.Fail failed. Found bug: Found unexpected error code. Replay trace using Coyote by running: TraceReplayer.exe TestConcurrentAccountRequests TestConcurrentAccountRequests.schedule Which also tells you how to reliably reproduce the bug using Coyote. How to reproduce a buggy concurrent trace As you can see above, the TestConcurrentAccountRequests failed. This bug is nondeterministic, and if you try debug it without Coyote it might not always happen. However, Coyote gives you a reliable repro. Right now, someone can use the replay functionality from the coyote replay tool or programmatically through the replay API, but for the purposes of this sample there is a simple TraceReplayer executable that takes the name of the test and the trace file produced by Coyote, and replays it in the VS debugger. To do this, just invoke the command mentioned in the error above (change the paths to the ones on your machine): TraceReplayer.exe TestConcurrentAccountRequests TestConcurrentAccountRequests.schedule You will also see that the trace output contains logs such as: [0HM34OD7O65E5] Creating account with id '0' (name: 'alice', email: 'alice@coyote.com'). [0HM34OD7O65E5] Creating container 'Accounts' in database 'ImageGalleryDB' if it does not exist. [0HM34OD7O65E5] Checking if item with partition key '0' and id '0' exists in container 'Accounts'. [0HM34OD7O65E5] Creating new item with partition key '0' and id '0' in container 'Accounts'. [0HM34OD7O65E7] Storing image with name 'beach' and account id '0'. [0HM34OD7O65E6] Deleting account with id '0'. [0HM34OD7O65E6] Creating container 'Accounts' in database 'ImageGalleryDB' if it does not exist. [0HM34OD7O65E7] Creating container 'Accounts' in database 'ImageGalleryDB' if it does not exist. [0HM34OD7O65E7] Checking if item with partition key '0' and id '0' exists in container 'Accounts'. [0HM34OD7O65E6] Checking if item with partition key '0' and id '0' exists in container 'Accounts'. [0HM34OD7O65E6] Deleting item with partition key '0' and id '0' in container 'Accounts'. [0HM34OD7O65E7] Creating container 'gallery-0' if it does not exist. [0HM34OD7O65E6] Deleting container 'gallery-0' if it exists. [0HM34OD7O65E7] Creating blob 'beach' in container 'gallery-0'. In the above logs, the [0HM34OD7O65E5] prefix is the HttpContext.TraceIdentifier which is a unique id per HTTP request. This makes it easier to see how Coyote explores lots of async interleaving during testing and debugging. In this example you can see it bouncing between 3 async tasks [0HM34OD7O65E5] , [0HM34OD7O65E6] and [0HM34OD7O65E7] and this controlled interleaving of tasks can help find lots of bugs. Troubleshooting Login fails with an unhandled exception has occurred while executing the request. Make sure the Azure storage emulators are running. SocketException: No connection could be made because the target machine actively refused it. Make sure the Azure storage emulators are running. System.AggregateException: \u2018Retry failed after 6 tries Make sure the Azure storage emulators are running. Make sure you can then connect to the azure storage emulator from the Azure storage explorer . Summary In this tutorial you learned: How to mock external systems like Azure Cosmos DB and Azure Storage for systematic testing. How to use the coyote rewrite command line to rewrite an ASP.NET service with task-based concurrency for systematic testing with Coyote. How to run a systematic test of unmodified code with Coyote inside an MSTest. How to replay a buggy trace of unmodified code with Coyote. Happy debugging!","title":"Testing aspnet service"},{"location":"tutorials/testing-aspnet-service/#systematically-testing-an-aspnet-service","text":"This sample shows how to use Coyote to systematically test an ASP.NET service. The sample ASP.NET service included here implements a simple image gallery . Please note that this sample service contains some interesting bugs on purpose. You can run the unit tests with and without Coyote and you can run the web front end using the Azure storage emulators.","title":"Systematically testing an ASP.NET service"},{"location":"tutorials/testing-aspnet-service/#what-you-will-need","text":"You will also need to: Install Visual Studio 2019 . Install the .NET 5.0 version of the coyote tool . Clone the Coyote Samples git repo . Be familiar with the coyote tool. See using Coyote . If you want to actually run the sample (rather than just running the unit tests) then you will also need the following: Azure Storage Emulator must be installed and running. Azure Cosmos Emulator must be installed and running. Open Azure Cosmos Data Explorer from taskbar tray and copy the Primary Connection String from there into ~/ImageGalleryAspNet/ImageGalleryService/appsettings.json .","title":"What you will need"},{"location":"tutorials/testing-aspnet-service/#build-the-sample","text":"After cloning the Coyote Samples git repo run the following command: cd ImageGalleryAspNet dotnet build","title":"Build the sample"},{"location":"tutorials/testing-aspnet-service/#running-the-sample","text":"You do not need to do this unless you really want to, you can do all the unit testing using coyote without running the development version of the service. But some people like to see the code running before they think about how to test it. Once all the above prerequisites are complete (including the storage emulators) you can run this app using two separate console windows as follows: cd ImageGalleryService dotnet run And in the second window: cd ImageGallery dotnet run Navigate your web browser to http://localhost:5000/ and you will see the empty ImageGallery site. Create a new test account and upload some of your favorite photos (you can do more than one at a time) and you will see them appear. The \u201cdotnet run\u201d consoles will also show logging output that shows you what is happening behind the scenes.","title":"Running the sample"},{"location":"tutorials/testing-aspnet-service/#sample-structure","text":"The ImageGallery.sln solution consists of five projects (all will be discussed below): ImageGallery - this is the web front end that uses the API service. ImageGalleryService - this is the ASP.NET API service. ImageGalleryClient - a helper API for talking to the service. Tests - this contains two regular unit tests that use MSTest . Tests.Coyote - this invokes the two tests in Tests wrapping them with the Coyote systematic testing engine. TraceReplayer - makes it easy to reproduce the bugs found by coyote test .","title":"Sample structure"},{"location":"tutorials/testing-aspnet-service/#the-image-gallery-sample-service","text":"This service is based on a 3-tier architecture: (1) a client (implemented by the unit tests and by the ImageGallery web front end), (2) two ASP.NET API services, one for managing accounts ( AccountController ) and one for managing image galleries ( GalleryController ) associated with these accounts, and (3) two backend storage systems used by these API services (Cosmos DB to store accounts, and Azure Blob Storage to store images). The AccountController has 4 APIs to Create , Update , Get and Delete an account. Create first checks if the account already exists, and if not it creates it in Cosmos DB. Similarly, Update and Get first check if the account exists and, if it does, it updates it, or returns it, accordingly. Finally, Delete first checks if the account exists, and if it does it deletes it from Cosmos DB and then also deletes the associated image container for this account from Azure Blob Storage. The GalleryController is similar. It has 4 APIs: Store , Get , Delete GetList . Store first checks if the account already exists in Cosmos DB and, if it does, it stores the image in Azure Blob Storage. Get is simple, it checks if the image blob exists, if it it does, it returns the image. Finally, Delete first checks if the account already exists in Cosmos DB and, if it does, it deletes the image blob from Azure Blob Storage. GetList can be used to enumerate the images in an account in pages.","title":"The Image Gallery sample service"},{"location":"tutorials/testing-aspnet-service/#bugs-in-the-service","text":"As mentioned above, this service was designed in purpose to contain some interesting bugs to showcase systematic testing with Coyote. You can read the comments in the controllers for more details about the bugs, but briefly a lot of the above APIs have race conditions. For example, the controller checks that the account exists, and tries to update it, but another request could delete the account between those two operations, resulting in an unhandled exception, and thus a 500 internal server error, which is a bad bug. The service should never return a 500 to its users! These kind of bugs involving race conditions between concurrent requests are hard to test. Unit tests are typically tailored to test sequential programs. Async race conditions can result in flaky tests and when you start debugging them, adding break points, and diving in, the race condition might just disappear, something known as a Heisenbug ! We wrote two unit tests (using MSTest and Microsoft.AspNetCore.Mvc.Testing ) to exercise the service and uncover bugs: TestConcurrentAccountRequests and TestConcurrentAccountAndImageRequests . The former only tests the AccountController , while the later tests both controllers at the same time. You can read more details in the comments for these tests, but let us quickly summarize what these tests do and what the bugs are. The TestConcurrentAccountRequests method initializes the mocks and injects them into the ASP.NET service, then creates a client, which does a Create account request to create a new account for Alice. It waits for this request to complete. It then concurrently invokes two requests: Update account and Delete account, and waits for both to complete. These requests are now racing, and because there is a race condition in the AccountController controller logic, the update request can fail due to an unhandled exception (500 error code) and this failure is nondeterministic. The issue is that the controller first checks if the account exists and, if it does, it then updates it. But after the \u201cdoes account exists check\u201d, the delete request could run, deleting the account! The update then tries to run which triggers the bug! Interestingly the non-coyote test run rarely finds this bug although it is possible to see it with teh ImageGallery web front end if you use multiple browser windows and do batch upload and delete operations in each. The TestConcurrentAccountAndImageRequests initializes the mocks and injects them into the ASP.NET service, then creates a client, which does a Create account request to create a new account for Alice. It waits for this request to complete. It then concurrently invokes two requests: Store image and Delete account, and waits for both to complete. Similar to the above test, these requests are now racing, and because there is a race condition in the controller logic, the store request can nondeterministically store the image in an \u201corphan\u201d container in Azure Storage, even if the associated account was deleted. This is more subtle bug because the request itself is not throwing an unhandled exception, it is just a sneaky race when trying to read/write from/to two backend systems at the same time. This issue is also a data race and you can see the detail in the controller logic. Most of the bugs described in this tutorial (and in the comments in the service code) can be fixed by catching the exceptions thrown by the (mock) storage systems (or checking their returned error codes) and returning back an appropriate non-500 error code to the client. Some of the bugs might also require to implement roll back logic in the case where a request updates one or more storage accounts in a non-transactional manner, which could result in stale data being stored, even if the the request failed. Before going further (and into Coyote), lets build and run the tests!","title":"Bugs in the service"},{"location":"tutorials/testing-aspnet-service/#how-to-run-the-unit-tests","text":"Just run them from inside Visual Studio, or run the following: cd ImageGalleryAspNet dotnet test bin/net5.0/ImageGalleryTests.dll The tests may or may not trigger the bug! Most likely you will see this output: Total tests: 2 Passed: 2 Total time: 1.2053 Seconds And even if you do get them to fail, if you try to debug them, the bugs may or may not manifest (as they are Heizenbugs ). We surely want some better way of testing concurrent code, right?","title":"How to run the unit tests"},{"location":"tutorials/testing-aspnet-service/#coyote-is-here-to-help","text":"You can learn more about the systematic testing capabilities of Coyote here , but lets give a brief summary here to get quickly in action. Coyote serializes the execution of a concurrent program (i.e., only executes a single task at at time). A Coyote test executes this serialized program lots of times (called testing iterations), each time exploring different interleavings in a clever manner. If a bug is found, Coyote gives a trace that allows you to deterministically reproduce the bug. You can use the VS Debugger to go over the trace as many times as required to fix the bug. To be able to test this service, use Coyote\u2019s binary rewriting capabilities to instrument concurrency primitives (Coyote primarily supports common task-related types like Task and TaskCompletionSource , the lock statement, and some more ). This is handled by the build script above.","title":"Coyote is here to help"},{"location":"tutorials/testing-aspnet-service/#how-to-run-the-coyote-systematic-tests","text":"Please do not run the MSTest from inside Visual Studio, as it will currently run the un-rewritten binaries (requires a post build task to get around this). Instead, once you build the service and the tests, run the following from the root directory of the repo: coyote rewrite rewrite.coyote.json dotnet test bin/coyote/ImageGalleryTests.Coyote.dll This will rewrite the tests, and then run the tests inside the Coyote testing engine, up to 1000 iterations each, and report any found bugs. The bug should be found most of the time after just a few iterations (as they are not too deep). Besides the error output, you should see a bug error such as: X TestConcurrentAccountRequests [10s 407ms] Error Message: Assert.Fail failed. Found bug: Found unexpected error code. Replay trace using Coyote by running: TraceReplayer.exe TestConcurrentAccountRequests TestConcurrentAccountRequests.schedule Which also tells you how to reliably reproduce the bug using Coyote.","title":"How to run the Coyote systematic tests"},{"location":"tutorials/testing-aspnet-service/#how-to-reproduce-a-buggy-concurrent-trace","text":"As you can see above, the TestConcurrentAccountRequests failed. This bug is nondeterministic, and if you try debug it without Coyote it might not always happen. However, Coyote gives you a reliable repro. Right now, someone can use the replay functionality from the coyote replay tool or programmatically through the replay API, but for the purposes of this sample there is a simple TraceReplayer executable that takes the name of the test and the trace file produced by Coyote, and replays it in the VS debugger. To do this, just invoke the command mentioned in the error above (change the paths to the ones on your machine): TraceReplayer.exe TestConcurrentAccountRequests TestConcurrentAccountRequests.schedule You will also see that the trace output contains logs such as: [0HM34OD7O65E5] Creating account with id '0' (name: 'alice', email: 'alice@coyote.com'). [0HM34OD7O65E5] Creating container 'Accounts' in database 'ImageGalleryDB' if it does not exist. [0HM34OD7O65E5] Checking if item with partition key '0' and id '0' exists in container 'Accounts'. [0HM34OD7O65E5] Creating new item with partition key '0' and id '0' in container 'Accounts'. [0HM34OD7O65E7] Storing image with name 'beach' and account id '0'. [0HM34OD7O65E6] Deleting account with id '0'. [0HM34OD7O65E6] Creating container 'Accounts' in database 'ImageGalleryDB' if it does not exist. [0HM34OD7O65E7] Creating container 'Accounts' in database 'ImageGalleryDB' if it does not exist. [0HM34OD7O65E7] Checking if item with partition key '0' and id '0' exists in container 'Accounts'. [0HM34OD7O65E6] Checking if item with partition key '0' and id '0' exists in container 'Accounts'. [0HM34OD7O65E6] Deleting item with partition key '0' and id '0' in container 'Accounts'. [0HM34OD7O65E7] Creating container 'gallery-0' if it does not exist. [0HM34OD7O65E6] Deleting container 'gallery-0' if it exists. [0HM34OD7O65E7] Creating blob 'beach' in container 'gallery-0'. In the above logs, the [0HM34OD7O65E5] prefix is the HttpContext.TraceIdentifier which is a unique id per HTTP request. This makes it easier to see how Coyote explores lots of async interleaving during testing and debugging. In this example you can see it bouncing between 3 async tasks [0HM34OD7O65E5] , [0HM34OD7O65E6] and [0HM34OD7O65E7] and this controlled interleaving of tasks can help find lots of bugs.","title":"How to reproduce a buggy concurrent trace"},{"location":"tutorials/testing-aspnet-service/#troubleshooting","text":"Login fails with an unhandled exception has occurred while executing the request. Make sure the Azure storage emulators are running. SocketException: No connection could be made because the target machine actively refused it. Make sure the Azure storage emulators are running. System.AggregateException: \u2018Retry failed after 6 tries Make sure the Azure storage emulators are running. Make sure you can then connect to the azure storage emulator from the Azure storage explorer .","title":"Troubleshooting"},{"location":"tutorials/testing-aspnet-service/#summary","text":"In this tutorial you learned: How to mock external systems like Azure Cosmos DB and Azure Storage for systematic testing. How to use the coyote rewrite command line to rewrite an ASP.NET service with task-based concurrency for systematic testing with Coyote. How to run a systematic test of unmodified code with Coyote inside an MSTest. How to replay a buggy trace of unmodified code with Coyote. Happy debugging!","title":"Summary"},{"location":"tutorials/actors/hello-world/","text":"Hello world example with actors HelloWorldActors is a simple program to get you started using the Coyote actors programming model . What you will need To run the Hello World Actors example, you will need to: Install Visual Studio 2019 . Install the .NET 5.0 version of the coyote tool . Clone the Coyote Samples git repo . Be familiar with the coyote tool. See using Coyote . Build the samples Build the coyote-samples repo by running the following command: powershell -f build.ps1 Run the HelloWorldActors application Now you can run the HelloWorldActors application: \"./bin/net5.0/HelloWorldActors.exe\" Press the ENTER key to terminate the program when it is done. Note that a bug has been inserted into the code intentionally and will be caught by a Coyote Assert . The program should display 1 to 5 greetings like Hello World! or Good Morning . The intentional bug is hard to reproduce when you run the program manually. The typical \u201cnormal\u201d run will look like this: press ENTER to terminate... Requesting 5 greetings Received greeting: Good Morning Received greeting: Hello World! Received greeting: Hello World! Received greeting: Hello World! Received greeting: Good Morning When the error is caught, an extra line of output is written saying: Exception 'Microsoft.Coyote.AssertionFailureException' was thrown in 0 (action '1'): Too many greetings returned! Finding the bug using Coyote test tool See Using Coyote for information on how to find the coyote test tool and setup your environment to use it. Enter the following from the command line: coyote test ./bin/net5.0/HelloWorldActors.dll --iterations 30 The result is: . Testing .\\bin\\net5.0\\HelloWorldActors.dll Starting TestingProcessScheduler in process 16432 ... Created '1' testing task. ... Task 0 is using 'random' strategy (seed:308255541). ..... Iteration #1 ..... Iteration #2 ... Task 0 found a bug. ... Emitting task 0 traces: ..... Writing .\\bin\\net5.0\\Output\\HelloWorldActors.exe\\CoyoteOutput\\HelloWorldActors_0_2.txt ..... Writing .\\bin\\net5.0\\Output\\HelloWorldActors.exe\\CoyoteOutput\\HelloWorldActors_0_2.schedule ... Elapsed 0.0906639 sec. ... Testing statistics: ..... Found 1 bug. ... Scheduling statistics: ..... Explored 2 schedules: 2 fair and 0 unfair. ..... Found 50.00% buggy schedules. ..... Number of scheduling points in fair terminating schedules: 23 (min), 30 (avg), 37 (max). ... Elapsed 0.1819877 sec. . Done The Coyote tester has found the bug very quickly\u2014something that takes much longer if testing manually. When using Coyote for testing more complex, real-world systems the time savings can be huge! This will give you the ability to find and fix even the most difficult to reproduce concurrency bugs before pushing to production . To learn more about testing with Coyote read here . The Greeter Please read Programming model: asynchronous actors to gain a basic understanding of the Actors programming model. The core of an Actor based Coyote program, is, well, an Actor class! The following Actor named Greeter is able to receive a RequestGreetingEvent to which it responds with a GreetingEvent : [OnEventDoAction(typeof(RequestGreetingEvent), nameof(HandleGreeting))] public class Greeter : Actor { /// This method is called when this actor receives a RequestGreetingEvent. private void HandleGreeting(Event e) { if (e is RequestGreetingEvent ge) { string greeting = this.RandomBoolean() ? \"Hello World!\" : \"Good Morning\"; this.SendEvent(ge.Caller, new GreetingEvent(greeting)); if (this.RandomBoolean(10)) { // bug: a 1 in 10 chance of sending too many greetings. this.SendEvent(ge.Caller, new GreetingEvent(greeting)); } } } } Notice the OnEventDoAction custom attribute decorating the class. This tells the Coyote runtime that this class expects to receive RequestGreetingEvents . These events will be queued in the inbox for this Actor until the right time to dequeue them and process them. The custom attribute tells the Coyote runtime to call the HandleGreeting method. The Coyote runtime will also report an error if a different type of event is sent to the Greeter . The HandleGreeting method is called with an Event parameter, and you know in this case the event will be of type RequestGreetingEvent . This event is defined in Events.cs like this: internal class RequestGreetingEvent : Event { public readonly ActorId Caller; public RequestGreetingEvent(ActorId caller) { this.Caller = caller; } } The inbox is crucial to the Actor model You can think of an Event declaration as a type of interface definition for Actors . Events really define the interface of an Actor because the caller will never get to see the Greeter class, so the caller can\u2019t just call HandleGreeting directly. The caller only gets to see an ActorId , which is like a Coyote runtime handle to the actor. There is a really important reason for this . Events are queued in an inbox managed by the Actor base class. This serializes the incoming events so that at any given time, only one event is being handled in the Greeter . This greatly simplifies concurrent programming. For example, there is no need to use lock to protect against data race conditions, and therefore no need to worry about deadlocks. Each Actor instance can run in a separate thread, so all actors in the system can be hugely parallel, but at the same time the processing inside an Actor is incredibly simple. So you get the best of both worlds, code that scales but is also easy to write. An Actor receives messages, and can create other Actor objects, and can send events. Notice the Greeter gets an ActorId from the RequestGreetingEvent and uses that to send a greeting back to the caller using SendEvent : this.SendEvent(ge.Caller, new GreetingEvent(greeting)); You can also see the bug which has been injected deliberately, namely, it randomly returns more than one GreetingEvent . A TestActor To test this Greeter you will need to setup a TestActor which is done in Program.cs . The TestActor creates the Greeter and sends between 1 and 5 RequestGreetingEvents . The TestActor is declared in a way that tells the Coyote runtime it is expecting to receive GreetingEvents as follows: [OnEventDoAction(typeof(GreetingEvent), nameof(HandleGreeting))] To make this a good test, the TestActor keeps track of how many greetings were sent and how many were received, and it writes an Assert to ensure it doesn\u2019t receive too many as follows: private void HandleGreeting(Event e) { // this is perfectly thread safe, because all message handling in actors is // serialized within the Actor class. this.Count--; string greeting = ((GreetingEvent)e).Greeting; Console.WriteLine(\"Received greeting: {0}\", greeting); this.Assert(this.Count >= 0, \"Too many greetings returned!\"); } Lastly, to test the TestActor you need to fire up the Coyote runtime which is done in the HostProgram Main entry point as follows: public static void Main() { var config = Configuration.Create(); IActorRuntime runtime = RuntimeFactory.Create(config); Execute(runtime); runtime.OnFailure += OnRuntimeFailure; Console.WriteLine(\"press ENTER to terminate...\"); Console.ReadLine(); } Notice that Coyote actors run in parallel, so you have to stop the program from terminating prematurely, which can be done with a Console.ReadLine call. In order for this program to also be testable using the coyote test tool, you need to declare a test method as follows: [Microsoft.Coyote.SystematicTesting.Test] public static void Execute(IActorRuntime runtime) { runtime.CreateActor(typeof(TestActor)); } The coyote test tool will call this method. But it will not call your Main entry point. So this Execute method needs to be standalone. It cannot depend on anything except statically initialized variables. There is no way to get command line arguments from coyote test through to this method. This Execute method is very simple, it just creates the TestActor . In Coyote once an actor is created it lives forever until it is halted. Note that Coyote programs can run forever, the coyote test tool has ways of interrupting and restarting this Execute method based on --iterations and --max-steps arguments provided to the test tool. So now you know what happened when you ran the following command line: coyote test ./bin/net5.0/HelloWorldActors.exe --iterations 30 A special coyote TestingEngine was created, it invoked the Execute method 30 times, and during those executions the test engine took over all concurrent activity and the non-determinism (like RandomInteger ) to ensure the program covered lots of async non-deterministic choices, and recorded all this in a way that when a bug was found, it is able to reproduce that bug. See also Using Coyote for information on how to replay a test that found a bug using coyote replay . Summary In this tutorial you learned: How to create an Actor and use SendEvent to send messages to it. How an Actor can handle events using OnEventDoAction . The importance of the inbox to simplify parallel programming. How to run the HelloWorldActors sample from the command-line. How to use Assert in Coyote code. How to write a [Test] method for use in coyote test runs. How to run that test using the coyote test tool.","title":"Hello world with actors"},{"location":"tutorials/actors/hello-world/#hello-world-example-with-actors","text":"HelloWorldActors is a simple program to get you started using the Coyote actors programming model .","title":"Hello world example with actors"},{"location":"tutorials/actors/hello-world/#what-you-will-need","text":"To run the Hello World Actors example, you will need to: Install Visual Studio 2019 . Install the .NET 5.0 version of the coyote tool . Clone the Coyote Samples git repo . Be familiar with the coyote tool. See using Coyote .","title":"What you will need"},{"location":"tutorials/actors/hello-world/#build-the-samples","text":"Build the coyote-samples repo by running the following command: powershell -f build.ps1","title":"Build the samples"},{"location":"tutorials/actors/hello-world/#run-the-helloworldactors-application","text":"Now you can run the HelloWorldActors application: \"./bin/net5.0/HelloWorldActors.exe\" Press the ENTER key to terminate the program when it is done. Note that a bug has been inserted into the code intentionally and will be caught by a Coyote Assert . The program should display 1 to 5 greetings like Hello World! or Good Morning . The intentional bug is hard to reproduce when you run the program manually. The typical \u201cnormal\u201d run will look like this: press ENTER to terminate... Requesting 5 greetings Received greeting: Good Morning Received greeting: Hello World! Received greeting: Hello World! Received greeting: Hello World! Received greeting: Good Morning When the error is caught, an extra line of output is written saying: Exception 'Microsoft.Coyote.AssertionFailureException' was thrown in 0 (action '1'): Too many greetings returned!","title":"Run the HelloWorldActors application"},{"location":"tutorials/actors/hello-world/#finding-the-bug-using-coyote-test-tool","text":"See Using Coyote for information on how to find the coyote test tool and setup your environment to use it. Enter the following from the command line: coyote test ./bin/net5.0/HelloWorldActors.dll --iterations 30 The result is: . Testing .\\bin\\net5.0\\HelloWorldActors.dll Starting TestingProcessScheduler in process 16432 ... Created '1' testing task. ... Task 0 is using 'random' strategy (seed:308255541). ..... Iteration #1 ..... Iteration #2 ... Task 0 found a bug. ... Emitting task 0 traces: ..... Writing .\\bin\\net5.0\\Output\\HelloWorldActors.exe\\CoyoteOutput\\HelloWorldActors_0_2.txt ..... Writing .\\bin\\net5.0\\Output\\HelloWorldActors.exe\\CoyoteOutput\\HelloWorldActors_0_2.schedule ... Elapsed 0.0906639 sec. ... Testing statistics: ..... Found 1 bug. ... Scheduling statistics: ..... Explored 2 schedules: 2 fair and 0 unfair. ..... Found 50.00% buggy schedules. ..... Number of scheduling points in fair terminating schedules: 23 (min), 30 (avg), 37 (max). ... Elapsed 0.1819877 sec. . Done The Coyote tester has found the bug very quickly\u2014something that takes much longer if testing manually. When using Coyote for testing more complex, real-world systems the time savings can be huge! This will give you the ability to find and fix even the most difficult to reproduce concurrency bugs before pushing to production . To learn more about testing with Coyote read here .","title":"Finding the bug using Coyote test tool"},{"location":"tutorials/actors/hello-world/#the-greeter","text":"Please read Programming model: asynchronous actors to gain a basic understanding of the Actors programming model. The core of an Actor based Coyote program, is, well, an Actor class! The following Actor named Greeter is able to receive a RequestGreetingEvent to which it responds with a GreetingEvent : [OnEventDoAction(typeof(RequestGreetingEvent), nameof(HandleGreeting))] public class Greeter : Actor { /// This method is called when this actor receives a RequestGreetingEvent. private void HandleGreeting(Event e) { if (e is RequestGreetingEvent ge) { string greeting = this.RandomBoolean() ? \"Hello World!\" : \"Good Morning\"; this.SendEvent(ge.Caller, new GreetingEvent(greeting)); if (this.RandomBoolean(10)) { // bug: a 1 in 10 chance of sending too many greetings. this.SendEvent(ge.Caller, new GreetingEvent(greeting)); } } } } Notice the OnEventDoAction custom attribute decorating the class. This tells the Coyote runtime that this class expects to receive RequestGreetingEvents . These events will be queued in the inbox for this Actor until the right time to dequeue them and process them. The custom attribute tells the Coyote runtime to call the HandleGreeting method. The Coyote runtime will also report an error if a different type of event is sent to the Greeter . The HandleGreeting method is called with an Event parameter, and you know in this case the event will be of type RequestGreetingEvent . This event is defined in Events.cs like this: internal class RequestGreetingEvent : Event { public readonly ActorId Caller; public RequestGreetingEvent(ActorId caller) { this.Caller = caller; } }","title":"The Greeter"},{"location":"tutorials/actors/hello-world/#the-inbox-is-crucial-to-the-actor-model","text":"You can think of an Event declaration as a type of interface definition for Actors . Events really define the interface of an Actor because the caller will never get to see the Greeter class, so the caller can\u2019t just call HandleGreeting directly. The caller only gets to see an ActorId , which is like a Coyote runtime handle to the actor. There is a really important reason for this . Events are queued in an inbox managed by the Actor base class. This serializes the incoming events so that at any given time, only one event is being handled in the Greeter . This greatly simplifies concurrent programming. For example, there is no need to use lock to protect against data race conditions, and therefore no need to worry about deadlocks. Each Actor instance can run in a separate thread, so all actors in the system can be hugely parallel, but at the same time the processing inside an Actor is incredibly simple. So you get the best of both worlds, code that scales but is also easy to write. An Actor receives messages, and can create other Actor objects, and can send events. Notice the Greeter gets an ActorId from the RequestGreetingEvent and uses that to send a greeting back to the caller using SendEvent : this.SendEvent(ge.Caller, new GreetingEvent(greeting)); You can also see the bug which has been injected deliberately, namely, it randomly returns more than one GreetingEvent .","title":"The inbox is crucial to the Actor model"},{"location":"tutorials/actors/hello-world/#a-testactor","text":"To test this Greeter you will need to setup a TestActor which is done in Program.cs . The TestActor creates the Greeter and sends between 1 and 5 RequestGreetingEvents . The TestActor is declared in a way that tells the Coyote runtime it is expecting to receive GreetingEvents as follows: [OnEventDoAction(typeof(GreetingEvent), nameof(HandleGreeting))] To make this a good test, the TestActor keeps track of how many greetings were sent and how many were received, and it writes an Assert to ensure it doesn\u2019t receive too many as follows: private void HandleGreeting(Event e) { // this is perfectly thread safe, because all message handling in actors is // serialized within the Actor class. this.Count--; string greeting = ((GreetingEvent)e).Greeting; Console.WriteLine(\"Received greeting: {0}\", greeting); this.Assert(this.Count >= 0, \"Too many greetings returned!\"); } Lastly, to test the TestActor you need to fire up the Coyote runtime which is done in the HostProgram Main entry point as follows: public static void Main() { var config = Configuration.Create(); IActorRuntime runtime = RuntimeFactory.Create(config); Execute(runtime); runtime.OnFailure += OnRuntimeFailure; Console.WriteLine(\"press ENTER to terminate...\"); Console.ReadLine(); } Notice that Coyote actors run in parallel, so you have to stop the program from terminating prematurely, which can be done with a Console.ReadLine call. In order for this program to also be testable using the coyote test tool, you need to declare a test method as follows: [Microsoft.Coyote.SystematicTesting.Test] public static void Execute(IActorRuntime runtime) { runtime.CreateActor(typeof(TestActor)); } The coyote test tool will call this method. But it will not call your Main entry point. So this Execute method needs to be standalone. It cannot depend on anything except statically initialized variables. There is no way to get command line arguments from coyote test through to this method. This Execute method is very simple, it just creates the TestActor . In Coyote once an actor is created it lives forever until it is halted. Note that Coyote programs can run forever, the coyote test tool has ways of interrupting and restarting this Execute method based on --iterations and --max-steps arguments provided to the test tool. So now you know what happened when you ran the following command line: coyote test ./bin/net5.0/HelloWorldActors.exe --iterations 30 A special coyote TestingEngine was created, it invoked the Execute method 30 times, and during those executions the test engine took over all concurrent activity and the non-determinism (like RandomInteger ) to ensure the program covered lots of async non-deterministic choices, and recorded all this in a way that when a bug was found, it is able to reproduce that bug. See also Using Coyote for information on how to replay a test that found a bug using coyote replay .","title":"A TestActor"},{"location":"tutorials/actors/hello-world/#summary","text":"In this tutorial you learned: How to create an Actor and use SendEvent to send messages to it. How an Actor can handle events using OnEventDoAction . The importance of the inbox to simplify parallel programming. How to run the HelloWorldActors sample from the command-line. How to use Assert in Coyote code. How to write a [Test] method for use in coyote test runs. How to run that test using the coyote test tool.","title":"Summary"},{"location":"tutorials/actors/raft-azure/","text":"Raft consensus protocol on Azure The CloudMessaging sample implements the Raft consensus algorithm as an Azure Service built on the Azure Service Bus . See animating state machine demo which shows the Coyote systematic testing process in action on this application. This example is organized into the following projects: Raft - a .NET Core C# class library that implements the Raft Consensus Algorithm using the Coyote Actor Programming Model . Raft.Azure - a C# executable that shows how to run Coyote messages through an Azure Service Bus . Raft.Mocking - demonstrates how to use mocks to systematically test the CloudMessaging sample application, in-memory on your local machine without using any Azure messaging, discussed in more detail in Raft actor service (mocked) tutorial. Raft.Nondeterminism - demonstrates how to introduce controlled nondeterminism in your Coyote tests to systematically exercise corner-cases. What you will need To run the Azure example, you will need an Azure subscription . You will also need to install the Azure Command-line tool . This tool is called the Azure CLI . You will also need to: Install Visual Studio 2019 . Install the .NET 5.0 version of the coyote tool . Clone the Coyote Samples git repo . Be familiar with the coyote tool. See using Coyote . Setup Azure Open a Developer Command Prompt for Visual Studio 2019. Run powershell -f setup.ps1 to create a new Azure Resource Group called CoyoteSamplesRG and an Azure Service Bus namespace called CoyoteSampleMessageBus . This script will provide the connection string you need so the sample can connect to the Azure Service Bus. Copy the command line from the output of setup.ps1 and paste it into your console window: set CONNECTION_STRING=... If you need to find this connection string again later you can get it from your Azure Portal , find the message bus resource you created above, click on Shared access policies and select the RootManageSharedAccessKey and wait for the keys to load, then copy the contents of the field named Primary Connection String . Build the samples Build the coyote-samples repo by running the following command: powershell -f build.ps1 Run the Raft.Azure application Now you can run the Raft.Azure application: \"./bin/net5.0/Raft.Azure.exe\" --connection-string \"%CONNECTION_STRING%\" --topic-name rafttopic --num-requests 5 --local-cluster-size 5 Note: you don\u2019t want to try and run Raft.Azure client using the coyote test tool until you complete the mocking of the Azure Message Bus calls. Design The Raft.dll library contains a Server state machine , and a ClusterManager state machine. It also contains an interface named IServerManager and some Coyote Event declarations which describe the message types that are sent between the Server instances and the Client. The ClusterManager is an abstract state machine that models the concept of being able to broadcast messages to all Servers registered in a cluster. Sending an event to this cluster will result in all Servers getting that same event. So, as the raft protocol requires, broadcasting VoteRequestEvents can be done by a Server using this SendEvent instruction: this.SendEvent(this.ClusterManager, new VoteRequestEvent(this.CurrentTerm, this.Manager.ServerId, lastLogIndex, lastLogTerm)); You will see similar calls sending VoteResponseEvent , AppendLogEntriesRequestEvent , AppendLogEntriesResponseEvent , and ClientResponseEvent via the ClusterManager . The second project builds Raft.Azure.dll and contains all the Azure specific code that hooks all this up to an Azure Service Bus . Notice it implements the IServerManager interface in a class named AzureServer and it subclasses the ClusterManager in a state machine named AzureClusterManager . This subclass achieves the required broadcast semantics by forwarding all events received to an Azure Service Bus pub/sub topic. It also has an AzureMessageReceiver class which subscribes to the Azure service bus topic, and forwards those events back into the local Coyote state machine using SendEvent . You can think of AzureClusterManager and AzureMessageReceiver as an example of how to \u201cbridge\u201d an external messaging platform with the Coyote runtime. In this way you can map Coyote Actors to any underlying messaging platform which is why Coyote does not force you to use any particular message platform. Initialization When you run the Raft.Azure.dll command line you will see some options: Option Description --connection-string your Azure Service Bus connection string --topic-name optional string for Service Bus Topic (default \u2018rafttopic\u2019) --num-servers number of servers to spawn As you can see here Raft.Azure.dll will launch each server in a separate process. The first process is the Client process, then each subsequent one is a Server instance according to the specified --local-cluster-size command line argument. The following diagram shows what this looks like when we have 2 servers in the cluster: The startup sequence for all this can be found in Program.cs and goes like this: Parse the command line for the client process and call RunAsync . RunAsync sets up the Azure Service Bus pub/sub topic using CreateTopicAsync , and creates a subscription to that topic using CreateSubscriptionAsync . Each process does this same thing so they can all talk to each other via the Azure Service Bus using the TopicClient . Create the Coyote IActorRuntime using RuntimeFactory.Create . The TopicClient is then wrapped by the first Coyote Actor called AzureClusterManager . Then depending which process is running it calls RunClient or RunServer . RunClient launches the server processes in StartRaftServers and special hidden command line arguments --server-id and --client-process-id tell those child processes to run in server mode. RunClient creates an AzureMessageReceiver , and sends a sequence of ClientRequestEvents , waiting for a response from the cluster for each request. RunServer creates the AzureServer object and an AzureMessageReceiver , telling the AzureMessageReceiver to run forever asynchronously. Each server terminates when the client terminates which is done by MonitorClientProcess . The AzureServer object creates a StateMachine of type Server . Note: MonitorClientProcess doesn\u2019t work when you run the project from Visual Studio debugger, in that case you may have to kill the spawned dotnet processes by hand. Processing The Server state machine is where the interesting code lives, it is a complete implementation of the Raft protocol. All the Server instances form a fault-tolerant server cluster, that can handle ClientRequestEvents in a reliable way. Server instances can failover, and the cluster protocol is able to figure out which server should handle which client request, and how to replicate the logs across all servers for safe keeping and reliability. The whole idea is that with this cluster there is no single point of failure. Clearly for this to be reliable, it must also be bug free, and therefore is an excellent candidate for thorough testing by the coyote test tool. The RunClient method shows how you can use the cluster , namely, sending a ClientRequestEvent and waiting for the async response that comes back from the service bus in the ClientResponseEvent . Sending a message to the cluster is done like this: runtime.SendEvent(clusterManager, new ClientRequestEvent(command)); Receiving a response is done using the ResponseReceived event on the AzureMessageReceiver . The client then uses a TaskCompletionSource to synchronize these two events so that it waits for a ClientResponseEvent before sending the next ClientRequestEvent . Each ClientRequestEvent goes to all server processes in the cluster via the Azure Service Bus. The servers then implement their Raft voting protocol to figure out which server will handle the request. The sample runs each Server on the same machine, just for simplicity, but in a real fault-tolerant system you would probably want to run each server on a different VM in the cloud and get a real distributed cluster going. You could use Kubernetes or some other system to manage that setup. The Azure Service Bus code would be the same in either case. The AzureServer code is a bit more complicated than you might expect, where it uses CreateActorIdFromName , then a Initialize method to create the Server state machines and a Start that sends a NotifyJoinedServiceEvent to kick things off. The reason for all this will become more apparent when you look at the mocked implementation . In the mocking case all Server state machines run in the same process and in that case the servers must not start until all server instances have been created. This is an example of how the issue of testability can sometimes affect how you do things in your production code. CreateActorIdFromName creates only the ActorId object and does not actually create the actor. This is handy when you need to give that ActorId to another Actor as part of an initialization process. Then at a later time when everything is ready we can create the actual actor using this predetermined id as follows: this.Runtime.CreateActor(id, typeof(Server), new Server.SetupServerEvent(this, this.ClusterManager)); Notice the Server when it is in the start state ( Init ), it defers all events using a special wild card: [DeferEvents(typeof(WildCardEvent))] Then only when NotifyJoinedServiceEvent arrives does it go to the Follower state where the raft protocol begins and any queued messages can be processed. This tutorial does not go into the gory details of the entire Server protocol implementation, but there is a great animation of how the Raft Protocol works on this website . Please check that out, as it will make the Server code easier to understand. This more detailed walkthrough of the protocol can also help make things even more clear. The overall Server state machine flow looks like this: In a nutshell, each Server instance can be in one of three states, Follower , Candidate or Leader . Each Server starts in the Follower state. If these followers don\u2019t hear from a leader in a small timeout period then they promote themselves to Candidate state where each candidate requests a vote from the other servers in the cluster using the VoteRequestEvent . The other servers figure out how to reply to those votes, either accepting or denying the request sending back a corresponding VoteResponseEvent . A Candidate then becomes a Leader if it gets affirmative votes from a majority of the Server nodes in the cluster. A Leader then appends a new entry to the distributed log by sending an AppendLogEntriesRequestEvent to the other servers in the cluster. A AppendLogEntriesResponseEvent is returned in response to that which includes a success indicator. Now there are more details to this, like what happens if two servers get a majority vote or if a AppendLogEntriesRequestEvent fails for some reason. The cluster does some clever book keeping using a type of version number called \u201cTerm\u201d where in some cases an elected Leader can be rolled back to Follower enabling a new election process to continue and so on. Note: a real application of this protocol could be deployed where you simply add new [DataMember] fields to each ClientRequestEvent . These serializable members will be automatically replicated across the Servers and you implement whatever server logic you need at the point in the Server state machine where new log entries are about to be committed, if the server logic succeeds the Coyote commit continues, otherwise it is rolled back. Summary In this tutorial you learned: How to hook Coyote Actors and StateMachines up to a real production ready messaging platform (like Azure Service Bus). What it looks like to implement a real production ready algorithm like Raft in a Coyote StateMachine . How the Coyote StateMachine declarations embedded in the code show that high level state machine design can be continually maintained in your code, and this way Coyote is ensuring design and implementation remain in sync over time. How to reserve an ActorId before creating an Actor using CreateActorIdFromName . How to great DGML diagram of production runs by registering the ActorRuntimeLogGraphBuilder . Now you need to be sure this Server protocol implementation is trustworthy, and for that you can move on to the next tutorial: Raft actor service (mocked) .","title":"Raft actor service (on Azure)"},{"location":"tutorials/actors/raft-azure/#raft-consensus-protocol-on-azure","text":"The CloudMessaging sample implements the Raft consensus algorithm as an Azure Service built on the Azure Service Bus . See animating state machine demo which shows the Coyote systematic testing process in action on this application. This example is organized into the following projects: Raft - a .NET Core C# class library that implements the Raft Consensus Algorithm using the Coyote Actor Programming Model . Raft.Azure - a C# executable that shows how to run Coyote messages through an Azure Service Bus . Raft.Mocking - demonstrates how to use mocks to systematically test the CloudMessaging sample application, in-memory on your local machine without using any Azure messaging, discussed in more detail in Raft actor service (mocked) tutorial. Raft.Nondeterminism - demonstrates how to introduce controlled nondeterminism in your Coyote tests to systematically exercise corner-cases.","title":"Raft consensus protocol on Azure"},{"location":"tutorials/actors/raft-azure/#what-you-will-need","text":"To run the Azure example, you will need an Azure subscription . You will also need to install the Azure Command-line tool . This tool is called the Azure CLI . You will also need to: Install Visual Studio 2019 . Install the .NET 5.0 version of the coyote tool . Clone the Coyote Samples git repo . Be familiar with the coyote tool. See using Coyote .","title":"What you will need"},{"location":"tutorials/actors/raft-azure/#setup-azure","text":"Open a Developer Command Prompt for Visual Studio 2019. Run powershell -f setup.ps1 to create a new Azure Resource Group called CoyoteSamplesRG and an Azure Service Bus namespace called CoyoteSampleMessageBus . This script will provide the connection string you need so the sample can connect to the Azure Service Bus. Copy the command line from the output of setup.ps1 and paste it into your console window: set CONNECTION_STRING=... If you need to find this connection string again later you can get it from your Azure Portal , find the message bus resource you created above, click on Shared access policies and select the RootManageSharedAccessKey and wait for the keys to load, then copy the contents of the field named Primary Connection String .","title":"Setup Azure"},{"location":"tutorials/actors/raft-azure/#build-the-samples","text":"Build the coyote-samples repo by running the following command: powershell -f build.ps1","title":"Build the samples"},{"location":"tutorials/actors/raft-azure/#run-the-raftazure-application","text":"Now you can run the Raft.Azure application: \"./bin/net5.0/Raft.Azure.exe\" --connection-string \"%CONNECTION_STRING%\" --topic-name rafttopic --num-requests 5 --local-cluster-size 5 Note: you don\u2019t want to try and run Raft.Azure client using the coyote test tool until you complete the mocking of the Azure Message Bus calls.","title":"Run the Raft.Azure application"},{"location":"tutorials/actors/raft-azure/#design","text":"The Raft.dll library contains a Server state machine , and a ClusterManager state machine. It also contains an interface named IServerManager and some Coyote Event declarations which describe the message types that are sent between the Server instances and the Client. The ClusterManager is an abstract state machine that models the concept of being able to broadcast messages to all Servers registered in a cluster. Sending an event to this cluster will result in all Servers getting that same event. So, as the raft protocol requires, broadcasting VoteRequestEvents can be done by a Server using this SendEvent instruction: this.SendEvent(this.ClusterManager, new VoteRequestEvent(this.CurrentTerm, this.Manager.ServerId, lastLogIndex, lastLogTerm)); You will see similar calls sending VoteResponseEvent , AppendLogEntriesRequestEvent , AppendLogEntriesResponseEvent , and ClientResponseEvent via the ClusterManager . The second project builds Raft.Azure.dll and contains all the Azure specific code that hooks all this up to an Azure Service Bus . Notice it implements the IServerManager interface in a class named AzureServer and it subclasses the ClusterManager in a state machine named AzureClusterManager . This subclass achieves the required broadcast semantics by forwarding all events received to an Azure Service Bus pub/sub topic. It also has an AzureMessageReceiver class which subscribes to the Azure service bus topic, and forwards those events back into the local Coyote state machine using SendEvent . You can think of AzureClusterManager and AzureMessageReceiver as an example of how to \u201cbridge\u201d an external messaging platform with the Coyote runtime. In this way you can map Coyote Actors to any underlying messaging platform which is why Coyote does not force you to use any particular message platform.","title":"Design"},{"location":"tutorials/actors/raft-azure/#initialization","text":"When you run the Raft.Azure.dll command line you will see some options: Option Description --connection-string your Azure Service Bus connection string --topic-name optional string for Service Bus Topic (default \u2018rafttopic\u2019) --num-servers number of servers to spawn As you can see here Raft.Azure.dll will launch each server in a separate process. The first process is the Client process, then each subsequent one is a Server instance according to the specified --local-cluster-size command line argument. The following diagram shows what this looks like when we have 2 servers in the cluster: The startup sequence for all this can be found in Program.cs and goes like this: Parse the command line for the client process and call RunAsync . RunAsync sets up the Azure Service Bus pub/sub topic using CreateTopicAsync , and creates a subscription to that topic using CreateSubscriptionAsync . Each process does this same thing so they can all talk to each other via the Azure Service Bus using the TopicClient . Create the Coyote IActorRuntime using RuntimeFactory.Create . The TopicClient is then wrapped by the first Coyote Actor called AzureClusterManager . Then depending which process is running it calls RunClient or RunServer . RunClient launches the server processes in StartRaftServers and special hidden command line arguments --server-id and --client-process-id tell those child processes to run in server mode. RunClient creates an AzureMessageReceiver , and sends a sequence of ClientRequestEvents , waiting for a response from the cluster for each request. RunServer creates the AzureServer object and an AzureMessageReceiver , telling the AzureMessageReceiver to run forever asynchronously. Each server terminates when the client terminates which is done by MonitorClientProcess . The AzureServer object creates a StateMachine of type Server . Note: MonitorClientProcess doesn\u2019t work when you run the project from Visual Studio debugger, in that case you may have to kill the spawned dotnet processes by hand.","title":"Initialization"},{"location":"tutorials/actors/raft-azure/#processing","text":"The Server state machine is where the interesting code lives, it is a complete implementation of the Raft protocol. All the Server instances form a fault-tolerant server cluster, that can handle ClientRequestEvents in a reliable way. Server instances can failover, and the cluster protocol is able to figure out which server should handle which client request, and how to replicate the logs across all servers for safe keeping and reliability. The whole idea is that with this cluster there is no single point of failure. Clearly for this to be reliable, it must also be bug free, and therefore is an excellent candidate for thorough testing by the coyote test tool. The RunClient method shows how you can use the cluster , namely, sending a ClientRequestEvent and waiting for the async response that comes back from the service bus in the ClientResponseEvent . Sending a message to the cluster is done like this: runtime.SendEvent(clusterManager, new ClientRequestEvent(command)); Receiving a response is done using the ResponseReceived event on the AzureMessageReceiver . The client then uses a TaskCompletionSource to synchronize these two events so that it waits for a ClientResponseEvent before sending the next ClientRequestEvent . Each ClientRequestEvent goes to all server processes in the cluster via the Azure Service Bus. The servers then implement their Raft voting protocol to figure out which server will handle the request. The sample runs each Server on the same machine, just for simplicity, but in a real fault-tolerant system you would probably want to run each server on a different VM in the cloud and get a real distributed cluster going. You could use Kubernetes or some other system to manage that setup. The Azure Service Bus code would be the same in either case. The AzureServer code is a bit more complicated than you might expect, where it uses CreateActorIdFromName , then a Initialize method to create the Server state machines and a Start that sends a NotifyJoinedServiceEvent to kick things off. The reason for all this will become more apparent when you look at the mocked implementation . In the mocking case all Server state machines run in the same process and in that case the servers must not start until all server instances have been created. This is an example of how the issue of testability can sometimes affect how you do things in your production code. CreateActorIdFromName creates only the ActorId object and does not actually create the actor. This is handy when you need to give that ActorId to another Actor as part of an initialization process. Then at a later time when everything is ready we can create the actual actor using this predetermined id as follows: this.Runtime.CreateActor(id, typeof(Server), new Server.SetupServerEvent(this, this.ClusterManager)); Notice the Server when it is in the start state ( Init ), it defers all events using a special wild card: [DeferEvents(typeof(WildCardEvent))] Then only when NotifyJoinedServiceEvent arrives does it go to the Follower state where the raft protocol begins and any queued messages can be processed. This tutorial does not go into the gory details of the entire Server protocol implementation, but there is a great animation of how the Raft Protocol works on this website . Please check that out, as it will make the Server code easier to understand. This more detailed walkthrough of the protocol can also help make things even more clear. The overall Server state machine flow looks like this: In a nutshell, each Server instance can be in one of three states, Follower , Candidate or Leader . Each Server starts in the Follower state. If these followers don\u2019t hear from a leader in a small timeout period then they promote themselves to Candidate state where each candidate requests a vote from the other servers in the cluster using the VoteRequestEvent . The other servers figure out how to reply to those votes, either accepting or denying the request sending back a corresponding VoteResponseEvent . A Candidate then becomes a Leader if it gets affirmative votes from a majority of the Server nodes in the cluster. A Leader then appends a new entry to the distributed log by sending an AppendLogEntriesRequestEvent to the other servers in the cluster. A AppendLogEntriesResponseEvent is returned in response to that which includes a success indicator. Now there are more details to this, like what happens if two servers get a majority vote or if a AppendLogEntriesRequestEvent fails for some reason. The cluster does some clever book keeping using a type of version number called \u201cTerm\u201d where in some cases an elected Leader can be rolled back to Follower enabling a new election process to continue and so on. Note: a real application of this protocol could be deployed where you simply add new [DataMember] fields to each ClientRequestEvent . These serializable members will be automatically replicated across the Servers and you implement whatever server logic you need at the point in the Server state machine where new log entries are about to be committed, if the server logic succeeds the Coyote commit continues, otherwise it is rolled back.","title":"Processing"},{"location":"tutorials/actors/raft-azure/#summary","text":"In this tutorial you learned: How to hook Coyote Actors and StateMachines up to a real production ready messaging platform (like Azure Service Bus). What it looks like to implement a real production ready algorithm like Raft in a Coyote StateMachine . How the Coyote StateMachine declarations embedded in the code show that high level state machine design can be continually maintained in your code, and this way Coyote is ensuring design and implementation remain in sync over time. How to reserve an ActorId before creating an Actor using CreateActorIdFromName . How to great DGML diagram of production runs by registering the ActorRuntimeLogGraphBuilder . Now you need to be sure this Server protocol implementation is trustworthy, and for that you can move on to the next tutorial: Raft actor service (mocked) .","title":"Summary"},{"location":"tutorials/actors/raft-mocking/","text":"Raft consensus protocol with mocks for testing In the previous example you created an Azure application that uses Coyote and performs messaging using Azure Service Bus . This is a great way to build a reliable application or service. But there is overhead in using an enterprise scale service bus, which limits our ability to fully test the state machine. Clearly a fault-tolerant server consensus protocol needs to be thoroughly tested, which is what you will do in this tutorial. First you will mock the Azure Service Bus which allows the Coyote tester to perform thousands of tests per second and thereby find bugs in the application code more efficiently. Then you will use the coyote test tool to explore the code using different test strategies until you achieve a high level of confidence that the code is rock solid. What you will need You will also need to: Install Visual Studio 2019 . Install the .NET 5.0 version of the coyote tool . Clone the Coyote Samples git repo . Be familiar with the coyote tool. See using Coyote . Build the samples Build the coyote-samples repo by running the following command: powershell -f build.ps1 Run the Raft.Mocking application Now you can run coyote test tool on the Raft.Mocking application: coyote test ./bin/net5.0/Raft.Mocking.dll -i 1000 -ms 200 --coverage activity You should see the test succeed with output like this, including a coverage report and graph: . Testing ./bin/net5.0/Raft.Mocking.dll Starting TestingProcessScheduler in process 34068 ... Created '1' testing task. ... Task 0 is using 'random' strategy (seed:1388735316). ..... Iteration #1 ..... Iteration #2 ..... Iteration #3 ..... ..... Iteration #900 ..... Iteration #1000 ... Emitting coverage reports: ..... Writing .\\bin\\net5.0\\Output\\Raft.Mocking.dll\\CoyoteOutput\\Raft.Mocking.dgml ..... Writing .\\bin\\net5.0\\Output\\Raft.Mocking.dll\\CoyoteOutput\\Raft.Mocking.coverage.txt ..... Writing .\\bin\\net5.0\\Output\\Raft.Mocking.dll\\CoyoteOutput\\Raft.Mocking.sci ... Testing statistics: ..... Found 0 bugs. ... Scheduling statistics: ..... Explored 1000 schedules: 0 fair and 1000 unfair. ..... Hit the max-steps bound of '200' in 100.00% of the unfair schedules. ... Elapsed 61.3283634 sec. . Done Now you are seeing a longer more realistic test run. But if you create a --verbose log you will see that in these 61 seconds the test actually tested over 2.4 million async operations!! In this case you should see Total event coverage: 100.0% which is a great sign, this means every possible event has been sent and received by every state of every state machine that you tested here. This is not the same thing as 100% code coverage, but it is a higher level of abstraction on coverage. Both are important. The coverage report has a separate section for each Actor or StateMachine that was covered by the test. It then lists the overall event coverage as a percentage, then lists the details of each State . For actors there will be only one state listed, matching the name of the Actor type. For example, the Server section reports the Candidate state like this: State: Candidate State event coverage: 100.0% Events received: Microsoft.Coyote.Actors.Timers.TimerElapsedEvent, AppendLogEntriesRequestEvent, AppendLogEntriesResponseEvent, VoteRequestEvent, VoteResponseEvent Events sent: AppendLogEntriesResponseEvent, VoteRequestEvent, VoteResponseEvent Previous states: Candidate, Follower Next states: Candidate, Follower, Leader This shows 100% coverage for the state, meaning all expected events have been received, it lists those under Events received , and it also lists all Events sent while in this state. Lastly it shows all recorded state transitions in and out of this state. Previous states are the states that transitions to the Candidate state and Next states are the states that the Candidate state went to using RaiseGotoStateEVent transitions. The key thing to look for here is that during this test run some of the Server state machines did make it to the Leader state. Notice because of the mocking of Azure API\u2019s this application is now able to run 200 steps per iteration and a thousand iterations pretty quickly, much faster than if all those messages were going to Azure and back. This means the test can quickly explore every kind of asynchronous timing of events to find all the bugs. Not only is it faster but it is also systematic in how it explores every possible interleaving of asynchronous operations. This systematic approach ensures the test doesn\u2019t just test the same happy paths over and over (like a stress test does) but instead it is more likely to find one bad path where a bug is hiding. The --coverage report also generates a DGML diagram of all the messages sent during the test. You can browse these graphs using Visual Studio. The file name in this case is Raft.Mocking.dgml and it will look something like this: Here you see all the Actor objects in green, and Monitor in blue and StateMachine and ExternalCode objects in gray. You can see that all the states were explored in the Server , including the Leader state. The MockStateMachineTimer is a helper Actor provided as a mock implementation CreateTimer and CreatePeriodicTimer API\u2019s. There are many different coyote test command line options you can play with to test different things and really increase your confidence level in the code you are testing. For example there are 4 different test scheduling options you can play with: Option Description --sch-random Choose the random scheduling strategy (this is the default) --sch-pct uint Choose the PCT scheduling strategy with given maximum number of priority switch points --sch-fairpct uint Choose the fair PCT scheduling strategy with given maximum number of priority switch points --sch-portfolio Choose the portfolio scheduling strategy in combination with parallel testing These options change how coyote test explores the large state space of possible schedules for your async operations. The last option is interesting because it allows you to test many different scheduling strategies at once, this is used in combination with the --parallel test option, so the following, for example, would run 5 parallel test processes using different scheduling strategies: coyote test ./bin/net5.0/Raft.Mocking.dll -i 1000 -ms 200 --coverage activity --sch-portfolio --parallel 5 When you use this the test will print the chosen strategies at the top of the test output: ... Task 3 is using 'FairPCT' strategy (seed:3922897588). ... Task 4 is using 'ProbabilisticRandom' strategy (seed:3469760925). ... Task 2 is using 'ProbabilisticRandom' strategy (seed:1642014516). ... Task 1 is using 'FairPCT' strategy (seed:1466235705). ... Task 0 is using 'Random' strategy (seed:3931672516). You can also increase the number of iterations to 10,000,000 if you want to, then come back tomorrow and see how it did. Clearly, you should now see that Coyote makes it possible to thoroughly test your code automatically, without you having to write a million individual boring unit tests that test every little possibility in terms of sending and receiving messages. Manual unit testing has a place in software engineering, but what Coyote does is more powerful. With Coyote you can explore a very large number of combinations and find lots of bugs which greatly increases confidence in your code. One interesting thing about Coyote is that every time you run a test you might explore a slightly different space and so continuous integration testing where you run tests on every checkin, or longer test suites every night, has a higher chance of finding that one ridiculously embarrassing bug before you go live with your service. You might wonder, if there is randomness in the testing, how will you reproduce bugs that are found? The answer lies in the random seed printed above (seed:3469760925) . This is all you need to re-run an identical test, so interesting random seeds can also become your regression test suite. Imagine, an entire interesting regression test is simply one integer. There is one restriction to this, if the product code you are testing changes the set of non-deterministic choices, then prior saved random seeds are no longer usable, but you can quickly build a new set by simply running more tests. Comparing this with the cost of maintaining large static regression test suite code bases, this is quite an improvement. Instead of building lots of little manual unit tests, you will find that when using Coyote your time is better spent designing interesting mocks that accurately model all the kinds of weird things that can happen when interacting with external systems. You also should write lots of interesting specifications throughout these mocks that use Assert to ensure everything is running properly during the test. You also should use the Monitor pattern to ensure all the global invariants you care about in your system remain true no matter what a specific test run is doing. Design The following diagram illustrates how the MockClient actor sends ClientRequestEvents , and how the MockClusterManager subclasses from ClusterManager . There is also a MockServerHost that implements the IServerManager interface and a RaftTestScenario class which sets everything up. Notice that the Server code you are testing here is the exact same production ready code you used in the Raft actor service (on Azure) tutorial. You should now see that this is very cool . You have switched the Server from running on Azure to running locally with a bunch of mocks and didn\u2019t have to change one line of Server code. For this test we also inject a SafetyMonitor into the process by simply registering it on the runtime like this: runtime.RegisterMonitor<SafetyMonitor>(); This enables the monitor so that when the MockServerHost sends the NotifyLeaderElected it can keep track and make sure there is only one leader per term. The MockClusterManager implementation is very simple, since at test time all Server instances are in the same process, a broadcast operation is simply a for-loop over those servers, sending the broadcast event to each one using SendEvent . The MockServerHost is a bit tricky, since all the Server actors have to be created before you start them using the NotifyJoinedServiceEvent otherwise the MockClusterManager might be too quick and start sending events to a Server instance before it is ready. Now you can see why the IServerManager interface was designed this way in the original Raft.Azure example. The RaftTestScenario then creates all the actors needed to run the test including all the mock actors and the real Server instances. This is all relatively simple compared to the original Raft.Azure example that was also dealing with setting up the Azure Service Bus. This mock test setup is able to fully test the Server implementation and get good coverage. The IServerManager interface and the abstract ClusterManager state machine where originally designed with testability in mind and that\u2019s what makes this easy mocking of the external pieces possible. The test also includes a coyote Monitor called SafetyMonitor which provides a global invariant check, namely checking there is never more than one Server that is elected to be the Leader at the same time. The Monitor class in Coyote shows how to inject additional work that you want to do at test time only, and have almost no overhead in the production code. Hopefully you agree it is pretty easy to create a monitor and that monitoring like this is a powerful concept that adds a lot of value to your Coyote testing process. Summary In this tutorial you learned: How to mock external systems like Azure Service Bus to make a Coyote test run fast. How to use the coyote test command line to explore different test strategies. How to read a Coyote coverage report and view the coverage graph. How to inject test logic like the SafetyMonitor in to the coyote test scenario that monitors the overall correctness of your system in a way that has minimal overhead in your production code. How to think about model based testing using random seeds and integrate that into your continuous integration testing process. You can also explore the Raft.Nondeterminism.dll version of this sample that injects a bug in the system by randomly sending duplicate VoteRequestEvents . Then you can see how the coyote test tool is able to spot the resulting bugs because of the SafetyMonitor .","title":"Raft actor service (mocked)"},{"location":"tutorials/actors/raft-mocking/#raft-consensus-protocol-with-mocks-for-testing","text":"In the previous example you created an Azure application that uses Coyote and performs messaging using Azure Service Bus . This is a great way to build a reliable application or service. But there is overhead in using an enterprise scale service bus, which limits our ability to fully test the state machine. Clearly a fault-tolerant server consensus protocol needs to be thoroughly tested, which is what you will do in this tutorial. First you will mock the Azure Service Bus which allows the Coyote tester to perform thousands of tests per second and thereby find bugs in the application code more efficiently. Then you will use the coyote test tool to explore the code using different test strategies until you achieve a high level of confidence that the code is rock solid.","title":"Raft consensus protocol with mocks for testing"},{"location":"tutorials/actors/raft-mocking/#what-you-will-need","text":"You will also need to: Install Visual Studio 2019 . Install the .NET 5.0 version of the coyote tool . Clone the Coyote Samples git repo . Be familiar with the coyote tool. See using Coyote .","title":"What you will need"},{"location":"tutorials/actors/raft-mocking/#build-the-samples","text":"Build the coyote-samples repo by running the following command: powershell -f build.ps1","title":"Build the samples"},{"location":"tutorials/actors/raft-mocking/#run-the-raftmocking-application","text":"Now you can run coyote test tool on the Raft.Mocking application: coyote test ./bin/net5.0/Raft.Mocking.dll -i 1000 -ms 200 --coverage activity You should see the test succeed with output like this, including a coverage report and graph: . Testing ./bin/net5.0/Raft.Mocking.dll Starting TestingProcessScheduler in process 34068 ... Created '1' testing task. ... Task 0 is using 'random' strategy (seed:1388735316). ..... Iteration #1 ..... Iteration #2 ..... Iteration #3 ..... ..... Iteration #900 ..... Iteration #1000 ... Emitting coverage reports: ..... Writing .\\bin\\net5.0\\Output\\Raft.Mocking.dll\\CoyoteOutput\\Raft.Mocking.dgml ..... Writing .\\bin\\net5.0\\Output\\Raft.Mocking.dll\\CoyoteOutput\\Raft.Mocking.coverage.txt ..... Writing .\\bin\\net5.0\\Output\\Raft.Mocking.dll\\CoyoteOutput\\Raft.Mocking.sci ... Testing statistics: ..... Found 0 bugs. ... Scheduling statistics: ..... Explored 1000 schedules: 0 fair and 1000 unfair. ..... Hit the max-steps bound of '200' in 100.00% of the unfair schedules. ... Elapsed 61.3283634 sec. . Done Now you are seeing a longer more realistic test run. But if you create a --verbose log you will see that in these 61 seconds the test actually tested over 2.4 million async operations!! In this case you should see Total event coverage: 100.0% which is a great sign, this means every possible event has been sent and received by every state of every state machine that you tested here. This is not the same thing as 100% code coverage, but it is a higher level of abstraction on coverage. Both are important. The coverage report has a separate section for each Actor or StateMachine that was covered by the test. It then lists the overall event coverage as a percentage, then lists the details of each State . For actors there will be only one state listed, matching the name of the Actor type. For example, the Server section reports the Candidate state like this: State: Candidate State event coverage: 100.0% Events received: Microsoft.Coyote.Actors.Timers.TimerElapsedEvent, AppendLogEntriesRequestEvent, AppendLogEntriesResponseEvent, VoteRequestEvent, VoteResponseEvent Events sent: AppendLogEntriesResponseEvent, VoteRequestEvent, VoteResponseEvent Previous states: Candidate, Follower Next states: Candidate, Follower, Leader This shows 100% coverage for the state, meaning all expected events have been received, it lists those under Events received , and it also lists all Events sent while in this state. Lastly it shows all recorded state transitions in and out of this state. Previous states are the states that transitions to the Candidate state and Next states are the states that the Candidate state went to using RaiseGotoStateEVent transitions. The key thing to look for here is that during this test run some of the Server state machines did make it to the Leader state. Notice because of the mocking of Azure API\u2019s this application is now able to run 200 steps per iteration and a thousand iterations pretty quickly, much faster than if all those messages were going to Azure and back. This means the test can quickly explore every kind of asynchronous timing of events to find all the bugs. Not only is it faster but it is also systematic in how it explores every possible interleaving of asynchronous operations. This systematic approach ensures the test doesn\u2019t just test the same happy paths over and over (like a stress test does) but instead it is more likely to find one bad path where a bug is hiding. The --coverage report also generates a DGML diagram of all the messages sent during the test. You can browse these graphs using Visual Studio. The file name in this case is Raft.Mocking.dgml and it will look something like this: Here you see all the Actor objects in green, and Monitor in blue and StateMachine and ExternalCode objects in gray. You can see that all the states were explored in the Server , including the Leader state. The MockStateMachineTimer is a helper Actor provided as a mock implementation CreateTimer and CreatePeriodicTimer API\u2019s. There are many different coyote test command line options you can play with to test different things and really increase your confidence level in the code you are testing. For example there are 4 different test scheduling options you can play with: Option Description --sch-random Choose the random scheduling strategy (this is the default) --sch-pct uint Choose the PCT scheduling strategy with given maximum number of priority switch points --sch-fairpct uint Choose the fair PCT scheduling strategy with given maximum number of priority switch points --sch-portfolio Choose the portfolio scheduling strategy in combination with parallel testing These options change how coyote test explores the large state space of possible schedules for your async operations. The last option is interesting because it allows you to test many different scheduling strategies at once, this is used in combination with the --parallel test option, so the following, for example, would run 5 parallel test processes using different scheduling strategies: coyote test ./bin/net5.0/Raft.Mocking.dll -i 1000 -ms 200 --coverage activity --sch-portfolio --parallel 5 When you use this the test will print the chosen strategies at the top of the test output: ... Task 3 is using 'FairPCT' strategy (seed:3922897588). ... Task 4 is using 'ProbabilisticRandom' strategy (seed:3469760925). ... Task 2 is using 'ProbabilisticRandom' strategy (seed:1642014516). ... Task 1 is using 'FairPCT' strategy (seed:1466235705). ... Task 0 is using 'Random' strategy (seed:3931672516). You can also increase the number of iterations to 10,000,000 if you want to, then come back tomorrow and see how it did. Clearly, you should now see that Coyote makes it possible to thoroughly test your code automatically, without you having to write a million individual boring unit tests that test every little possibility in terms of sending and receiving messages. Manual unit testing has a place in software engineering, but what Coyote does is more powerful. With Coyote you can explore a very large number of combinations and find lots of bugs which greatly increases confidence in your code. One interesting thing about Coyote is that every time you run a test you might explore a slightly different space and so continuous integration testing where you run tests on every checkin, or longer test suites every night, has a higher chance of finding that one ridiculously embarrassing bug before you go live with your service. You might wonder, if there is randomness in the testing, how will you reproduce bugs that are found? The answer lies in the random seed printed above (seed:3469760925) . This is all you need to re-run an identical test, so interesting random seeds can also become your regression test suite. Imagine, an entire interesting regression test is simply one integer. There is one restriction to this, if the product code you are testing changes the set of non-deterministic choices, then prior saved random seeds are no longer usable, but you can quickly build a new set by simply running more tests. Comparing this with the cost of maintaining large static regression test suite code bases, this is quite an improvement. Instead of building lots of little manual unit tests, you will find that when using Coyote your time is better spent designing interesting mocks that accurately model all the kinds of weird things that can happen when interacting with external systems. You also should write lots of interesting specifications throughout these mocks that use Assert to ensure everything is running properly during the test. You also should use the Monitor pattern to ensure all the global invariants you care about in your system remain true no matter what a specific test run is doing.","title":"Run the Raft.Mocking application"},{"location":"tutorials/actors/raft-mocking/#design","text":"The following diagram illustrates how the MockClient actor sends ClientRequestEvents , and how the MockClusterManager subclasses from ClusterManager . There is also a MockServerHost that implements the IServerManager interface and a RaftTestScenario class which sets everything up. Notice that the Server code you are testing here is the exact same production ready code you used in the Raft actor service (on Azure) tutorial. You should now see that this is very cool . You have switched the Server from running on Azure to running locally with a bunch of mocks and didn\u2019t have to change one line of Server code. For this test we also inject a SafetyMonitor into the process by simply registering it on the runtime like this: runtime.RegisterMonitor<SafetyMonitor>(); This enables the monitor so that when the MockServerHost sends the NotifyLeaderElected it can keep track and make sure there is only one leader per term. The MockClusterManager implementation is very simple, since at test time all Server instances are in the same process, a broadcast operation is simply a for-loop over those servers, sending the broadcast event to each one using SendEvent . The MockServerHost is a bit tricky, since all the Server actors have to be created before you start them using the NotifyJoinedServiceEvent otherwise the MockClusterManager might be too quick and start sending events to a Server instance before it is ready. Now you can see why the IServerManager interface was designed this way in the original Raft.Azure example. The RaftTestScenario then creates all the actors needed to run the test including all the mock actors and the real Server instances. This is all relatively simple compared to the original Raft.Azure example that was also dealing with setting up the Azure Service Bus. This mock test setup is able to fully test the Server implementation and get good coverage. The IServerManager interface and the abstract ClusterManager state machine where originally designed with testability in mind and that\u2019s what makes this easy mocking of the external pieces possible. The test also includes a coyote Monitor called SafetyMonitor which provides a global invariant check, namely checking there is never more than one Server that is elected to be the Leader at the same time. The Monitor class in Coyote shows how to inject additional work that you want to do at test time only, and have almost no overhead in the production code. Hopefully you agree it is pretty easy to create a monitor and that monitoring like this is a powerful concept that adds a lot of value to your Coyote testing process.","title":"Design"},{"location":"tutorials/actors/raft-mocking/#summary","text":"In this tutorial you learned: How to mock external systems like Azure Service Bus to make a Coyote test run fast. How to use the coyote test command line to explore different test strategies. How to read a Coyote coverage report and view the coverage graph. How to inject test logic like the SafetyMonitor in to the coyote test scenario that monitors the overall correctness of your system in a way that has minimal overhead in your production code. How to think about model based testing using random seeds and integrate that into your continuous integration testing process. You can also explore the Raft.Nondeterminism.dll version of this sample that injects a bug in the system by randomly sending duplicate VoteRequestEvents . Then you can see how the coyote test tool is able to spot the resulting bugs because of the SafetyMonitor .","title":"Summary"},{"location":"tutorials/actors/test-failover/","text":"Test failover and liveness in Coyote actors Wikipedia provides this definition : \u201c Failover is switching to a redundant or standby computer server, system, hardware component or network upon the failure or abnormal termination of the previously active application, server, system, hardware component, or network. Systems designers usually provide failover capability in servers, systems or networks requiring near-continuous availability and a high degree of reliability.\u201d This sample applies the failover concept to the firmware of an automated espresso machine using the Coyote asynchronous actors programming model. Imagine what would happen if the tiny CPU running the machine rebooted in the middle of making a coffee. What bad things might happen? Can we design a state machine that can handle this scenario and provide a more fault tolerant coffee machine? An identical version of this tutorial is available that uses regular C# tasks . The following diagram shows how Coyote can be used to test this scenario and help you design more reliable software. The CoffeeMachine is modeled as an asynchronous state machine . This example is not providing real firmware, instead it mocks the hardware sensor platform built into the machine. This is done in MockSensors.cs where you will find three actors that model various hardware components: MockDoorSensor , MockWaterTank and MockCoffeeGrinder . This actor provides async ways of reading sensor values like Water temperature and water levels, or turning on and off the coffee grinder and so on. The CoffeeMachine does not know the sensors are mocks, all it knows is the public interface defined in SensorEvents.cs . In this way the CoffeeMachine is production code, while the mocks are only for testing. The reason we are using an asynchronous model is that even in the smallest of devices, often times there is a message passing architecture where different hardware components are connected via some sort of bus, whether it is a simple serial port, or something more sophisticated like a CAN bus . We will test that we can kill the CoffeeMachine and restart it without anything bad happening. This test is setup by the FailoverDriver . The FailoverDriver lets the first CoffeeMachine instance run for a bit then it randomly kills it by using the HaltEvent , then it starts a new CoffeeMachine . The new CoffeeMachine instance needs to figure out the state of the sensors such that when a MakeCoffeeEvent arrives, it doesn\u2019t do something silly that breaks the machine. The mock sensors are not killed so that it acts as a persistent store for sensor state across all instances of the CoffeeMachine . Some safety Asserts are placed in the code that verify certain important things, including: - do not turn on heater if there is no water - do not turn on grinder if there are no beans in the hopper - do not turn on shot maker if there is no water - do not do anything if the door is open There is also a correctness assert in the CoffeeMachine to make sure the correct number of espresso shots are made and there is a LivenessMonitor that monitors the CoffeeMachine to make sure it never gets stuck, i.e., it always finishes the job it was given or it goes to an error state if the machine needs to be fixed. See Liveness Checking . A number of excellent bugs were found by Coyote during the development of this sample, and this illustrates the fact that Coyote can be applied to any type of asynchronous software, not just cloud services. There is still one bug remaining in the code which you can find using coyote test , and it happens after failover just to prove the usefulness of this testing methodology. What you will need To run the CoffeeMachine example, you will need to: Install Visual Studio 2019 . Install the .NET 5.0 version of the coyote tool . Clone the Coyote Samples git repo . Be familiar with the coyote tool. See using Coyote . Build the samples Build the coyote-samples repo by running the following command: powershell -f build.ps1 Run the failover coffee machine application Now you can run the CoffeeMachine application: \"./bin/net5.0/CoffeeMachineActors.exe\" The coffee machine There are many different types of coffee machines. This example is based on the following machine which can automatically heat water, grind beans, and make an espresso shot all with the press of a button: The following diagram shows the states and actions in our example implementation in the CoffeeMachine class: When you run the executable without using coyote test (this is called running in production mode ), you will see the following console output. Notice in the output below that the FailoverDriver forces the termination of the CoffeeMachine right in the middle of making a coffee. Then when the CoffeeMachine is restarted, the FailoverDriver requests another coffee and the CoffeeMachine is able to continue on, the water is already warm, and it dumps the old grinds so you have the freshest possible coffee each time. <FailoverDriver> starting new CoffeeMachine. <CoffeeMachine> initializing... <CoffeeMachine> checking initial state of sensors... <CoffeeMachine> Water level is 60 % <CoffeeMachine> Hopper level is 93 % <CoffeeMachine> Warming the water to 100 degrees <CoffeeMachine> Turning on the water heater <CoffeeMachine> Coffee machine is warming up (64 degrees)... <CoffeeMachine> Coffee machine is warming up (74 degrees)... <CoffeeMachine> Coffee machine is warming up (84 degrees)... <CoffeeMachine> Coffee machine is warming up (94 degrees)... <CoffeeMachine> Coffee machine water temperature is now 100 <CoffeeMachine> Turning off the water heater <CoffeeMachine> Coffee machine is ready to make coffee (green light is on) <CoffeeMachine> Coffee requested, shots=1 <CoffeeMachine> Grinding beans... <CoffeeMachine> PortaFilter is 10 % full <CoffeeMachine> PortaFilter is 20 % full <CoffeeMachine> PortaFilter is 30 % full <CoffeeMachine> PortaFilter is 40 % full <CoffeeMachine> PortaFilter is 50 % full <CoffeeMachine> PortaFilter is 60 % full <CoffeeMachine> PortaFilter is 70 % full <CoffeeMachine> PortaFilter is 80 % full <CoffeeMachine> PortaFilter is 90 % full <CoffeeMachine> PortaFilter is full <CoffeeMachine> Making shots... <FailoverDriver> forcing termination of CoffeeMachine. <CoffeeMachine> Coffee Machine Terminating... <CoffeeMachine> ################################################################# <CoffeeMachine> # Coffee Machine Halted # <CoffeeMachine> ################################################################# <FailoverDriver> starting new CoffeeMachine. <CoffeeMachine> initializing... <CoffeeMachine> checking initial state of sensors... <CoffeeMachine> Water level is 60 % <CoffeeMachine> Hopper level is 83 % <CoffeeMachine> Dumping old smelly grinds! <CoffeeMachine> Warming the water to 100 degrees <CoffeeMachine> Coffee machine water temperature is now 100 <CoffeeMachine> Coffee machine is ready to make coffee (green light is on) <CoffeeMachine> Coffee requested, shots=2 <CoffeeMachine> Grinding beans... <CoffeeMachine> PortaFilter is 10 % full <CoffeeMachine> PortaFilter is 20 % full <CoffeeMachine> PortaFilter is 30 % full <CoffeeMachine> PortaFilter is 40 % full <CoffeeMachine> PortaFilter is 50 % full <CoffeeMachine> PortaFilter is 60 % full <CoffeeMachine> PortaFilter is 70 % full <CoffeeMachine> PortaFilter is 80 % full <CoffeeMachine> PortaFilter is 90 % full <CoffeeMachine> PortaFilter is full <CoffeeMachine> Making shots... <CoffeeMachine> Shot count is 1 <CoffeeMachine> 2 shots completed and 2 shots requested! <CoffeeMachine> Dumping the grinds! <CoffeeMachine> Coffee machine is ready to make coffee (green light is on) <FailoverDriver> CoffeeMachine completed the job. ... The test will continue on making coffee until it runs out of either water or coffee beans and the FailoverDriver halts each CoffeeMachine instance at random times until the machine is out of resources, at which point the test is complete. The mock sensors also randomly choose some error conditions, so instead of the above you may see some errors like: <CoffeeMachine> Cannot safely operate coffee machine with the door open! <CoffeeMachine> Coffee machine needs manual refilling of water and/or coffee beans! If you see these errors, press ENTER to terminate the program and run it again. These random start conditions help the test cover more cases. Each halted machine is terminated and discarded, then a new CoffeeMachine instance is started that must figure out what is happening with the sensors and make the next coffee without incident. Eventually a CoffeeMachine will report there is no more water or coffee beans and then it will stop with an error message saying the machine needs to be manually refilled. Coyote testing You can now use coyote test to exercise the code and see if any bugs can be found. From the coyote-samples folder: coyote test ./bin/net5.0/CoffeeMachineActors.dll -i 100 -ms 2000 --sch-pct 10 --graph-bug Chances are this will find a bug quickly, one of the safety assertions will fire and you will see that a test output log and DGML diagram are produced, like this: .\\bin\\net5.0\\Output\\CoffeeMachineActors.exe\\CoyoteOutput\\CoffeeMachine_0_0.txt .\\bin\\net5.0\\Output\\CoffeeMachineActors.exe\\CoyoteOutput\\CoffeeMachine_0_0.dgml This log can be pretty big, a couple thousand lines where each line represents one async operation. This log contains only the one iteration that failed, and towards the end you will see something like this: <ActionLog> Microsoft.Coyote.Samples.CoffeeMachineActors.MockCoffeeGrinder(3) invoked action 'OnGrinderButton'. <ErrorLog> Please do not turn on grinder if there are no beans in the hopper So the CoffeeMachine accidentally tried to grind beans when the hopper was empty. If you look at the resulting DGML diagram you will see exactly what happened: The Timer machines were removed from this diagram just for simplicity. The FailoverDriver started the first CoffeeMachine on the left which ran to completion but it ran low on coffee beans. Then this first machine was halted. The FailoverDriver then started a new CoffeeMachine , which made it all the way to GrindingBeans where it tripped the safety assertion in MockCoffeeGrinder . So the bug here is that somehow, the second CoffeeMachine instance missed the fact that it was low on coffee beans. A bug exists in the code somewhere. Can you find it? It is not a trivial bug because the CheckSensors state is clearly checking the coffee level by sending the ReadHopperLevelEvent to the MockCoffeeGrinder actor and CheckInitialState does not advance to the HeatingWater state until this reading is returned. So what happened? Hint: if you search backwards in the output log you will find the following situation reported in CheckState : <CoffeeMachine> Hopper level is -5 % The first CoffeeMachine instance left the grinder running a bit too long, and the sensor got confused thinking the coffee level is negative. The new CoffeeMachine instance never thought about this situation and checked only: if ((int)this.HopperLevel.Value == 0) ... And so it missed the fact it might be negative. The fix is easy, just change this condition to <= and the bug goes away. The fact that such a bug was found shows the usefulness of the failover testing strategy. Testing the scheduling of highly asynchronous operations This raises a bigger design question, how did the coffee level become negative? In firmware it is common to poll sensor readings and do something based on that. In this case we are polling a PortaFilterCoffeeLevelEvent in a tight loop while in the GrindingBeans state. Meanwhile the MockCoffeeGrinder class has a timer running and when HandleTimer calls MonitorGrinder it decreases the coffee level by 10 percent during every time interval. So we have an asynchronous operation going on here. Coffee level is decreasing based on a timer, and the CoffeeMachine is monitoring that coffee level using async events. This all seems to work perfectly in the production code where we see this output: <CoffeeMachine> Grinding beans... <CoffeeMachine> PortaFilter is 10 % full <CoffeeMachine> PortaFilter is 20 % full <CoffeeMachine> PortaFilter is 30 % full <CoffeeMachine> PortaFilter is 40 % full <CoffeeMachine> PortaFilter is 50 % full <CoffeeMachine> PortaFilter is 60 % full <CoffeeMachine> PortaFilter is 70 % full <CoffeeMachine> PortaFilter is 80 % full <CoffeeMachine> PortaFilter is 90 % full <CoffeeMachine> PortaFilter is full And the reason it works is because your Operating System is scheduling both of these async threads in a way that is relatively fair meaning one does not run for a long time without the other being scheduled also. But what if these two systems were running in a distributed world and one of them hangs for a long time? This is the kind of thread scheduling that coyote test is testing where one machine can run way ahead of another. You need to take this into account when using this kind of timer based async events . One way to improve the design in a firmware based system like a coffee machine is to switch from a polling based system to an interrupt based system where the MockCoffeeGrinder can send important events to the CoffeeMachine . This style of interrupt based eventing is used to model the ShotCompleteEvent , WaterHotEvent , WaterEmptyEvent and HopperEmptyEvent . This shows how Coyote can help find actual design flaws in your code so you can design a system that is more robust in the face of unexpected faults. The coyote test engine provides several different scheduling strategies that test different kinds of fairness algorithms. These are designed to find different kinds of bugs. The following command line shows how to use --sch-portfolio and the --parallel options to test a bunch of different strategies in parallel, each in different test processes: coyote test ./bin/net5.0/CoffeeMachineActors.dll -i 100 -ms 2000 --sch-pct 10 --graph-bug --sch-portfolio --parallel 8 which outputs the following: . Testing .\\bin\\net5.0\\CoffeeMachineActors.dll Starting TestingProcessScheduler in process 42036 ... Created '8' testing tasks. ... Task 3 is using 'FairPCT' strategy (seed:2143). ... Task 5 is using 'FairPCT' strategy (seed:3489). ... Task 2 is using 'ProbabilisticRandom' strategy (seed:1470). ... Task 7 is using 'FairPCT' strategy (seed:4835). ... Task 0 is using 'Random' strategy (seed:124). ... Task 6 is using 'ProbabilisticRandom' strategy (seed:4162). ... Task 4 is using 'ProbabilisticRandom' strategy (seed:2816). ... Task 1 is using 'FairPCT' strategy (seed:797). ... The --parallel 8 option means use 8 test processes in parallel with each one being assigned a random scheduling strategy. Each process runs until the first bug is found by some process, then they are all terminated and the bug is reported. This can be useful when you want to leverage the full power of your computer to find those bugs that are particularly hard to find more quickly. You can find out how much testing was actually done during this parallel test operation by adding --coverage activity . The coverage report summarizes how many of the possible events were covered. Liveness monitor As described in the documentation on Liveness Checking the CoffeeMachine must also eventually finish what it is doing. It must either make a coffee when requested and return to the Ready state, or it must find a problem and go to the Error state or the RefillRequired state. This \u201cliveness\u201d property can be enforced using a very simple LivenessMonitor as shown below: internal class LivenessMonitor : Monitor { public class BusyEvent : Event { } public class IdleEvent : Event { } [Start] [Cold] [OnEventGotoState(typeof(BusyEvent), typeof(Busy))] [IgnoreEvents(typeof(IdleEvent))] private class Idle : State { } [Hot] [OnEventGotoState(typeof(IdleEvent), typeof(Idle))] [IgnoreEvents(typeof(BusyEvent))] private class Busy : State { } } This type of Monitor is also a kind of state machine. The CoffeeMachine can send events to this monitor to tell it when it has switched into Busy state or Idle state. When the CoffeeMachine starts heating water, or making coffee it sends this event: this.Monitor<LivenessMonitor>(new LivenessMonitor.BusyEvent()); and when the CoffeeMachine is done making coffee or it has moved to an error state it sends this event: this.Monitor<LivenessMonitor>(new LivenessMonitor.IdleEvent()); The Busy state is marked as a [Hot] state and the Idle state is marked as a [Cold] state. During testing if coyote test finds the LivenessMonitor to be stuck in the [Hot] state too long it raises an exception and the test fails. Reliable termination handshake You may notice in the code that when the FailoverDriver wants to stop the first CoffeeMachine it sends a CoffeeMachine.TerminateEvent and waits for a CoffeeMachine.HaltedEvent before it starts a new CoffeeMachine by running this.RaiseGotoStateEvent<Test>() . This may seem a bit convoluted compared to just this.SendEvent(this.CoffeeMachineId, HaltEvent.Instance) followed by this.RaiseGotoStateEvent<Test>() . The reason a direct halt event was not used in this case is because a HaltEvent is processed asynchronously, which means the RaiseGotoStateEvent would end up creating the new CoffeeMachine instance before the old one was fully halted. This can lead to confusion in the mock sensors which are written to expect one and only one client CoffeeMachine at a time. The TerminateEvent handshake solves that problem. Since the TerminateEvent could be sent to the CoffeeMachine at any time we need an easy way to handle this event at any time in CoffeeMachine , hopefully without having to decorate every single state in the machine with the custom attribute: [OnEventDoAction(typeof(TerminateEvent), nameof(OnTerminate))] The solution is to promote this OnEventDoAction to the class level. Class level handlers are handled like a fall back mechanism so that no matter what state the CoffeeMachine is in the class level handler can be invoked, unless the current state overrides that handler. Summary Failover testing is simple to achieve using Coyote and yields many interesting bugs in your code, including some thought-provoking design bugs. The technique of halting your \u201cproduction\u201d actors/state-machines, and recreating them by reading from a \u201cpersistent\u201d mock (which is not halted during testing) can be generalized to many other scenarios (e.g. cloud services) where someone needs to test failover logic of production actors using Coyote. In this tutorial you learned: How to do failover testing using Coyote FailoverDriver state machines. How to use Coyote in a firmware/sensor scenario. How to use --sch-portfolio testing on multiple processes to find tricky bugs more quickly. How Assert helps find violations of safety properties during testing. How to ensure full termination of one state machine before creating a new one. How to use class level event handlers in a StateMachine to define an event handler in one place that is invoked no matter what state the machine is in. How to write a LivenessMonitor .","title":"Test failover and liveness"},{"location":"tutorials/actors/test-failover/#test-failover-and-liveness-in-coyote-actors","text":"Wikipedia provides this definition : \u201c Failover is switching to a redundant or standby computer server, system, hardware component or network upon the failure or abnormal termination of the previously active application, server, system, hardware component, or network. Systems designers usually provide failover capability in servers, systems or networks requiring near-continuous availability and a high degree of reliability.\u201d This sample applies the failover concept to the firmware of an automated espresso machine using the Coyote asynchronous actors programming model. Imagine what would happen if the tiny CPU running the machine rebooted in the middle of making a coffee. What bad things might happen? Can we design a state machine that can handle this scenario and provide a more fault tolerant coffee machine? An identical version of this tutorial is available that uses regular C# tasks . The following diagram shows how Coyote can be used to test this scenario and help you design more reliable software. The CoffeeMachine is modeled as an asynchronous state machine . This example is not providing real firmware, instead it mocks the hardware sensor platform built into the machine. This is done in MockSensors.cs where you will find three actors that model various hardware components: MockDoorSensor , MockWaterTank and MockCoffeeGrinder . This actor provides async ways of reading sensor values like Water temperature and water levels, or turning on and off the coffee grinder and so on. The CoffeeMachine does not know the sensors are mocks, all it knows is the public interface defined in SensorEvents.cs . In this way the CoffeeMachine is production code, while the mocks are only for testing. The reason we are using an asynchronous model is that even in the smallest of devices, often times there is a message passing architecture where different hardware components are connected via some sort of bus, whether it is a simple serial port, or something more sophisticated like a CAN bus . We will test that we can kill the CoffeeMachine and restart it without anything bad happening. This test is setup by the FailoverDriver . The FailoverDriver lets the first CoffeeMachine instance run for a bit then it randomly kills it by using the HaltEvent , then it starts a new CoffeeMachine . The new CoffeeMachine instance needs to figure out the state of the sensors such that when a MakeCoffeeEvent arrives, it doesn\u2019t do something silly that breaks the machine. The mock sensors are not killed so that it acts as a persistent store for sensor state across all instances of the CoffeeMachine . Some safety Asserts are placed in the code that verify certain important things, including: - do not turn on heater if there is no water - do not turn on grinder if there are no beans in the hopper - do not turn on shot maker if there is no water - do not do anything if the door is open There is also a correctness assert in the CoffeeMachine to make sure the correct number of espresso shots are made and there is a LivenessMonitor that monitors the CoffeeMachine to make sure it never gets stuck, i.e., it always finishes the job it was given or it goes to an error state if the machine needs to be fixed. See Liveness Checking . A number of excellent bugs were found by Coyote during the development of this sample, and this illustrates the fact that Coyote can be applied to any type of asynchronous software, not just cloud services. There is still one bug remaining in the code which you can find using coyote test , and it happens after failover just to prove the usefulness of this testing methodology.","title":"Test failover and liveness in Coyote actors"},{"location":"tutorials/actors/test-failover/#what-you-will-need","text":"To run the CoffeeMachine example, you will need to: Install Visual Studio 2019 . Install the .NET 5.0 version of the coyote tool . Clone the Coyote Samples git repo . Be familiar with the coyote tool. See using Coyote .","title":"What you will need"},{"location":"tutorials/actors/test-failover/#build-the-samples","text":"Build the coyote-samples repo by running the following command: powershell -f build.ps1","title":"Build the samples"},{"location":"tutorials/actors/test-failover/#run-the-failover-coffee-machine-application","text":"Now you can run the CoffeeMachine application: \"./bin/net5.0/CoffeeMachineActors.exe\"","title":"Run the failover coffee machine application"},{"location":"tutorials/actors/test-failover/#the-coffee-machine","text":"There are many different types of coffee machines. This example is based on the following machine which can automatically heat water, grind beans, and make an espresso shot all with the press of a button: The following diagram shows the states and actions in our example implementation in the CoffeeMachine class: When you run the executable without using coyote test (this is called running in production mode ), you will see the following console output. Notice in the output below that the FailoverDriver forces the termination of the CoffeeMachine right in the middle of making a coffee. Then when the CoffeeMachine is restarted, the FailoverDriver requests another coffee and the CoffeeMachine is able to continue on, the water is already warm, and it dumps the old grinds so you have the freshest possible coffee each time. <FailoverDriver> starting new CoffeeMachine. <CoffeeMachine> initializing... <CoffeeMachine> checking initial state of sensors... <CoffeeMachine> Water level is 60 % <CoffeeMachine> Hopper level is 93 % <CoffeeMachine> Warming the water to 100 degrees <CoffeeMachine> Turning on the water heater <CoffeeMachine> Coffee machine is warming up (64 degrees)... <CoffeeMachine> Coffee machine is warming up (74 degrees)... <CoffeeMachine> Coffee machine is warming up (84 degrees)... <CoffeeMachine> Coffee machine is warming up (94 degrees)... <CoffeeMachine> Coffee machine water temperature is now 100 <CoffeeMachine> Turning off the water heater <CoffeeMachine> Coffee machine is ready to make coffee (green light is on) <CoffeeMachine> Coffee requested, shots=1 <CoffeeMachine> Grinding beans... <CoffeeMachine> PortaFilter is 10 % full <CoffeeMachine> PortaFilter is 20 % full <CoffeeMachine> PortaFilter is 30 % full <CoffeeMachine> PortaFilter is 40 % full <CoffeeMachine> PortaFilter is 50 % full <CoffeeMachine> PortaFilter is 60 % full <CoffeeMachine> PortaFilter is 70 % full <CoffeeMachine> PortaFilter is 80 % full <CoffeeMachine> PortaFilter is 90 % full <CoffeeMachine> PortaFilter is full <CoffeeMachine> Making shots... <FailoverDriver> forcing termination of CoffeeMachine. <CoffeeMachine> Coffee Machine Terminating... <CoffeeMachine> ################################################################# <CoffeeMachine> # Coffee Machine Halted # <CoffeeMachine> ################################################################# <FailoverDriver> starting new CoffeeMachine. <CoffeeMachine> initializing... <CoffeeMachine> checking initial state of sensors... <CoffeeMachine> Water level is 60 % <CoffeeMachine> Hopper level is 83 % <CoffeeMachine> Dumping old smelly grinds! <CoffeeMachine> Warming the water to 100 degrees <CoffeeMachine> Coffee machine water temperature is now 100 <CoffeeMachine> Coffee machine is ready to make coffee (green light is on) <CoffeeMachine> Coffee requested, shots=2 <CoffeeMachine> Grinding beans... <CoffeeMachine> PortaFilter is 10 % full <CoffeeMachine> PortaFilter is 20 % full <CoffeeMachine> PortaFilter is 30 % full <CoffeeMachine> PortaFilter is 40 % full <CoffeeMachine> PortaFilter is 50 % full <CoffeeMachine> PortaFilter is 60 % full <CoffeeMachine> PortaFilter is 70 % full <CoffeeMachine> PortaFilter is 80 % full <CoffeeMachine> PortaFilter is 90 % full <CoffeeMachine> PortaFilter is full <CoffeeMachine> Making shots... <CoffeeMachine> Shot count is 1 <CoffeeMachine> 2 shots completed and 2 shots requested! <CoffeeMachine> Dumping the grinds! <CoffeeMachine> Coffee machine is ready to make coffee (green light is on) <FailoverDriver> CoffeeMachine completed the job. ... The test will continue on making coffee until it runs out of either water or coffee beans and the FailoverDriver halts each CoffeeMachine instance at random times until the machine is out of resources, at which point the test is complete. The mock sensors also randomly choose some error conditions, so instead of the above you may see some errors like: <CoffeeMachine> Cannot safely operate coffee machine with the door open! <CoffeeMachine> Coffee machine needs manual refilling of water and/or coffee beans! If you see these errors, press ENTER to terminate the program and run it again. These random start conditions help the test cover more cases. Each halted machine is terminated and discarded, then a new CoffeeMachine instance is started that must figure out what is happening with the sensors and make the next coffee without incident. Eventually a CoffeeMachine will report there is no more water or coffee beans and then it will stop with an error message saying the machine needs to be manually refilled.","title":"The coffee machine"},{"location":"tutorials/actors/test-failover/#coyote-testing","text":"You can now use coyote test to exercise the code and see if any bugs can be found. From the coyote-samples folder: coyote test ./bin/net5.0/CoffeeMachineActors.dll -i 100 -ms 2000 --sch-pct 10 --graph-bug Chances are this will find a bug quickly, one of the safety assertions will fire and you will see that a test output log and DGML diagram are produced, like this: .\\bin\\net5.0\\Output\\CoffeeMachineActors.exe\\CoyoteOutput\\CoffeeMachine_0_0.txt .\\bin\\net5.0\\Output\\CoffeeMachineActors.exe\\CoyoteOutput\\CoffeeMachine_0_0.dgml This log can be pretty big, a couple thousand lines where each line represents one async operation. This log contains only the one iteration that failed, and towards the end you will see something like this: <ActionLog> Microsoft.Coyote.Samples.CoffeeMachineActors.MockCoffeeGrinder(3) invoked action 'OnGrinderButton'. <ErrorLog> Please do not turn on grinder if there are no beans in the hopper So the CoffeeMachine accidentally tried to grind beans when the hopper was empty. If you look at the resulting DGML diagram you will see exactly what happened: The Timer machines were removed from this diagram just for simplicity. The FailoverDriver started the first CoffeeMachine on the left which ran to completion but it ran low on coffee beans. Then this first machine was halted. The FailoverDriver then started a new CoffeeMachine , which made it all the way to GrindingBeans where it tripped the safety assertion in MockCoffeeGrinder . So the bug here is that somehow, the second CoffeeMachine instance missed the fact that it was low on coffee beans. A bug exists in the code somewhere. Can you find it? It is not a trivial bug because the CheckSensors state is clearly checking the coffee level by sending the ReadHopperLevelEvent to the MockCoffeeGrinder actor and CheckInitialState does not advance to the HeatingWater state until this reading is returned. So what happened? Hint: if you search backwards in the output log you will find the following situation reported in CheckState : <CoffeeMachine> Hopper level is -5 % The first CoffeeMachine instance left the grinder running a bit too long, and the sensor got confused thinking the coffee level is negative. The new CoffeeMachine instance never thought about this situation and checked only: if ((int)this.HopperLevel.Value == 0) ... And so it missed the fact it might be negative. The fix is easy, just change this condition to <= and the bug goes away. The fact that such a bug was found shows the usefulness of the failover testing strategy.","title":"Coyote testing"},{"location":"tutorials/actors/test-failover/#testing-the-scheduling-of-highly-asynchronous-operations","text":"This raises a bigger design question, how did the coffee level become negative? In firmware it is common to poll sensor readings and do something based on that. In this case we are polling a PortaFilterCoffeeLevelEvent in a tight loop while in the GrindingBeans state. Meanwhile the MockCoffeeGrinder class has a timer running and when HandleTimer calls MonitorGrinder it decreases the coffee level by 10 percent during every time interval. So we have an asynchronous operation going on here. Coffee level is decreasing based on a timer, and the CoffeeMachine is monitoring that coffee level using async events. This all seems to work perfectly in the production code where we see this output: <CoffeeMachine> Grinding beans... <CoffeeMachine> PortaFilter is 10 % full <CoffeeMachine> PortaFilter is 20 % full <CoffeeMachine> PortaFilter is 30 % full <CoffeeMachine> PortaFilter is 40 % full <CoffeeMachine> PortaFilter is 50 % full <CoffeeMachine> PortaFilter is 60 % full <CoffeeMachine> PortaFilter is 70 % full <CoffeeMachine> PortaFilter is 80 % full <CoffeeMachine> PortaFilter is 90 % full <CoffeeMachine> PortaFilter is full And the reason it works is because your Operating System is scheduling both of these async threads in a way that is relatively fair meaning one does not run for a long time without the other being scheduled also. But what if these two systems were running in a distributed world and one of them hangs for a long time? This is the kind of thread scheduling that coyote test is testing where one machine can run way ahead of another. You need to take this into account when using this kind of timer based async events . One way to improve the design in a firmware based system like a coffee machine is to switch from a polling based system to an interrupt based system where the MockCoffeeGrinder can send important events to the CoffeeMachine . This style of interrupt based eventing is used to model the ShotCompleteEvent , WaterHotEvent , WaterEmptyEvent and HopperEmptyEvent . This shows how Coyote can help find actual design flaws in your code so you can design a system that is more robust in the face of unexpected faults. The coyote test engine provides several different scheduling strategies that test different kinds of fairness algorithms. These are designed to find different kinds of bugs. The following command line shows how to use --sch-portfolio and the --parallel options to test a bunch of different strategies in parallel, each in different test processes: coyote test ./bin/net5.0/CoffeeMachineActors.dll -i 100 -ms 2000 --sch-pct 10 --graph-bug --sch-portfolio --parallel 8 which outputs the following: . Testing .\\bin\\net5.0\\CoffeeMachineActors.dll Starting TestingProcessScheduler in process 42036 ... Created '8' testing tasks. ... Task 3 is using 'FairPCT' strategy (seed:2143). ... Task 5 is using 'FairPCT' strategy (seed:3489). ... Task 2 is using 'ProbabilisticRandom' strategy (seed:1470). ... Task 7 is using 'FairPCT' strategy (seed:4835). ... Task 0 is using 'Random' strategy (seed:124). ... Task 6 is using 'ProbabilisticRandom' strategy (seed:4162). ... Task 4 is using 'ProbabilisticRandom' strategy (seed:2816). ... Task 1 is using 'FairPCT' strategy (seed:797). ... The --parallel 8 option means use 8 test processes in parallel with each one being assigned a random scheduling strategy. Each process runs until the first bug is found by some process, then they are all terminated and the bug is reported. This can be useful when you want to leverage the full power of your computer to find those bugs that are particularly hard to find more quickly. You can find out how much testing was actually done during this parallel test operation by adding --coverage activity . The coverage report summarizes how many of the possible events were covered.","title":"Testing the scheduling of highly asynchronous operations"},{"location":"tutorials/actors/test-failover/#liveness-monitor","text":"As described in the documentation on Liveness Checking the CoffeeMachine must also eventually finish what it is doing. It must either make a coffee when requested and return to the Ready state, or it must find a problem and go to the Error state or the RefillRequired state. This \u201cliveness\u201d property can be enforced using a very simple LivenessMonitor as shown below: internal class LivenessMonitor : Monitor { public class BusyEvent : Event { } public class IdleEvent : Event { } [Start] [Cold] [OnEventGotoState(typeof(BusyEvent), typeof(Busy))] [IgnoreEvents(typeof(IdleEvent))] private class Idle : State { } [Hot] [OnEventGotoState(typeof(IdleEvent), typeof(Idle))] [IgnoreEvents(typeof(BusyEvent))] private class Busy : State { } } This type of Monitor is also a kind of state machine. The CoffeeMachine can send events to this monitor to tell it when it has switched into Busy state or Idle state. When the CoffeeMachine starts heating water, or making coffee it sends this event: this.Monitor<LivenessMonitor>(new LivenessMonitor.BusyEvent()); and when the CoffeeMachine is done making coffee or it has moved to an error state it sends this event: this.Monitor<LivenessMonitor>(new LivenessMonitor.IdleEvent()); The Busy state is marked as a [Hot] state and the Idle state is marked as a [Cold] state. During testing if coyote test finds the LivenessMonitor to be stuck in the [Hot] state too long it raises an exception and the test fails.","title":"Liveness monitor"},{"location":"tutorials/actors/test-failover/#reliable-termination-handshake","text":"You may notice in the code that when the FailoverDriver wants to stop the first CoffeeMachine it sends a CoffeeMachine.TerminateEvent and waits for a CoffeeMachine.HaltedEvent before it starts a new CoffeeMachine by running this.RaiseGotoStateEvent<Test>() . This may seem a bit convoluted compared to just this.SendEvent(this.CoffeeMachineId, HaltEvent.Instance) followed by this.RaiseGotoStateEvent<Test>() . The reason a direct halt event was not used in this case is because a HaltEvent is processed asynchronously, which means the RaiseGotoStateEvent would end up creating the new CoffeeMachine instance before the old one was fully halted. This can lead to confusion in the mock sensors which are written to expect one and only one client CoffeeMachine at a time. The TerminateEvent handshake solves that problem. Since the TerminateEvent could be sent to the CoffeeMachine at any time we need an easy way to handle this event at any time in CoffeeMachine , hopefully without having to decorate every single state in the machine with the custom attribute: [OnEventDoAction(typeof(TerminateEvent), nameof(OnTerminate))] The solution is to promote this OnEventDoAction to the class level. Class level handlers are handled like a fall back mechanism so that no matter what state the CoffeeMachine is in the class level handler can be invoked, unless the current state overrides that handler.","title":"Reliable termination handshake"},{"location":"tutorials/actors/test-failover/#summary","text":"Failover testing is simple to achieve using Coyote and yields many interesting bugs in your code, including some thought-provoking design bugs. The technique of halting your \u201cproduction\u201d actors/state-machines, and recreating them by reading from a \u201cpersistent\u201d mock (which is not halted during testing) can be generalized to many other scenarios (e.g. cloud services) where someone needs to test failover logic of production actors using Coyote. In this tutorial you learned: How to do failover testing using Coyote FailoverDriver state machines. How to use Coyote in a firmware/sensor scenario. How to use --sch-portfolio testing on multiple processes to find tricky bugs more quickly. How Assert helps find violations of safety properties during testing. How to ensure full termination of one state machine before creating a new one. How to use class level event handlers in a StateMachine to define an event handler in one place that is invoked no matter what state the machine is in. How to write a LivenessMonitor .","title":"Summary"},{"location":"tutorials/mocks/mock-dependencies/","text":"Mocking dependencies for concurrency unit testing Mocking dependencies is a common activity when writing unit tests. The code that you want to test often depends on other more complex code, such as third-party libraries and external services (e.g. Cosmos DB ). These dependencies might be impractical to include as part of the test, so you want to replace them with much simpler implementations that simulate the real behavior. One popular way to replace real dependencies with mocks is via dependency injection . Mocks play an even greater role when writing concurrency unit tests . Coyote explores different interleavings during each testing iteration, so you have to write mocks that simulate the behavior of the real dependency by returning the correct response no matter which interleaving is explored. This means that when testing with Coyote, you need to design mocks with concurrency in mind. In this tutorial, you will write a simple mock for the IDbCollection that was introduced in write your first concurrency unit test . You will design this mock to be used in a concurrent setting, where methods in multiple instances of the class can be called concurrently, either within the same process or across processes and machines. This latter condition means that using locks in your code will not help you in writing correct concurrent code. What you will need To run the code in this tutorial, you will need to: Install Visual Studio 2019 . Install the .NET 5.0 version of the coyote tool . Be familiar with the coyote tool. See using Coyote . Go through the write your first concurrency unit test tutorial. Walkthrough Consider the following deliberately buggy implementation of the AccountManager.CreateAccount method: // Returns true if the account is created, else false. public async Task<bool> CreateAccount(string accountName, string accountPayload) { if (await this.AccountCollection.DoesRowExist(accountName)) { return false; } return await this.AccountCollection.CreateRow(accountName, accountPayload); } and consider this simple InMemoryDbCollection mock for the IDbCollection interface, which implements the CreateRow and DoesRowExist methods used in the above method. You can ignore the GetRow and DeleteRow methods for now as they aren\u2019t used in CreateAccount . public class InMemoryDbCollection : IDbCollection { public Task<bool> CreateRow(string key, string value) { return Task.FromResult(true); } public Task<bool> DoesRowExist(string key) { return Task.FromResult(false); } public Task<string> GetRow(string key) { ... } public Task<bool> DeleteRow(string key) { ... } } Using this simple mock, you can write a unit test to exercise sequential account creation in the AccountManager class (see write your first concurrency unit test for the AccountManager code). [Microsoft.Coyote.SystematicTesting.Test] public static async Task TestAccountCreation() { // Initialize the mock DB and account manager. var dbCollection = new InMemoryDbCollection(); var accountManager = new AccountManager(dbCollection); // Create some dummy data. string accountName = \"MyAccount\"; string accountPayload = \"...\"; // Create the account, it should complete successfully and return true. var result = await accountManager.CreateAccount(accountName, accountPayload); Assert.True(result); } After building the code, rewrite the assembly and run the test using Coyote for 10 iterations: coyote rewrite .\\AccountManager.dll coyote test .\\AccountManager.dll -m TestAccountCreation -i 10 The test succeeds. . Testing .\\AccountManager.dll ... Method TestAccountCreation ... Started the testing task scheduler (process:9072). ... Created '1' testing task (process:9072). ... Task 0 is using 'random' strategy (seed:2168858778). ..... Iteration #1 ..... Iteration #2 ..... Iteration #3 ..... Iteration #4 ..... Iteration #5 ..... Iteration #6 ..... Iteration #7 ..... Iteration #8 ..... Iteration #9 ..... Iteration #10 ... Testing statistics: ..... Found 0 bugs. ... Scheduling statistics: ..... Explored 10 schedules: 10 fair and 0 unfair. ..... Number of scheduling points in fair terminating schedules: 0 (min), 0 (avg), 0 (max). ... Elapsed 0.1182 sec. This works, but can this same mock also be used to pass the test if it was executing concurrently? Go ahead and try it out on the following concurrency unit test. [Microsoft.Coyote.SystematicTesting.Test] public static async Task TestConcurrentAccountCreation() { // Initialize the mock DB and account manager. var dbCollection = new InMemoryDbCollection(); var accountManager = new AccountManager(dbCollection); // Create some dummy data. string accountName = \"MyAccount\"; string accountPayload = \"...\"; // Call CreateAccount twice without awaiting, which makes both methods run // asynchronously with each other. var task1 = accountManager.CreateAccount(accountName, accountPayload); var task2 = accountManager.CreateAccount(accountName, accountPayload); // Then wait both requests to complete. await Task.WhenAll(task1, task2); // Finally, assert that only one of the two requests succeeded and the other // failed. Note that we do not know which one of the two succeeded as the // requests ran concurrently (this is why we use an exclusive OR). Assert.True(task1.Result ^ task2.Result); } Build the code again, and then rewrite the assembly and run the test using Coyote for 10 iterations: coyote rewrite .\\AccountManager.dll coyote test .\\AccountManager.dll -m TestConcurrentAccountCreation -i 10 This time the test immediately (and always) fails! . Testing .\\AccountManager.dll ... Method TestConcurrentAccountCreation ... Started the testing task scheduler (process:13328). ... Created '1' testing task (process:13328). ... Task 0 is using 'random' strategy (seed:802918651). ..... Iteration #1 ... Task 0 found a bug. ... Emitting task 0 traces: ..... Writing AccountManager.dll\\CoyoteOutput\\AccountManager_0_0.txt ..... Writing AccountManager.dll\\CoyoteOutput\\AccountManager_0_0.schedule ... Elapsed 0.0798435 sec. ... Testing statistics: ..... Found 1 bug. ... Scheduling statistics: ..... Explored 1 schedule: 1 fair and 0 unfair. ..... Found 100.00% buggy schedules. ..... Number of scheduling points in fair terminating schedules: 5 (min), 5 (avg), 5 (max). ... Elapsed 0.1867838 sec. Your test asserts that one CreateAccount call must succeed and the other must fail, but both calls succeed with the current mock. This is because the dbCollection.DoesRowExist mock method always returns false and the dbCollection.CreateRow mock method always returns true no matter what order the two CreateAccount requests execute. The dbCollection.DoesRowExist method should only return false if the account doesn\u2019t exist and the dbCollection.CreateRow method should only return true if a new row was created. The mock needs to implement more of the stateful behavior of the database as follows: public class InMemoryDbCollection : IDbCollection { private bool UserExists = false; public Task<bool> CreateRow(string key, string value) { if (this.UserExists) { throw new RowAlreadyExistsException(); } this.UserExists = true; return Task.FromResult(true); } public Task<bool> DoesRowExist(string key) { return Task.FromResult(this.UserExists); } public Task<string> GetRow(string key) { ... } public Task<bool> DeleteRow(string key) { ... } } The above mock is a bit more complicated as it models the DoesRowExist and CreateRow behavior more precisely for your test. Build, rewrite and run the same test once again. . Testing .\\AccountManager.dll ... Method TestConcurrentAccountCreation ... Started the testing task scheduler (process:38080). ... Created '1' testing task (process:38080). ... Task 0 is using 'random' strategy (seed:2983982407). ..... Iteration #1 ..... Iteration #2 ..... Iteration #3 ..... Iteration #4 ..... Iteration #5 ..... Iteration #6 ..... Iteration #7 ..... Iteration #8 ..... Iteration #9 ..... Iteration #10 ... Testing statistics: ..... Found 0 bugs. ... Scheduling statistics: ..... Explored 10 schedules: 10 fair and 0 unfair. ..... Number of scheduling points in fair terminating schedules: 2 (min), 3 (avg), 6 (max). ... Elapsed 0.1560682 sec. The assertion will now pass, but the CreateAccount method is actually buggy (read the write your first concurrency unit test tutorial to remember why that is). Why does the assertion not fail?! The reason is that while the two asynchronous CreateAccount methods are invoked concurrently, there is no actual concurrency in the test. While your code uses async/await methods, no code path introduces any concurrency (through Task.Run , Task.Yield etc), which means that the two methods execute sequentially, one after another. Let\u2019s see how you can inject some concurrency which will allow Coyote to \u201cshake\u201d the system and uncover the bug! There are a few ways to make the test truly concurrent. One simple way is to tweak the mock so that it uses Task.Run to start a new task whenever its methods are invoked. public class InMemoryDbCollection : IDbCollection { private bool UserExists = false; public Task<bool> CreateRow(string key, string value) { return Task.Run(() => { if (this.UserExists) { throw new RowAlreadyExistsException(); } this.UserExists = true; return true; }); } public Task<bool> DoesRowExist(string key) { return Task.Run(() => { return this.UserExists; }); } public Task<string> GetRow(string key) { ... } public Task<bool> DeleteRow(string key) { ... } } If you run the TestConcurrentAccountCreation test again using the above mock version, you will see that the bug in CreateAccount is now triggered and the assertion fails! . Testing .\\AccountManager.dll ... Method TestConcurrentAccountCreation ... Started the testing task scheduler (process:17760). ... Created '1' testing task (process:17760). ... Task 0 is using 'random' strategy (seed:641979276). ..... Iteration #1 ..... Iteration #2 ..... Iteration #3 ..... Iteration #4 ..... Iteration #5 ..... Iteration #6 ..... Iteration #7 ..... Iteration #8 ... Task 0 found a bug. ... Emitting task 0 traces: ..... Writing AccountManager.dll\\CoyoteOutput\\AccountManager_0_0.txt ..... Writing AccountManager.dll\\CoyoteOutput\\AccountManager_0_0.schedule ... Elapsed 0.0902799 sec. ... Testing statistics: ..... Found 1 bug. ... Scheduling statistics: ..... Explored 8 schedules: 8 fair and 0 unfair. ..... Found 12.50% buggy schedules. ..... Number of scheduling points in fair terminating schedules: 10 (min), 14 (avg), 23 (max). ... Elapsed 0.198829 sec. Awesome! Using Task.Run in the mock methods introduces concurrency in the test, which allows the two CreateAccount methods to execute asynchronously and race with each other. This is similar to how invoking the production implementation of IDbCollection (i.e. the actual backend NoSQL database) typically happens asynchronously. Can you make the above mock a little more generally applicable, so you don\u2019t have to write custom mocks for each test case? What if you model it in a way that more closely simulates the behavior of the actual IDbCollection ? You could write a mock that you can use in all your concurrency unit tests for the AccountManager using a ConcurrentDictionary : public class InMemoryDbCollection : IDbCollection { private readonly ConcurrentDictionary<string, string> Collection; public InMemoryDbCollection() { this.Collection = new ConcurrentDictionary<string, string>(); } public Task<bool> CreateRow(string key, string value) { return Task.Run(() => { var success = this.Collection.TryAdd(key, value); if (!success) { throw new RowAlreadyExistsException(); } return true; }); } public Task<bool> DoesRowExist(string key) { return Task.Run(() => { return this.Collection.ContainsKey(key); }); } public Task<string> GetRow(string key) { ... } public Task<bool> DeleteRow(string key) { ... } } Through a very simple change, which is to add a ConcurrentDictionary collection to back the in-memory database, you have now written a simple mock that not only simulates the behavior of asynchronously adding rows and checking for their existence, but also can be used in many different concurrency unit tests for the AccountManager logic. For example, this mock can be used in the TestConcurrentAccountCreationAndDeletion test that exercises a race between a CreateAccount and DeleteAccount request in this tutorial . You can now complete the mock by implementing the GetRow and DeleteRow methods. public Task<string> GetRow(string key) { return Task.Run(() => { var success = collection.TryGetValue(key, out string value); if (!success) { throw new RowNotFoundException(); } return value; }); } public Task<bool> DeleteRow(string key) { return Task.Run(() => { var success = collection.TryRemove(key); if (!success) { throw new RowNotFoundException(); } return true; }); } The above is the complete implementation of the InMemoryDbCollection mock that you used in the write your first concurrency unit test tutorial. Mocks that can be used in concurrency unit tests are often surprisingly easy to write and have the benefit that they can be reused in multiple testing scenarios as they more closely model the production behavior of the mocked dependency. Teams in Azure have reported that spending a little effort to write such mocks yielded large productivity gains through better concurrency testing coverage. The cool thing is that writing mocks for testing with Coyote can be done in a \u201cpay-as-you-go\u201d fashion where the initial mock implementation can be as simple as you want, and more functionality can be added later to cover increasingly more complex testing scenarios. Even simple mocks can help you write interesting concurrency unit tests that can find tons of bugs in your code! In the next tutorial , you will learn how to extend the above mock to simulate optimistic concurrency control using ETags. Adding support for ETags combined with the systematic testing of Coyote will allow you to test a scenario that is fairly hard to hit in production but can lead to data loss. Get the sample source code To get the complete source code for the AccountManager tutorial, clone the Coyote Samples git repo . You can build the sample by running the following command: powershell -f build.ps1","title":"Mocking dependencies for testing"},{"location":"tutorials/mocks/mock-dependencies/#mocking-dependencies-for-concurrency-unit-testing","text":"Mocking dependencies is a common activity when writing unit tests. The code that you want to test often depends on other more complex code, such as third-party libraries and external services (e.g. Cosmos DB ). These dependencies might be impractical to include as part of the test, so you want to replace them with much simpler implementations that simulate the real behavior. One popular way to replace real dependencies with mocks is via dependency injection . Mocks play an even greater role when writing concurrency unit tests . Coyote explores different interleavings during each testing iteration, so you have to write mocks that simulate the behavior of the real dependency by returning the correct response no matter which interleaving is explored. This means that when testing with Coyote, you need to design mocks with concurrency in mind. In this tutorial, you will write a simple mock for the IDbCollection that was introduced in write your first concurrency unit test . You will design this mock to be used in a concurrent setting, where methods in multiple instances of the class can be called concurrently, either within the same process or across processes and machines. This latter condition means that using locks in your code will not help you in writing correct concurrent code.","title":"Mocking dependencies for concurrency unit testing"},{"location":"tutorials/mocks/mock-dependencies/#what-you-will-need","text":"To run the code in this tutorial, you will need to: Install Visual Studio 2019 . Install the .NET 5.0 version of the coyote tool . Be familiar with the coyote tool. See using Coyote . Go through the write your first concurrency unit test tutorial.","title":"What you will need"},{"location":"tutorials/mocks/mock-dependencies/#walkthrough","text":"Consider the following deliberately buggy implementation of the AccountManager.CreateAccount method: // Returns true if the account is created, else false. public async Task<bool> CreateAccount(string accountName, string accountPayload) { if (await this.AccountCollection.DoesRowExist(accountName)) { return false; } return await this.AccountCollection.CreateRow(accountName, accountPayload); } and consider this simple InMemoryDbCollection mock for the IDbCollection interface, which implements the CreateRow and DoesRowExist methods used in the above method. You can ignore the GetRow and DeleteRow methods for now as they aren\u2019t used in CreateAccount . public class InMemoryDbCollection : IDbCollection { public Task<bool> CreateRow(string key, string value) { return Task.FromResult(true); } public Task<bool> DoesRowExist(string key) { return Task.FromResult(false); } public Task<string> GetRow(string key) { ... } public Task<bool> DeleteRow(string key) { ... } } Using this simple mock, you can write a unit test to exercise sequential account creation in the AccountManager class (see write your first concurrency unit test for the AccountManager code). [Microsoft.Coyote.SystematicTesting.Test] public static async Task TestAccountCreation() { // Initialize the mock DB and account manager. var dbCollection = new InMemoryDbCollection(); var accountManager = new AccountManager(dbCollection); // Create some dummy data. string accountName = \"MyAccount\"; string accountPayload = \"...\"; // Create the account, it should complete successfully and return true. var result = await accountManager.CreateAccount(accountName, accountPayload); Assert.True(result); } After building the code, rewrite the assembly and run the test using Coyote for 10 iterations: coyote rewrite .\\AccountManager.dll coyote test .\\AccountManager.dll -m TestAccountCreation -i 10 The test succeeds. . Testing .\\AccountManager.dll ... Method TestAccountCreation ... Started the testing task scheduler (process:9072). ... Created '1' testing task (process:9072). ... Task 0 is using 'random' strategy (seed:2168858778). ..... Iteration #1 ..... Iteration #2 ..... Iteration #3 ..... Iteration #4 ..... Iteration #5 ..... Iteration #6 ..... Iteration #7 ..... Iteration #8 ..... Iteration #9 ..... Iteration #10 ... Testing statistics: ..... Found 0 bugs. ... Scheduling statistics: ..... Explored 10 schedules: 10 fair and 0 unfair. ..... Number of scheduling points in fair terminating schedules: 0 (min), 0 (avg), 0 (max). ... Elapsed 0.1182 sec. This works, but can this same mock also be used to pass the test if it was executing concurrently? Go ahead and try it out on the following concurrency unit test. [Microsoft.Coyote.SystematicTesting.Test] public static async Task TestConcurrentAccountCreation() { // Initialize the mock DB and account manager. var dbCollection = new InMemoryDbCollection(); var accountManager = new AccountManager(dbCollection); // Create some dummy data. string accountName = \"MyAccount\"; string accountPayload = \"...\"; // Call CreateAccount twice without awaiting, which makes both methods run // asynchronously with each other. var task1 = accountManager.CreateAccount(accountName, accountPayload); var task2 = accountManager.CreateAccount(accountName, accountPayload); // Then wait both requests to complete. await Task.WhenAll(task1, task2); // Finally, assert that only one of the two requests succeeded and the other // failed. Note that we do not know which one of the two succeeded as the // requests ran concurrently (this is why we use an exclusive OR). Assert.True(task1.Result ^ task2.Result); } Build the code again, and then rewrite the assembly and run the test using Coyote for 10 iterations: coyote rewrite .\\AccountManager.dll coyote test .\\AccountManager.dll -m TestConcurrentAccountCreation -i 10 This time the test immediately (and always) fails! . Testing .\\AccountManager.dll ... Method TestConcurrentAccountCreation ... Started the testing task scheduler (process:13328). ... Created '1' testing task (process:13328). ... Task 0 is using 'random' strategy (seed:802918651). ..... Iteration #1 ... Task 0 found a bug. ... Emitting task 0 traces: ..... Writing AccountManager.dll\\CoyoteOutput\\AccountManager_0_0.txt ..... Writing AccountManager.dll\\CoyoteOutput\\AccountManager_0_0.schedule ... Elapsed 0.0798435 sec. ... Testing statistics: ..... Found 1 bug. ... Scheduling statistics: ..... Explored 1 schedule: 1 fair and 0 unfair. ..... Found 100.00% buggy schedules. ..... Number of scheduling points in fair terminating schedules: 5 (min), 5 (avg), 5 (max). ... Elapsed 0.1867838 sec. Your test asserts that one CreateAccount call must succeed and the other must fail, but both calls succeed with the current mock. This is because the dbCollection.DoesRowExist mock method always returns false and the dbCollection.CreateRow mock method always returns true no matter what order the two CreateAccount requests execute. The dbCollection.DoesRowExist method should only return false if the account doesn\u2019t exist and the dbCollection.CreateRow method should only return true if a new row was created. The mock needs to implement more of the stateful behavior of the database as follows: public class InMemoryDbCollection : IDbCollection { private bool UserExists = false; public Task<bool> CreateRow(string key, string value) { if (this.UserExists) { throw new RowAlreadyExistsException(); } this.UserExists = true; return Task.FromResult(true); } public Task<bool> DoesRowExist(string key) { return Task.FromResult(this.UserExists); } public Task<string> GetRow(string key) { ... } public Task<bool> DeleteRow(string key) { ... } } The above mock is a bit more complicated as it models the DoesRowExist and CreateRow behavior more precisely for your test. Build, rewrite and run the same test once again. . Testing .\\AccountManager.dll ... Method TestConcurrentAccountCreation ... Started the testing task scheduler (process:38080). ... Created '1' testing task (process:38080). ... Task 0 is using 'random' strategy (seed:2983982407). ..... Iteration #1 ..... Iteration #2 ..... Iteration #3 ..... Iteration #4 ..... Iteration #5 ..... Iteration #6 ..... Iteration #7 ..... Iteration #8 ..... Iteration #9 ..... Iteration #10 ... Testing statistics: ..... Found 0 bugs. ... Scheduling statistics: ..... Explored 10 schedules: 10 fair and 0 unfair. ..... Number of scheduling points in fair terminating schedules: 2 (min), 3 (avg), 6 (max). ... Elapsed 0.1560682 sec. The assertion will now pass, but the CreateAccount method is actually buggy (read the write your first concurrency unit test tutorial to remember why that is). Why does the assertion not fail?! The reason is that while the two asynchronous CreateAccount methods are invoked concurrently, there is no actual concurrency in the test. While your code uses async/await methods, no code path introduces any concurrency (through Task.Run , Task.Yield etc), which means that the two methods execute sequentially, one after another. Let\u2019s see how you can inject some concurrency which will allow Coyote to \u201cshake\u201d the system and uncover the bug! There are a few ways to make the test truly concurrent. One simple way is to tweak the mock so that it uses Task.Run to start a new task whenever its methods are invoked. public class InMemoryDbCollection : IDbCollection { private bool UserExists = false; public Task<bool> CreateRow(string key, string value) { return Task.Run(() => { if (this.UserExists) { throw new RowAlreadyExistsException(); } this.UserExists = true; return true; }); } public Task<bool> DoesRowExist(string key) { return Task.Run(() => { return this.UserExists; }); } public Task<string> GetRow(string key) { ... } public Task<bool> DeleteRow(string key) { ... } } If you run the TestConcurrentAccountCreation test again using the above mock version, you will see that the bug in CreateAccount is now triggered and the assertion fails! . Testing .\\AccountManager.dll ... Method TestConcurrentAccountCreation ... Started the testing task scheduler (process:17760). ... Created '1' testing task (process:17760). ... Task 0 is using 'random' strategy (seed:641979276). ..... Iteration #1 ..... Iteration #2 ..... Iteration #3 ..... Iteration #4 ..... Iteration #5 ..... Iteration #6 ..... Iteration #7 ..... Iteration #8 ... Task 0 found a bug. ... Emitting task 0 traces: ..... Writing AccountManager.dll\\CoyoteOutput\\AccountManager_0_0.txt ..... Writing AccountManager.dll\\CoyoteOutput\\AccountManager_0_0.schedule ... Elapsed 0.0902799 sec. ... Testing statistics: ..... Found 1 bug. ... Scheduling statistics: ..... Explored 8 schedules: 8 fair and 0 unfair. ..... Found 12.50% buggy schedules. ..... Number of scheduling points in fair terminating schedules: 10 (min), 14 (avg), 23 (max). ... Elapsed 0.198829 sec. Awesome! Using Task.Run in the mock methods introduces concurrency in the test, which allows the two CreateAccount methods to execute asynchronously and race with each other. This is similar to how invoking the production implementation of IDbCollection (i.e. the actual backend NoSQL database) typically happens asynchronously. Can you make the above mock a little more generally applicable, so you don\u2019t have to write custom mocks for each test case? What if you model it in a way that more closely simulates the behavior of the actual IDbCollection ? You could write a mock that you can use in all your concurrency unit tests for the AccountManager using a ConcurrentDictionary : public class InMemoryDbCollection : IDbCollection { private readonly ConcurrentDictionary<string, string> Collection; public InMemoryDbCollection() { this.Collection = new ConcurrentDictionary<string, string>(); } public Task<bool> CreateRow(string key, string value) { return Task.Run(() => { var success = this.Collection.TryAdd(key, value); if (!success) { throw new RowAlreadyExistsException(); } return true; }); } public Task<bool> DoesRowExist(string key) { return Task.Run(() => { return this.Collection.ContainsKey(key); }); } public Task<string> GetRow(string key) { ... } public Task<bool> DeleteRow(string key) { ... } } Through a very simple change, which is to add a ConcurrentDictionary collection to back the in-memory database, you have now written a simple mock that not only simulates the behavior of asynchronously adding rows and checking for their existence, but also can be used in many different concurrency unit tests for the AccountManager logic. For example, this mock can be used in the TestConcurrentAccountCreationAndDeletion test that exercises a race between a CreateAccount and DeleteAccount request in this tutorial . You can now complete the mock by implementing the GetRow and DeleteRow methods. public Task<string> GetRow(string key) { return Task.Run(() => { var success = collection.TryGetValue(key, out string value); if (!success) { throw new RowNotFoundException(); } return value; }); } public Task<bool> DeleteRow(string key) { return Task.Run(() => { var success = collection.TryRemove(key); if (!success) { throw new RowNotFoundException(); } return true; }); } The above is the complete implementation of the InMemoryDbCollection mock that you used in the write your first concurrency unit test tutorial. Mocks that can be used in concurrency unit tests are often surprisingly easy to write and have the benefit that they can be reused in multiple testing scenarios as they more closely model the production behavior of the mocked dependency. Teams in Azure have reported that spending a little effort to write such mocks yielded large productivity gains through better concurrency testing coverage. The cool thing is that writing mocks for testing with Coyote can be done in a \u201cpay-as-you-go\u201d fashion where the initial mock implementation can be as simple as you want, and more functionality can be added later to cover increasingly more complex testing scenarios. Even simple mocks can help you write interesting concurrency unit tests that can find tons of bugs in your code! In the next tutorial , you will learn how to extend the above mock to simulate optimistic concurrency control using ETags. Adding support for ETags combined with the systematic testing of Coyote will allow you to test a scenario that is fairly hard to hit in production but can lead to data loss.","title":"Walkthrough"},{"location":"tutorials/mocks/mock-dependencies/#get-the-sample-source-code","text":"To get the complete source code for the AccountManager tutorial, clone the Coyote Samples git repo . You can build the sample by running the following command: powershell -f build.ps1","title":"Get the sample source code"},{"location":"tutorials/mocks/optimistic-concurrency-control/","text":"Simulating optimistic concurrency control using ETags Concurrency unit testing with Coyote often involves writing mocks that simulate (a subset of) the behavior of an external service or library. This is a \u201cpay-as-you-go\u201d effort, it is up to you to decide how simple or complex you want your mocks to be depending on what kind of logic you want to test! You can start with writing some very simple mocks and incrementally add behavior if you want to test more advanced scenarios. The only requirement is that the mocks must work in a concurrent setting, as Coyote explores interleavings and other sources of nondeterminism . For example, the simple InMemoryDbCollection mock described in the previous tutorial simulates asynchronous row manipulation in a backend NoSQL database to test the logic of an AccountManager . A great benefit of designing such a mock is that it can be reused across many different concurrency unit tests , comparing to the more traditional approach of writing very simple mock methods that return fixed results (like in the first version of the InMemoryDbCollection mock). In this tutorial, you will see that it is very easy to take the InMemoryDbCollection mock and extend it with ETags to simulate optimistic concurrency control . While the implementation of an actual NoSQL database can be really complex, enhancing your mock with ETag semantics can be fairly trivial. What you will need To run the code in this tutorial, you will need to: Install Visual Studio 2019 . Install the .NET 5.0 version of the coyote tool . Be familiar with the coyote tool. See using Coyote . Go through the mocking dependencies for testing tutorial. Walkthrough Let\u2019s motivate the problem by extending the AccountManager to support updating existing accounts. An account can only be updated if the version of the new instance is greater than that of the existing instance. To deal with this design requirement, the AccountManager must now maintain a version per account (besides its name and payload) as follows: public class Account { public string Name { get; set; } public string Payload { get; set; } public int Version { get; set; } } Recall that accounts are stored in a backend NoSQL database, which the AccountManager accesses via the IDbCollection interface. To be able to update stored accounts, extend IDbCollection with an UpdateRow method. public interface IDbCollection { Task<bool> CreateRow(string key, string value); Task<bool> DoesRowExist(string key); Task<string> GetRow(string key); Task<bool> UpdateRow(string key, string value); Task<bool> DeleteRow(string key); } You will also need to extend the InMemoryDbCollection mock with UpdateRow . Let\u2019s write a very simple mock implementation for this method. public Task<bool> UpdateRow(string key, string value) { return Task.Run(() => { lock (this.Collection) { bool success = this.Collection.ContainsKey(key); if (!success) { throw new RowNotFoundException(); } this.Collection[key] = value; } return true; }); } The lock statement ensures that checking if the key exists in the dictionary (via this.Collection.ContainsKey(key) ) and updating its value (via this.Collection[key] = value ) is done atomically (without interference from other concurrent operations to the database). One interesting observation is that the lock is inside the InMemoryDbCollection mock but not inside the AccountManager code. You might be wondering why it is not okay to use a lock in AccountManager , but it is fine to use it in InMemoryDbCollection ? The reason behind this choice is that AccountManager instances can run in across different processes or machines in production, and locks do not work in such an intra-process setting because usually intra-process calls are done asynchronously and it is not safe to do async code inside a lock statement. With Coyote, however, you run the entire concurrency unit test in a single process, so it is perfectly fine for the mock itself to take a lock, which makes it a lot easier to simulate the ETag functionality. You can see how the rest of the InMemoryDbCollection methods are implemented in the AccountManager.ETags sample, which is available in the Coyote Samples git repo . Next, let\u2019s implement the AccountManager logic. public class AccountManager { private readonly IDbCollection AccountCollection; public AccountManager(IDbCollection dbCollection) { this.AccountCollection = dbCollection; } // Returns true if the account is created, else false. public async Task<bool> CreateAccount(string accountName, string accountPayload, int accountVersion) { var account = new Account() { Name = accountName, Payload = accountPayload, Version = accountVersion }; try { return await this.AccountCollection.CreateRow(accountName, JsonSerializer.Serialize(account)); } catch (RowAlreadyExistsException) { return false; } } // Returns true if the account is updated, else false. public async Task<bool> UpdateAccount(string accountName, string accountPayload, int accountVersion) { Account existingAccount; try { string value = await this.AccountCollection.GetRow(accountName); existingAccount = JsonSerializer.Deserialize<Account>(value); } catch (RowNotFoundException) { return false; } if (accountVersion <= existingAccount.Version) { return false; } var updatedAccount = new Account() { Name = accountName, Payload = accountPayload, Version = accountVersion }; try { return await this.AccountCollection.UpdateRow(accountName, JsonSerializer.Serialize(updatedAccount)); } catch (RowNotFoundException) { return false; } } // Returns the account if found, else null. public async Task<Account> GetAccount(string accountName) { try { string value = await this.AccountCollection.GetRow(accountName); return JsonSerializer.Deserialize<Account>(value); } catch (RowNotFoundException) { return null; } } // Returns true if the account is deleted, else false. public async Task<bool> DeleteAccount(string accountName) { try { return await this.AccountCollection.DeleteRow(accountName); } catch (RowNotFoundException) { return false; } } } This was a lot of code! The CreateAccount is similar to the previous tutorial , but with a few differences. It creates an Account instance using the input account data, then uses System.Text.Json to serialize it to a string and tries to add it to the database by invoking CreateRow . If this operation fails with a RowAlreadyExistsException , the AccountManager catches the exception and returns false , else it returns true . The UpdateAccount method is a bit more involved. The method first invokes the GetRow database method to get the value of the account with the name that we want to update (if such an account already exists), and uses System.Text.Json to deserialize the returned value to an Account instance. Next, the AccountManager checks if the version of the existing account is greater or equal than the new account, and if yes, the method fails with false . Else, it creates a new Account instance, serializes it and tries to update the corresponding database entry by invoking UpdateRow . The GetAccount and DeleteAccount methods are also similar to the previous tutorial , but now use a try { ... } catch { ... } block to return false if the call to IDbCollection failed with a RowNotFoundException . Let\u2019s first write a sequential unit test to exercise the above UpdateAccount logic. [Microsoft.Coyote.SystematicTesting.Test] public static async Task TestAccountUpdate() { // Initialize the mock in-memory DB and account manager. var dbCollection = new InMemoryDbCollection(); var accountManager = new AccountManager(dbCollection); string accountName = \"MyAccount\"; // Create the account, it should complete successfully and return true. var result = await accountManager.CreateAccount(accountName, \"first_version\", 1); Assert.True(result); result = await accountManager.UpdateAccount(accountName, \"second_version\", 2); Assert.True(result); result = await accountManager.UpdateAccount(accountName, \"second_version_alt\", 2); Assert.False(result); } Build the code, rewrite the assembly and run the test using Coyote for 10 iterations: coyote rewrite .\\AccountManager.ETags.dll coyote test .\\AccountManager.ETags.dll -m TestAccountUpdate -i 10 The test succeeds. . Testing .\\AccountManager.ETags.dll ... Method TestAccountUpdate ... Started the testing task scheduler (process:37236). ... Created '1' testing task (process:37236). ... Task 0 is using 'random' strategy (seed:2049239085). ..... Iteration #1 ..... Iteration #2 ..... Iteration #3 ..... Iteration #4 ..... Iteration #5 ..... Iteration #6 ..... Iteration #7 ..... Iteration #8 ..... Iteration #9 ..... Iteration #10 ... Testing statistics: ..... Found 0 bugs. ... Scheduling statistics: ..... Explored 10 schedules: 10 fair and 0 unfair. ..... Number of scheduling points in fair terminating schedules: 15 (min), 17 (avg), 25 (max). ... Elapsed 0.2354834 sec. This is cool, but will a test that exercises concurrent account updates also succeed? Let\u2019s find out by writing the following concurrency unit test. [Microsoft.Coyote.SystematicTesting.Test] public static async Task TestConcurrentAccountUpdate() { // Initialize the mock in-memory DB and account manager. var dbCollection = new InMemoryDbCollection(); var accountManager = new AccountManager(dbCollection); string accountName = \"MyAccount\"; // Create the account, it should complete successfully and return true. var result = await accountManager.CreateAccount(accountName, \"first_version\", 1); Assert.True(result); // Call UpdateAccount twice without awaiting, which makes both methods run // asynchronously with each other. var task1 = accountManager.UpdateAccount(accountName, \"second_version\", 2); var task2 = accountManager.UpdateAccount(accountName, \"second_version_alt\", 2); // Then wait both requests to complete. await Task.WhenAll(task1, task2); // Finally, assert that only one of the two requests succeeded and the other // failed. Note that we do not know which one of the two succeeded as the // requests ran concurrently (this is why we use an exclusive OR). Assert.True(task1.Result ^ task2.Result); } Build the code, rewrite the assembly and run the test using Coyote for 10 iterations. You\u2019ll realize it will fail quite fast as Coyote will find an execution in which both UpdateAccount requests succeed. This is a bug because only one of the two requests should succeed. This race condition happens when the two concurrently executing UpdateAccount methods both read the first Version of the row, independently think their account Version is greater than what is currently stored in the database and update the entry. In fact, the problem is worse than that. Consider the following test that first updates the accounts concurrently using two different versions, 2 and 3 , and then getting the account and asserting that the account version should always be the latest, which is 3 . [Microsoft.Coyote.SystematicTesting.Test] public static async Task TestGetAccountAfterConcurrentUpdate() { // Initialize the mock in-memory DB and account manager. var dbCollection = new InMemoryDbCollection(); var accountManager = new AccountManager(dbCollection); string accountName = \"MyAccount\"; // Create the account, it should complete successfully and return true. var result = await accountManager.CreateAccount(accountName, \"first_version\", 1); Assert.True(result); // Call UpdateAccount twice without awaiting, which makes both methods run // asynchronously with each other. var task1 = accountManager.UpdateAccount(accountName, \"second_version\", 2); var task2 = accountManager.UpdateAccount(accountName, \"third_version\", 3); // Then wait both requests to complete. await Task.WhenAll(task1, task2); // Finally, get the account and assert that the version is always 3, // which is the latest updated version. var account = await accountManager.GetAccount(accountName); Assert.True(account.Version == 3); } Build the code, rewrite the assembly and run the test using Coyote for 10 iterations. This test will fail in some iterations with account version 2 overwriting version 3 . You can see that this is not just a benign failure! The code doesn\u2019t respect the UpdateAccount semantics in the presence of concurrency, which is a serious issue. A database system like Cosmos DB provides ETags which you can use to only update the row if the ETags match. This ensures that UpdateAccount will fail if another concurrent request updates the row after UpdateAccount has read it, which indicates that UpdateAccount operated on stale data. Let\u2019s take a look at a correct implementation of UpdateAccount that uses ETags. // Returns true if the account is updated, else false. public async Task<bool> UpdateAccount(string accountName, string accountPayload, int accountVersion) { Account existingAccount; Guid existingAccountETag; // Naive retry if ETags mismatch. In production, you would either use a proper retry // policy with delays or return a response to the caller requesting them to retry. while (true) { try { (string value, Guid etag) = await this.AccountCollection.GetRow(accountName); existingAccount = JsonSerializer.Deserialize<Account>(value); existingAccountETag = etag; } catch (RowNotFoundException) { return false; } if (accountVersion <= existingAccount.Version) { return false; } var updatedAccount = new Account() { Name = accountName, Payload = accountPayload, Version = accountVersion }; try { return await this.AccountCollection.UpdateRow( accountName, JsonSerializer.Serialize(updatedAccount), existingAccountETag); } catch (MismatchedETagException) { continue; } catch (RowNotFoundException) { return false; } } } Let\u2019s extend the IDbCollection interface and InMemoryDbCollection mock to support ETags so that you can run the above test. You can also define a helper DbRow class in your mock to store the database row value with its associated ETag. public class DbRow { public string Value { get; set; } public Guid ETag { get; set; } } public interface IDbCollection { Task<bool> CreateRow(string key, string value); Task<bool> DoesRowExist(string key); Task<(string value, Guid etag)> GetRow(string key); Task<bool> UpdateRow(string key, string value, Guid etag); Task<bool> DeleteRow(string key); } public class InMemoryDbCollection : IDbCollection { private readonly ConcurrentDictionary<string, DbRow> Collection; public InMemoryDbCollection() { this.Collection = new ConcurrentDictionary<string, DbRow>(); } public Task<bool> CreateRow(string key, string value) { return Task.Run(() => { // Generate a new ETag when creating a brand new row. var dbRow = new DbRow() { Value = value, ETag = Guid.NewGuid() }; bool success = this.Collection.TryAdd(key, dbRow); if (!success) { throw new RowAlreadyExistsException(); } return true; }); } public Task<(string value, Guid etag)> GetRow(string key) { return Task.Run(() => { bool success = this.Collection.TryGetValue(key, out DbRow dbRow); if (!success) { throw new RowNotFoundException(); } return (dbRow.Value, dbRow.ETag); }); } public Task<bool> UpdateRow(string key, string value, Guid etag) { return Task.Run(() => { lock (this.Collection) { bool success = this.Collection.TryGetValue(key, out DbRow existingDbRow); if (!success) { throw new RowNotFoundException(); } else if (etag != existingDbRow.ETag) { throw new MismatchedETagException(); } // Update the Etag value when updating the row. var dbRow = new DbRow() { Value = value, ETag = Guid.NewGuid() }; this.Collection[key] = dbRow; return true; } }); } /* Rest of the methods not shown for simplicity */ } The above InMemoryDbCollection mock simulates the ETag semantics of Cosmos DB. You can see how the rest of the InMemoryDbCollection methods are implemented in the AccountManager.ETags sample, which is available in the Coyote Samples git repo . Build the code one last time, rewrite the assembly and run the test using Coyote for 10 iterations. This time the test succeeds! If you try to remove the ETag check, it will fail as expected. As you can see, it didn\u2019t take much effort to simulate ETags in the mock, as you just simulated the semantics in-memory . This is significantly easier than if you had to implement the real ETags functionality in a production distributed system, where you would have to worry about arbitrary failures, coordination across machines and network delays. Mocks are often fairly easy to write and help ensure that your distributed service works correctly in the presence of arbitrary concurrency across a fleet of machines. Get the sample source code To get the complete source code for the AccountManager.ETags tutorial, clone the Coyote Samples git repo . You can build the sample by running the following command: powershell -f build.ps1","title":"Simulating optimistic concurrency control"},{"location":"tutorials/mocks/optimistic-concurrency-control/#simulating-optimistic-concurrency-control-using-etags","text":"Concurrency unit testing with Coyote often involves writing mocks that simulate (a subset of) the behavior of an external service or library. This is a \u201cpay-as-you-go\u201d effort, it is up to you to decide how simple or complex you want your mocks to be depending on what kind of logic you want to test! You can start with writing some very simple mocks and incrementally add behavior if you want to test more advanced scenarios. The only requirement is that the mocks must work in a concurrent setting, as Coyote explores interleavings and other sources of nondeterminism . For example, the simple InMemoryDbCollection mock described in the previous tutorial simulates asynchronous row manipulation in a backend NoSQL database to test the logic of an AccountManager . A great benefit of designing such a mock is that it can be reused across many different concurrency unit tests , comparing to the more traditional approach of writing very simple mock methods that return fixed results (like in the first version of the InMemoryDbCollection mock). In this tutorial, you will see that it is very easy to take the InMemoryDbCollection mock and extend it with ETags to simulate optimistic concurrency control . While the implementation of an actual NoSQL database can be really complex, enhancing your mock with ETag semantics can be fairly trivial.","title":"Simulating optimistic concurrency control using ETags"},{"location":"tutorials/mocks/optimistic-concurrency-control/#what-you-will-need","text":"To run the code in this tutorial, you will need to: Install Visual Studio 2019 . Install the .NET 5.0 version of the coyote tool . Be familiar with the coyote tool. See using Coyote . Go through the mocking dependencies for testing tutorial.","title":"What you will need"},{"location":"tutorials/mocks/optimistic-concurrency-control/#walkthrough","text":"Let\u2019s motivate the problem by extending the AccountManager to support updating existing accounts. An account can only be updated if the version of the new instance is greater than that of the existing instance. To deal with this design requirement, the AccountManager must now maintain a version per account (besides its name and payload) as follows: public class Account { public string Name { get; set; } public string Payload { get; set; } public int Version { get; set; } } Recall that accounts are stored in a backend NoSQL database, which the AccountManager accesses via the IDbCollection interface. To be able to update stored accounts, extend IDbCollection with an UpdateRow method. public interface IDbCollection { Task<bool> CreateRow(string key, string value); Task<bool> DoesRowExist(string key); Task<string> GetRow(string key); Task<bool> UpdateRow(string key, string value); Task<bool> DeleteRow(string key); } You will also need to extend the InMemoryDbCollection mock with UpdateRow . Let\u2019s write a very simple mock implementation for this method. public Task<bool> UpdateRow(string key, string value) { return Task.Run(() => { lock (this.Collection) { bool success = this.Collection.ContainsKey(key); if (!success) { throw new RowNotFoundException(); } this.Collection[key] = value; } return true; }); } The lock statement ensures that checking if the key exists in the dictionary (via this.Collection.ContainsKey(key) ) and updating its value (via this.Collection[key] = value ) is done atomically (without interference from other concurrent operations to the database). One interesting observation is that the lock is inside the InMemoryDbCollection mock but not inside the AccountManager code. You might be wondering why it is not okay to use a lock in AccountManager , but it is fine to use it in InMemoryDbCollection ? The reason behind this choice is that AccountManager instances can run in across different processes or machines in production, and locks do not work in such an intra-process setting because usually intra-process calls are done asynchronously and it is not safe to do async code inside a lock statement. With Coyote, however, you run the entire concurrency unit test in a single process, so it is perfectly fine for the mock itself to take a lock, which makes it a lot easier to simulate the ETag functionality. You can see how the rest of the InMemoryDbCollection methods are implemented in the AccountManager.ETags sample, which is available in the Coyote Samples git repo . Next, let\u2019s implement the AccountManager logic. public class AccountManager { private readonly IDbCollection AccountCollection; public AccountManager(IDbCollection dbCollection) { this.AccountCollection = dbCollection; } // Returns true if the account is created, else false. public async Task<bool> CreateAccount(string accountName, string accountPayload, int accountVersion) { var account = new Account() { Name = accountName, Payload = accountPayload, Version = accountVersion }; try { return await this.AccountCollection.CreateRow(accountName, JsonSerializer.Serialize(account)); } catch (RowAlreadyExistsException) { return false; } } // Returns true if the account is updated, else false. public async Task<bool> UpdateAccount(string accountName, string accountPayload, int accountVersion) { Account existingAccount; try { string value = await this.AccountCollection.GetRow(accountName); existingAccount = JsonSerializer.Deserialize<Account>(value); } catch (RowNotFoundException) { return false; } if (accountVersion <= existingAccount.Version) { return false; } var updatedAccount = new Account() { Name = accountName, Payload = accountPayload, Version = accountVersion }; try { return await this.AccountCollection.UpdateRow(accountName, JsonSerializer.Serialize(updatedAccount)); } catch (RowNotFoundException) { return false; } } // Returns the account if found, else null. public async Task<Account> GetAccount(string accountName) { try { string value = await this.AccountCollection.GetRow(accountName); return JsonSerializer.Deserialize<Account>(value); } catch (RowNotFoundException) { return null; } } // Returns true if the account is deleted, else false. public async Task<bool> DeleteAccount(string accountName) { try { return await this.AccountCollection.DeleteRow(accountName); } catch (RowNotFoundException) { return false; } } } This was a lot of code! The CreateAccount is similar to the previous tutorial , but with a few differences. It creates an Account instance using the input account data, then uses System.Text.Json to serialize it to a string and tries to add it to the database by invoking CreateRow . If this operation fails with a RowAlreadyExistsException , the AccountManager catches the exception and returns false , else it returns true . The UpdateAccount method is a bit more involved. The method first invokes the GetRow database method to get the value of the account with the name that we want to update (if such an account already exists), and uses System.Text.Json to deserialize the returned value to an Account instance. Next, the AccountManager checks if the version of the existing account is greater or equal than the new account, and if yes, the method fails with false . Else, it creates a new Account instance, serializes it and tries to update the corresponding database entry by invoking UpdateRow . The GetAccount and DeleteAccount methods are also similar to the previous tutorial , but now use a try { ... } catch { ... } block to return false if the call to IDbCollection failed with a RowNotFoundException . Let\u2019s first write a sequential unit test to exercise the above UpdateAccount logic. [Microsoft.Coyote.SystematicTesting.Test] public static async Task TestAccountUpdate() { // Initialize the mock in-memory DB and account manager. var dbCollection = new InMemoryDbCollection(); var accountManager = new AccountManager(dbCollection); string accountName = \"MyAccount\"; // Create the account, it should complete successfully and return true. var result = await accountManager.CreateAccount(accountName, \"first_version\", 1); Assert.True(result); result = await accountManager.UpdateAccount(accountName, \"second_version\", 2); Assert.True(result); result = await accountManager.UpdateAccount(accountName, \"second_version_alt\", 2); Assert.False(result); } Build the code, rewrite the assembly and run the test using Coyote for 10 iterations: coyote rewrite .\\AccountManager.ETags.dll coyote test .\\AccountManager.ETags.dll -m TestAccountUpdate -i 10 The test succeeds. . Testing .\\AccountManager.ETags.dll ... Method TestAccountUpdate ... Started the testing task scheduler (process:37236). ... Created '1' testing task (process:37236). ... Task 0 is using 'random' strategy (seed:2049239085). ..... Iteration #1 ..... Iteration #2 ..... Iteration #3 ..... Iteration #4 ..... Iteration #5 ..... Iteration #6 ..... Iteration #7 ..... Iteration #8 ..... Iteration #9 ..... Iteration #10 ... Testing statistics: ..... Found 0 bugs. ... Scheduling statistics: ..... Explored 10 schedules: 10 fair and 0 unfair. ..... Number of scheduling points in fair terminating schedules: 15 (min), 17 (avg), 25 (max). ... Elapsed 0.2354834 sec. This is cool, but will a test that exercises concurrent account updates also succeed? Let\u2019s find out by writing the following concurrency unit test. [Microsoft.Coyote.SystematicTesting.Test] public static async Task TestConcurrentAccountUpdate() { // Initialize the mock in-memory DB and account manager. var dbCollection = new InMemoryDbCollection(); var accountManager = new AccountManager(dbCollection); string accountName = \"MyAccount\"; // Create the account, it should complete successfully and return true. var result = await accountManager.CreateAccount(accountName, \"first_version\", 1); Assert.True(result); // Call UpdateAccount twice without awaiting, which makes both methods run // asynchronously with each other. var task1 = accountManager.UpdateAccount(accountName, \"second_version\", 2); var task2 = accountManager.UpdateAccount(accountName, \"second_version_alt\", 2); // Then wait both requests to complete. await Task.WhenAll(task1, task2); // Finally, assert that only one of the two requests succeeded and the other // failed. Note that we do not know which one of the two succeeded as the // requests ran concurrently (this is why we use an exclusive OR). Assert.True(task1.Result ^ task2.Result); } Build the code, rewrite the assembly and run the test using Coyote for 10 iterations. You\u2019ll realize it will fail quite fast as Coyote will find an execution in which both UpdateAccount requests succeed. This is a bug because only one of the two requests should succeed. This race condition happens when the two concurrently executing UpdateAccount methods both read the first Version of the row, independently think their account Version is greater than what is currently stored in the database and update the entry. In fact, the problem is worse than that. Consider the following test that first updates the accounts concurrently using two different versions, 2 and 3 , and then getting the account and asserting that the account version should always be the latest, which is 3 . [Microsoft.Coyote.SystematicTesting.Test] public static async Task TestGetAccountAfterConcurrentUpdate() { // Initialize the mock in-memory DB and account manager. var dbCollection = new InMemoryDbCollection(); var accountManager = new AccountManager(dbCollection); string accountName = \"MyAccount\"; // Create the account, it should complete successfully and return true. var result = await accountManager.CreateAccount(accountName, \"first_version\", 1); Assert.True(result); // Call UpdateAccount twice without awaiting, which makes both methods run // asynchronously with each other. var task1 = accountManager.UpdateAccount(accountName, \"second_version\", 2); var task2 = accountManager.UpdateAccount(accountName, \"third_version\", 3); // Then wait both requests to complete. await Task.WhenAll(task1, task2); // Finally, get the account and assert that the version is always 3, // which is the latest updated version. var account = await accountManager.GetAccount(accountName); Assert.True(account.Version == 3); } Build the code, rewrite the assembly and run the test using Coyote for 10 iterations. This test will fail in some iterations with account version 2 overwriting version 3 . You can see that this is not just a benign failure! The code doesn\u2019t respect the UpdateAccount semantics in the presence of concurrency, which is a serious issue. A database system like Cosmos DB provides ETags which you can use to only update the row if the ETags match. This ensures that UpdateAccount will fail if another concurrent request updates the row after UpdateAccount has read it, which indicates that UpdateAccount operated on stale data. Let\u2019s take a look at a correct implementation of UpdateAccount that uses ETags. // Returns true if the account is updated, else false. public async Task<bool> UpdateAccount(string accountName, string accountPayload, int accountVersion) { Account existingAccount; Guid existingAccountETag; // Naive retry if ETags mismatch. In production, you would either use a proper retry // policy with delays or return a response to the caller requesting them to retry. while (true) { try { (string value, Guid etag) = await this.AccountCollection.GetRow(accountName); existingAccount = JsonSerializer.Deserialize<Account>(value); existingAccountETag = etag; } catch (RowNotFoundException) { return false; } if (accountVersion <= existingAccount.Version) { return false; } var updatedAccount = new Account() { Name = accountName, Payload = accountPayload, Version = accountVersion }; try { return await this.AccountCollection.UpdateRow( accountName, JsonSerializer.Serialize(updatedAccount), existingAccountETag); } catch (MismatchedETagException) { continue; } catch (RowNotFoundException) { return false; } } } Let\u2019s extend the IDbCollection interface and InMemoryDbCollection mock to support ETags so that you can run the above test. You can also define a helper DbRow class in your mock to store the database row value with its associated ETag. public class DbRow { public string Value { get; set; } public Guid ETag { get; set; } } public interface IDbCollection { Task<bool> CreateRow(string key, string value); Task<bool> DoesRowExist(string key); Task<(string value, Guid etag)> GetRow(string key); Task<bool> UpdateRow(string key, string value, Guid etag); Task<bool> DeleteRow(string key); } public class InMemoryDbCollection : IDbCollection { private readonly ConcurrentDictionary<string, DbRow> Collection; public InMemoryDbCollection() { this.Collection = new ConcurrentDictionary<string, DbRow>(); } public Task<bool> CreateRow(string key, string value) { return Task.Run(() => { // Generate a new ETag when creating a brand new row. var dbRow = new DbRow() { Value = value, ETag = Guid.NewGuid() }; bool success = this.Collection.TryAdd(key, dbRow); if (!success) { throw new RowAlreadyExistsException(); } return true; }); } public Task<(string value, Guid etag)> GetRow(string key) { return Task.Run(() => { bool success = this.Collection.TryGetValue(key, out DbRow dbRow); if (!success) { throw new RowNotFoundException(); } return (dbRow.Value, dbRow.ETag); }); } public Task<bool> UpdateRow(string key, string value, Guid etag) { return Task.Run(() => { lock (this.Collection) { bool success = this.Collection.TryGetValue(key, out DbRow existingDbRow); if (!success) { throw new RowNotFoundException(); } else if (etag != existingDbRow.ETag) { throw new MismatchedETagException(); } // Update the Etag value when updating the row. var dbRow = new DbRow() { Value = value, ETag = Guid.NewGuid() }; this.Collection[key] = dbRow; return true; } }); } /* Rest of the methods not shown for simplicity */ } The above InMemoryDbCollection mock simulates the ETag semantics of Cosmos DB. You can see how the rest of the InMemoryDbCollection methods are implemented in the AccountManager.ETags sample, which is available in the Coyote Samples git repo . Build the code one last time, rewrite the assembly and run the test using Coyote for 10 iterations. This time the test succeeds! If you try to remove the ETag check, it will fail as expected. As you can see, it didn\u2019t take much effort to simulate ETags in the mock, as you just simulated the semantics in-memory . This is significantly easier than if you had to implement the real ETags functionality in a production distributed system, where you would have to worry about arbitrary failures, coordination across machines and network delays. Mocks are often fairly easy to write and help ensure that your distributed service works correctly in the presence of arbitrary concurrency across a fleet of machines.","title":"Walkthrough"},{"location":"tutorials/mocks/optimistic-concurrency-control/#get-the-sample-source-code","text":"To get the complete source code for the AccountManager.ETags tutorial, clone the Coyote Samples git repo . You can build the sample by running the following command: powershell -f build.ps1","title":"Get the sample source code"}]}