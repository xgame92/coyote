<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://microsoft.github.io/coyote/tutorials/mocks/mock-dependencies/">
    <link rel="shortcut icon" href="/coyote/img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Mocking dependencies for testing - Coyote</title>
    <link href="/coyote/css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="/coyote/css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="/coyote/css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="/coyote/css/highlight.css">
    <link href="../../../css/main.css" rel="stylesheet">
    <link href="../../../css/player-controls.css" rel="stylesheet">
    <link href="../../../css/syntax.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="/coyote/js/jquery-3.2.1.min.js"></script>
    <script src="/coyote/js/bootstrap-3.3.7.min.js"></script>
    <script src="/coyote/js/highlight.pack.js"></script>
    <script src="https://consentdeliveryfd.azurefd.net/mscc/lib/v2/wcp-consent.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '/coyote/';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Mocking dependencies for concurrency unit testing", url: "#_top", children: [
          ]},
          {title: "What you will need", url: "#what-you-will-need", children: [
          ]},
          {title: "Walkthrough", url: "#walkthrough", children: [
          ]},
          {title: "Get the sample source code", url: "#get-the-sample-source-code", children: [
          ]},
        ];

    </script>
    <script src="/coyote/js/base.js"></script>
      <script src="../../../assets/js/analytics.js"></script>
      <script src="../../../assets/js/plugins.js"></script>
      <script src="../../../assets/js/animate_trace.js"></script>
      <script src="../../../assets/js/animation.js"></script>
      <script src="../../../assets/js/progress_bar.js"></script>
      <script src="../../../assets/js/trace_model.js"></script>
      <script src="../../../assets/js/main.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>

<div id="cookie-banner"></div>


<div class="wrapper wm-page-content">
  <div class="container-fluid">
    <a name="_top"></a>
      

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../optimistic-concurrency-control/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../optimistic-concurrency-control/" class="btn btn-xs btn-link">
        Simulating optimistic concurrency control
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../test-concurrent-operations/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../test-concurrent-operations/" class="btn btn-xs btn-link">
        Test concurrent CRUD operations
      </a>
    </div>
    
  </div>

      

      <h2 id="mocking-dependencies-for-concurrency-unit-testing">Mocking dependencies for concurrency unit testing</h2>
<p>Mocking dependencies is a common activity when writing unit tests. The code that you want to test
often depends on other more complex code, such as third-party libraries and external services (e.g.
<a href="https://azure.microsoft.com/services/cosmos-db/">Cosmos DB</a>). These dependencies might be
impractical to include as part of the test, so you want to replace them with much simpler
implementations that simulate the real behavior. One popular way to replace real dependencies with
mocks is via <a href="https://en.wikipedia.org/wiki/Dependency_injection">dependency injection</a>.</p>
<p>Mocks play an even greater role when <a href="../../../concepts/concurrency-unit-testing/">writing concurrency unit
tests</a>. Coyote explores different interleavings during
each testing iteration, so you have to write mocks that simulate the behavior of the real dependency
by returning the correct response no matter which interleaving is explored. This means that when
testing with Coyote, you need to design mocks with concurrency in mind.</p>
<p>In this tutorial, you will write a simple mock for the <code>IDbCollection</code> that was introduced in <a href="../../first-concurrency-unit-test/">write
your first concurrency unit test</a>. You will design this mock to
be used in a concurrent setting, where methods in multiple instances of the class can be called
concurrently, either within the same process or across processes and machines. This latter condition
means that using locks in your code will not help you in writing correct concurrent code.</p>
<h2 id="what-you-will-need">What you will need</h2>
<p>To run the code in this tutorial, you will need to:</p>
<ul>
<li>Install <a href="https://visualstudio.microsoft.com/downloads/">Visual Studio 2019</a>.</li>
<li>Install the <a href="../../../get-started/install/">.NET 5.0 version of the coyote tool</a>.</li>
<li>Be familiar with the <code>coyote</code> tool. See <a href="../../../get-started/using-coyote/">using Coyote</a>.</li>
<li>Go through the <a href="../../first-concurrency-unit-test/">write your first concurrency unit test</a> tutorial.</li>
</ul>
<h2 id="walkthrough">Walkthrough</h2>
<p>Consider the following deliberately buggy implementation of the <code>AccountManager.CreateAccount</code>
method:</p>
<pre><code class="language-csharp">// Returns true if the account is created, else false.
public async Task&lt;bool&gt; CreateAccount(string accountName, string accountPayload)
{
  if (await this.AccountCollection.DoesRowExist(accountName))
  {
    return false;
  }

  return await this.AccountCollection.CreateRow(accountName, accountPayload);
}
</code></pre>
<p>and consider this simple <code>InMemoryDbCollection</code> mock for the <code>IDbCollection</code> interface, which
implements the <code>CreateRow</code> and <code>DoesRowExist</code> methods used in the above method. You can ignore the
<code>GetRow</code> and <code>DeleteRow</code> methods for now as they aren&rsquo;t used in <code>CreateAccount</code>.</p>
<pre><code class="language-csharp">public class InMemoryDbCollection : IDbCollection
{
  public Task&lt;bool&gt; CreateRow(string key, string value)
  {
    return Task.FromResult(true);
  }

  public Task&lt;bool&gt; DoesRowExist(string key)
  {
    return Task.FromResult(false);
  }

  public Task&lt;string&gt; GetRow(string key) { ... }
  public Task&lt;bool&gt; DeleteRow(string key) { ... }
}
</code></pre>
<p>Using this simple mock, you can write a unit test to exercise <em>sequential</em> account creation in the
<code>AccountManager</code> class (see <a href="../../first-concurrency-unit-test/">write your first concurrency unit
test</a> for the <code>AccountManager</code> code).</p>
<pre><code class="language-csharp">[Microsoft.Coyote.SystematicTesting.Test]
public static async Task TestAccountCreation()
{
  // Initialize the mock DB and account manager.
  var dbCollection = new InMemoryDbCollection();
  var accountManager = new AccountManager(dbCollection);

  // Create some dummy data.
  string accountName = &quot;MyAccount&quot;;
  string accountPayload = &quot;...&quot;;

  // Create the account, it should complete successfully and return true.
  var result = await accountManager.CreateAccount(accountName, accountPayload);
  Assert.True(result);
}
</code></pre>
<p>After building the code, rewrite the assembly and run the test using Coyote for <code>10</code> iterations:</p>
<pre><code class="language-plain">coyote rewrite .\AccountManager.dll
coyote test .\AccountManager.dll -m TestAccountCreation -i 10
</code></pre>
<p>The test succeeds.</p>
<pre><code class="language-plain">. Testing .\AccountManager.dll
... Method TestAccountCreation
... Started the testing task scheduler (process:9072).
... Created '1' testing task (process:9072).
... Task 0 is using 'random' strategy (seed:2168858778).
..... Iteration #1
..... Iteration #2
..... Iteration #3
..... Iteration #4
..... Iteration #5
..... Iteration #6
..... Iteration #7
..... Iteration #8
..... Iteration #9
..... Iteration #10
... Testing statistics:
..... Found 0 bugs.
... Scheduling statistics:
..... Explored 10 schedules: 10 fair and 0 unfair.
..... Number of scheduling points in fair terminating schedules: 0 (min), 0 (avg), 0 (max).
... Elapsed 0.1182 sec.
</code></pre>
<p>This works, but can this same mock also be used to pass the test if it was executing concurrently?</p>
<p>Go ahead and try it out on the following concurrency unit test.</p>
<pre><code class="language-csharp">[Microsoft.Coyote.SystematicTesting.Test]
public static async Task TestConcurrentAccountCreation()
{
  // Initialize the mock DB and account manager.
  var dbCollection = new InMemoryDbCollection();
  var accountManager = new AccountManager(dbCollection);

  // Create some dummy data.
  string accountName = &quot;MyAccount&quot;;
  string accountPayload = &quot;...&quot;;

  // Call CreateAccount twice without awaiting, which makes both methods run
  // asynchronously with each other.
  var task1 = accountManager.CreateAccount(accountName, accountPayload);
  var task2 = accountManager.CreateAccount(accountName, accountPayload);

  // Then wait both requests to complete.
  await Task.WhenAll(task1, task2);

  // Finally, assert that only one of the two requests succeeded and the other
  // failed. Note that we do not know which one of the two succeeded as the
  // requests ran concurrently (this is why we use an exclusive OR).
  Assert.True(task1.Result ^ task2.Result);
}
</code></pre>
<p>Build the code again, and then rewrite the assembly and run the test using Coyote for <code>10</code>
iterations:</p>
<pre><code class="language-plain">coyote rewrite .\AccountManager.dll
coyote test .\AccountManager.dll -m TestConcurrentAccountCreation -i 10
</code></pre>
<p>This time the test immediately (and always) fails!</p>
<pre><code class="language-plain">. Testing .\AccountManager.dll
... Method TestConcurrentAccountCreation
... Started the testing task scheduler (process:13328).
... Created '1' testing task (process:13328).
... Task 0 is using 'random' strategy (seed:802918651).
..... Iteration #1
... Task 0 found a bug.
... Emitting task 0 traces:
..... Writing AccountManager.dll\CoyoteOutput\AccountManager_0_0.txt
..... Writing AccountManager.dll\CoyoteOutput\AccountManager_0_0.schedule
... Elapsed 0.0798435 sec.
... Testing statistics:
..... Found 1 bug.
... Scheduling statistics:
..... Explored 1 schedule: 1 fair and 0 unfair.
..... Found 100.00% buggy schedules.
..... Number of scheduling points in fair terminating schedules: 5 (min), 5 (avg), 5 (max).
... Elapsed 0.1867838 sec.
</code></pre>
<p>Your test asserts that one <code>CreateAccount</code> call must succeed and the other must fail, but both calls
succeed with the current mock. This is because the <code>dbCollection.DoesRowExist</code> mock method <em>always</em>
returns <code>false</code> and the <code>dbCollection.CreateRow</code> mock method <em>always</em> returns <code>true</code> no matter what
order the two <code>CreateAccount</code> requests execute. The <code>dbCollection.DoesRowExist</code> method should only
return <code>false</code> if the account doesn&rsquo;t exist and the <code>dbCollection.CreateRow</code> method should only
return <code>true</code> if a new row was created.</p>
<p>The mock needs to implement more of the stateful behavior of the database as follows:</p>
<pre><code class="language-csharp">public class InMemoryDbCollection : IDbCollection
{
  private bool UserExists = false;

  public Task&lt;bool&gt; CreateRow(string key, string value)
  {
    if (this.UserExists)
    {
      throw new RowAlreadyExistsException();
    }

    this.UserExists = true;
    return Task.FromResult(true);
  }

  public Task&lt;bool&gt; DoesRowExist(string key)
  {
    return Task.FromResult(this.UserExists);
  }

  public Task&lt;string&gt; GetRow(string key) { ... }
  public Task&lt;bool&gt; DeleteRow(string key) { ... }
}
</code></pre>
<p>The above mock is a bit more complicated as it models the <code>DoesRowExist</code> and <code>CreateRow</code> behavior
more precisely for your test. Build, rewrite and run the same test once again.</p>
<pre><code class="language-plain">. Testing .\AccountManager.dll
... Method TestConcurrentAccountCreation
... Started the testing task scheduler (process:38080).
... Created '1' testing task (process:38080).
... Task 0 is using 'random' strategy (seed:2983982407).
..... Iteration #1
..... Iteration #2
..... Iteration #3
..... Iteration #4
..... Iteration #5
..... Iteration #6
..... Iteration #7
..... Iteration #8
..... Iteration #9
..... Iteration #10
... Testing statistics:
..... Found 0 bugs.
... Scheduling statistics:
..... Explored 10 schedules: 10 fair and 0 unfair.
..... Number of scheduling points in fair terminating schedules: 2 (min), 3 (avg), 6 (max).
... Elapsed 0.1560682 sec.
</code></pre>
<p>The assertion will now pass, but the <code>CreateAccount</code> method is actually buggy (read the <a href="../../first-concurrency-unit-test/">write your
first concurrency unit test</a> tutorial to remember why that is).
Why does the assertion not fail?!</p>
<p>The reason is that while the two asynchronous <code>CreateAccount</code> methods are invoked concurrently,
there is no <em>actual</em> concurrency in the test. While your code uses async/await methods, no code path
introduces any concurrency (through <code>Task.Run</code>, <code>Task.Yield</code> etc), which means that the two methods
execute sequentially, one after another. Let&rsquo;s see how you can inject some concurrency which will
allow Coyote to &ldquo;shake&rdquo; the system and uncover the bug!</p>
<p>There are a few ways to make the test truly concurrent. One simple way is to tweak the mock so that
it uses <code>Task.Run</code> to <a href="https://docs.microsoft.com/dotnet/api/system.threading.tasks.task.run">start a new
task</a> whenever its methods
are invoked.</p>
<pre><code class="language-csharp">public class InMemoryDbCollection : IDbCollection
{
  private bool UserExists = false;

  public Task&lt;bool&gt; CreateRow(string key, string value)
  {
    return Task.Run(() =&gt;
    {
      if (this.UserExists)
      {
        throw new RowAlreadyExistsException();
      }

      this.UserExists = true;
      return true;
    });
  }

  public Task&lt;bool&gt; DoesRowExist(string key)
  {
    return Task.Run(() =&gt;
    {
      return this.UserExists;
    });
  }

  public Task&lt;string&gt; GetRow(string key) { ... }
  public Task&lt;bool&gt; DeleteRow(string key) { ... }
}
</code></pre>
<p>If you run the <code>TestConcurrentAccountCreation</code> test again using the above mock version, you will see
that the bug in <code>CreateAccount</code> is now triggered and the assertion fails!</p>
<pre><code class="language-plain">. Testing .\AccountManager.dll
... Method TestConcurrentAccountCreation
... Started the testing task scheduler (process:17760).
... Created '1' testing task (process:17760).
... Task 0 is using 'random' strategy (seed:641979276).
..... Iteration #1
..... Iteration #2
..... Iteration #3
..... Iteration #4
..... Iteration #5
..... Iteration #6
..... Iteration #7
..... Iteration #8
... Task 0 found a bug.
... Emitting task 0 traces:
..... Writing AccountManager.dll\CoyoteOutput\AccountManager_0_0.txt
..... Writing AccountManager.dll\CoyoteOutput\AccountManager_0_0.schedule
... Elapsed 0.0902799 sec.
... Testing statistics:
..... Found 1 bug.
... Scheduling statistics:
..... Explored 8 schedules: 8 fair and 0 unfair.
..... Found 12.50% buggy schedules.
..... Number of scheduling points in fair terminating schedules: 10 (min), 14 (avg), 23 (max).
... Elapsed 0.198829 sec.
</code></pre>
<p>Awesome! Using <code>Task.Run</code> in the mock methods introduces concurrency in the test, which allows the
two <code>CreateAccount</code> methods to execute asynchronously and race with each other. This is similar to
how invoking the production implementation of <code>IDbCollection</code> (i.e. the actual backend NoSQL
database) typically happens asynchronously.</p>
<p>Can you make the above mock a little more generally applicable, so you don&rsquo;t have to write custom
mocks for each test case? What if you model it in a way that more closely simulates the behavior of
the actual <code>IDbCollection</code>? You could write a mock that you can use in all your concurrency unit
tests for the <code>AccountManager</code> using a <code>ConcurrentDictionary</code>:</p>
<pre><code class="language-csharp">public class InMemoryDbCollection : IDbCollection
{
  private readonly ConcurrentDictionary&lt;string, string&gt; Collection;

  public InMemoryDbCollection()
  {
    this.Collection = new ConcurrentDictionary&lt;string, string&gt;();
  }

  public Task&lt;bool&gt; CreateRow(string key, string value)
  {
    return Task.Run(() =&gt;
    {
      var success = this.Collection.TryAdd(key, value);
      if (!success)
      {
        throw new RowAlreadyExistsException();
      }

      return true;
    });
  }

  public Task&lt;bool&gt; DoesRowExist(string key)
  {
    return Task.Run(() =&gt;
    {
      return this.Collection.ContainsKey(key);
    });
  }

  public Task&lt;string&gt; GetRow(string key) { ... }
  public Task&lt;bool&gt; DeleteRow(string key) { ... }
}
</code></pre>
<p>Through a very simple change, which is to add a <code>ConcurrentDictionary</code> collection to back the
in-memory database, you have now written a simple mock that not only simulates the behavior of
<em>asynchronously</em> adding rows and checking for their existence, but also can be used in many
different concurrency unit tests for the <code>AccountManager</code> logic. For example, this mock can be used
in the <code>TestConcurrentAccountCreationAndDeletion</code> test that exercises a race between a
<code>CreateAccount</code> and <code>DeleteAccount</code> request in this <a href="../../test-concurrent-operations/">tutorial</a>.</p>
<p>You can now complete the mock by implementing the <code>GetRow</code> and <code>DeleteRow</code> methods.</p>
<pre><code class="language-csharp">public Task&lt;string&gt; GetRow(string key)
{
  return Task.Run(() =&gt;
  {
    var success = collection.TryGetValue(key, out string value);
    if (!success)
    {
      throw new RowNotFoundException();
    }

    return value;
  });
}

public Task&lt;bool&gt; DeleteRow(string key)
{
  return Task.Run(() =&gt;
  {
    var success = collection.TryRemove(key);
    if (!success)
    {
      throw new RowNotFoundException();
    }

    return true;
  });
}
</code></pre>
<p>The above is the complete implementation of the <code>InMemoryDbCollection</code> mock that you used in the
<a href="../../first-concurrency-unit-test/">write your first concurrency unit test</a> tutorial.</p>
<p>Mocks that can be used in concurrency unit tests are often surprisingly easy to write and have the
benefit that they can be reused in multiple testing scenarios as they more closely model the
production behavior of the mocked dependency. Teams in Azure have
<a href="../../../case-studies/azure-blockchain-service/">reported</a> that spending a little effort to write such
mocks yielded large productivity gains through better concurrency testing coverage.</p>
<p>The cool thing is that writing mocks for testing with Coyote can be done in a &ldquo;pay-as-you-go&rdquo;
fashion where the initial mock implementation can be as simple as you want, and more functionality
can be added later to cover increasingly more complex testing scenarios. Even simple mocks can help
you write interesting concurrency unit tests that can find tons of bugs in your code!</p>
<p>In the <a href="../optimistic-concurrency-control/">next tutorial</a>, you will learn how to extend the above
mock to simulate optimistic concurrency control using ETags. Adding support for ETags combined with
the <a href="../../../concepts/concurrency-unit-testing/">systematic testing</a> of Coyote will allow you to
test a scenario that is fairly hard to hit in production but can lead to data loss.</p>
<h2 id="get-the-sample-source-code">Get the sample source code</h2>
<p>To get the complete source code for the <code>AccountManager</code> tutorial, clone the
<a href="http://github.com/microsoft/coyote-samples">Coyote Samples git repo</a>.</p>
<p>You can build the sample by running the following command:</p>
<pre><code class="language-plain">powershell -f build.ps1
</code></pre>

    <br>
      

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../optimistic-concurrency-control/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../optimistic-concurrency-control/" class="btn btn-xs btn-link">
        Simulating optimistic concurrency control
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../test-concurrent-operations/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../test-concurrent-operations/" class="btn btn-xs btn-link">
        Test concurrent CRUD operations
      </a>
    </div>
    
  </div>

      <br>
  </div>
</div>

<footer class="wm-page-content">
  

<section class="footer-join pt-40 pb-80">
  <div class="container-fluid">
    <div class="row text-center">
      <div class="col-sm-8 col-sm-offset-2">
      </div>
    </div>
    <div class="row">
   </div>
  </div>
</section>
<section class="footer-dark pt-60">
  <div class="container-fluid">
    <div class="row">
      <div class="hidden-xs col-sm-5 col-lg-6">
        <a href="" title="homepage" class="logo-footer">
          <img src="/coyote/assets/images/icon.png" alt="Coyote">
        </a>
      </div>

      <div class="col-sm-2 col-xs-4 footer-dark-col">
        <nav>
          <h4>Coyote</h4>
          <ul class="list-unstyled">
            <li><a href="/coyote/">Home</a></li>
            <li><a href="/coyote/get-started/install/">Install</a></li>
          </ul>
        </nav>
      </div>

      <div class="col-sm-2 col-xs-4 footer-dark-col">
        <nav>
          <h4>Resources</h4>
          <ul class="list-unstyled">
            <li><a href="/coyote/tutorials/first-concurrency-unit-test/">Getting started</a></li>
            <li><a href="/coyote/tutorials/overview/">Tutorials</a></li>
            <li><a href="/coyote/ref/Microsoft.Coyote">API documentation</a></li>
          </ul>
        </nav>
      </div>

      <div class="col-sm-2 col-xs-4 footer-dark-col">
        <nav>
          <h4>Community</h4>
          <ul class="list-unstyled">
            <li><a href="https://github.com/microsoft/coyote/"><i class="fa fa-github"></i>
GitHub</a></li>
            <li><a href="https://twitter.com/coyote_dev" target="_blank"><i class="fa fa-twitter"></i> Twitter</a></li>
            <li><a href="https://gitter.im/microsoft/coyote" target="_blank">Gitter</a></li>
          </ul>
        </nav>
      </div>
    </div>

    <div class="row footnote pt-50 pb-20">
      <div class="col-sm-12">
        <hr>
      </div>
      <div class="col-sm-6">
        <ul class="list-unstyled list-inline footnote-copy">
          <li><a href="https://privacy.microsoft.com/en-us/privacystatement/" target="_blank">Privacy</a></li>
          <li><a href="https://www.microsoft.com/en-us/legal/intellectualproperty/copyright/default.aspx" target="_blank">Terms of Use</a></li>
          <li><a href="https://github.com/microsoft/coyote/blob/main/LICENSE" target="_blank">License</a></li>
          <li><a href="javascript:manageCookies()">Cookies</a></li>
        </ul>
      </div>
      <div class="col-sm-6 text-right footnote-copy">
        <ul class="list-unstyled list-inline">
          <li><span id="copyright"></span></li>
          <li><a href="https://www.microsoft.com/" target="_blank"><img class="img-responsive" src="/coyote/assets/images/microsoft-logo.svg?v=3" alt="Microsoft">&nbsp;</a></li>
        </ul>
      </div>
    </div>
  </div>
</section>
</footer>


<script type="text/javascript">
    $(document).ready(function () {
      $('table').each(function () {
        $(this).addClass("table");
        $(this).addClass("table-bordered");
        $(this).addClass("table-striped");
        $(this).addClass("table-condensed");
      });

    });
</script>

</body>
</html>